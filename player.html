<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player - Peras TV</title> <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    </head>
<body class="player-page"> <div id="player-page-loading" class="status-message loading">Loading player...</div>
<div id="player-page-error" class="status-message error" style="display: none;"></div>

<div id="player-page-content" style="display: none; width: 100%; height: 100%; display: flex; flex-direction: column;">

    <div class="player-area">
        <div class="loader"></div>
        <div class="player-message" role="alert"></div>
        <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe>
        <video controls autoplay muted playsinline title="Stream Player"></video>
        <button class="custom-fullscreen-btn" aria-label="Enter Fullscreen" title="Enter Fullscreen">
            </button>
    </div>

    <div class="stream-buttons">
        </div>

    <p class="box-disclaimer">
        Disclaimer: This site embeds content from external sources. We do not host streams. Availability and quality not guaranteed. Use responsibly.
    </p>

</div>


<script>
    // --- Player Page Logic ---
    (function() {
        // --- Configuration ---
        const CONFIG = {
            channelsUrl: "channels.json",
            matchesUrl: "matches.json",
            placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%231a1a1a"/></svg>',
            iframeLoadTimeoutMs: 35000
        };

        // --- SVG Icons for Fullscreen Button ---
        const SVG_ENTER_FULLSCREEN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"> <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> </svg>`;
        const SVG_EXIT_FULLSCREEN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"> <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/> </svg>`;


        // --- DOM Elements ---
        const loadingElement = document.getElementById('player-page-loading');
        const errorElement = document.getElementById('player-page-error');
        const contentElement = document.getElementById('player-page-content');
        // Player elements within the container
        const playerAreaElement = contentElement.querySelector('.player-area');
        const streamButtonsContainer = contentElement.querySelector('.stream-buttons');
        const videoElement = contentElement.querySelector('video');
        const iframeElement = contentElement.querySelector('iframe');
        const loaderElement = contentElement.querySelector('.loader');
        const messageContainerElement = contentElement.querySelector('.player-message');
        // --- NEW: Custom fullscreen button ---
        const customFullscreenButton = playerAreaElement.querySelector('.custom-fullscreen-btn');

        // --- State ---
        let currentHlsInstance = null;
        let itemData = null; // To store the found channel/match data

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const itemId = urlParams.get('item');

            if (!itemId) {
                showError("Error: No item specified in the URL.");
                return;
            }
            console.log("Player page loading for item:", itemId);
            setupCustomFullscreenButton(); // --- NEW: Setup listener
            loadItemDataAndInitialize(itemId);
        });

        // --- Data Loading ---
        async function loadItemDataAndInitialize(itemId) {
            try {
                showLoading(); // Use function

                // Fetch both data sources concurrently
                const cacheBuster = `?t=${Date.now()}`;
                const [channelsResponse, matchesResponse] = await Promise.all([
                    fetch(CONFIG.channelsUrl + cacheBuster),
                    fetch(CONFIG.matchesUrl + cacheBuster)
                ]);

                if (!channelsResponse.ok) throw new Error(`Failed to load channels: ${channelsResponse.statusText}`);
                if (!matchesResponse.ok) throw new Error(`Failed to load matches: ${matchesResponse.statusText}`);

                const allChannelsData = await channelsResponse.json();
                const allMatchesData = await matchesResponse.json();

                // Find the item data based on the ID
                itemData = findItemById(itemId, allChannelsData, allMatchesData);

                if (!itemData) {
                    throw new Error(`Item with ID "${itemId}" not found.`);
                }

                console.log("Found item data:", itemData);
                initializePlayerUI();

            } catch (error) {
                console.error("Failed to load item data:", error);
                showError(`Error loading player: ${error.message}`);
            } finally {
                hideLoading(); // Use function
            }
        }

        /**
         * Finds the channel or match data corresponding to the given unique ID.
         * @param {string} itemId - The unique ID (e.g., 'PT-channel-0', 'match-1').
         * @param {object} channelsData - The fetched channels JSON object.
         * @param {Array} matchesData - The fetched matches JSON array.
         * @returns {object | null} The found item data object or null.
         */
        function findItemById(itemId, channelsData, matchesData) {
             if (itemId.startsWith('match-')) {
                const matchIndex = parseInt(itemId.split('-')[1], 10);
                if (!isNaN(matchIndex) && matchIndex >= 0 && matchIndex < matchesData.length) {
                    return { ...matchesData[matchIndex], itemType: 'match', name: `${matchesData[matchIndex].team1} vs ${matchesData[matchIndex].team2}` };
                }
            } else if (itemId.includes('-channel-')) {
                const parts = itemId.split('-'); const category = parts[0]; const channelIndex = parseInt(parts[parts.length - 1], 10);
                if (channelsData[category] && !isNaN(channelIndex) && channelIndex >= 0 && channelIndex < channelsData[category].length) {
                    return { ...channelsData[category][channelIndex], itemType: 'channel' };
                }
            }
            return null; // Not found
        }

        // --- UI Initialization ---
        function initializePlayerUI() {
            if (!itemData) return;

            // Set page title
            const itemName = itemData.name || 'Player';
            document.title = `${itemName} - Peras TV`;
            // No separate header title element anymore

            // Populate stream buttons and auto-load first stream
            populateStreamsAndLoadFirst(); // No need to pass box element anymore

            // Show the content area
            contentElement.style.display = 'flex'; // Use flex for column layout
        }

        // --- Status Display ---
        function showLoading() {
            loadingElement.style.display = 'block';
            errorElement.style.display = 'none';
            contentElement.style.display = 'none';
        }
        function hideLoading() {
             loadingElement.style.display = 'none';
        }
        function showError(message) {
            hideLoading();
            contentElement.style.display = 'none';
            errorElement.innerHTML = `<strong>Error</strong><span>${message}</span>`;
            errorElement.style.display = 'block';
        }

        // --- Player Logic (Adapted from index.html) ---
        // NOTE: These functions now operate directly on the elements defined in this scope.

        /**
         * Populates stream buttons and attempts to auto-load the first stream.
         */
        function populateStreamsAndLoadFirst() {
            // Extract sources based on item type
            let sourcesData = null;
            if (itemData.itemType === 'channel') {
                sourcesData = itemData.srcs; // Simple array
            } else if (itemData.itemType === 'match') {
                sourcesData = { pt: itemData.pt || [], uk: itemData.uk || [], es: itemData.es || [] }; // Object with languages
            }

            if (!sourcesData || !streamButtonsContainer || !playerAreaElement) {
                 displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); return;
            }

            streamButtonsContainer.innerHTML = '';
            let firstStreamUrl = null; let firstStreamButtonElement = null; let streamCount = 0;
            const fragment = document.createDocumentFragment();

            try {
                 // --- Populate Buttons ---
                if (Array.isArray(sourcesData)) { // Channel
                    sourcesData.forEach((src) => {
                        const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null);
                        const label = typeof src === 'object' && src.label ? src.label : `Source ${streamCount + 1}`;
                        if (url) { if (!firstStreamUrl) firstStreamUrl = url; const button = createStreamSourceButton(label, url); if (!firstStreamButtonElement) firstStreamButtonElement = button; fragment.appendChild(button); streamCount++; }
                    });
                } else if (typeof sourcesData === 'object' && sourcesData !== null) { // Match
                    Object.entries(sourcesData).forEach(([langKey, sourcesInLang]) => {
                        if (sourcesInLang && Array.isArray(sourcesInLang) && sourcesInLang.length > 0) {
                            const langGroupDiv = document.createElement('div'); const langLabel = document.createElement('strong'); langLabel.textContent = `${langKey.toUpperCase()}:`; langGroupDiv.appendChild(langLabel);
                            sourcesInLang.forEach((src) => {
                                const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null);
                                const label = typeof src === 'object' && src.label ? src.label : `Src ${streamCount + 1}`;
                                 if (url) { if (!firstStreamUrl) firstStreamUrl = url; const button = createStreamSourceButton(label, url); if (!firstStreamButtonElement) firstStreamButtonElement = button; langGroupDiv.appendChild(button); streamCount++; }
                            }); fragment.appendChild(langGroupDiv);
                        }
                    });
                }
                streamButtonsContainer.appendChild(fragment);

                // --- Handle Auto-load ---
                if (streamCount === 0) { displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerState(); }
                else if (firstStreamUrl && firstStreamButtonElement) { console.log("Auto-loading first stream for player page."); loadStreamIntoPlayer(firstStreamButtonElement, firstStreamUrl); }
                else { console.error("Inconsistency: Streams counted, but no first URL/Button."); displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerState(); }
            } catch (error) {
                console.error("Failed to parse sources/create buttons:", error);
                streamButtonsContainer.innerHTML = '<p class="status-message error">Error loading sources.</p>';
                clearPlayerState();
            }
        }

        function displayNoStreamsAvailable(playerArea, buttonsContainer) { /* ... (keep existing code) ... */
             const message = 'No stream sources listed for this item.';
             if (buttonsContainer) buttonsContainer.innerHTML = `<p style="color: var(--text-secondary); font-size: 0.9em; padding: 10px 0;">${message}</p>`;
             if (playerArea) displayMessageInPlayerArea(playerArea, `<strong>No Streams Available</strong><span>${message}</span>`, false);
        }

        function createStreamSourceButton(label, url) {
           const buttonElement = document.createElement('button');
           buttonElement.className = 'stream-button';
           buttonElement.textContent = label || 'Source';
           buttonElement.dataset.streamUrl = url;
           buttonElement.onclick = (event) => {
               event.stopPropagation();
               console.log(`Loading stream in player page: ${label} (${url})`);
               loadStreamIntoPlayer(buttonElement, url);
           };
           return buttonElement;
       }

        function loadStreamIntoPlayer(clickedButtonElement, streamUrl) { /* ... (keep existing code - simplified) ... */
            if (!streamUrl || typeof streamUrl !== 'string') return;
            console.log(`>>> Player Page: loadStreamIntoPlayer START: ${streamUrl}`);
            clearPlayerState(); messageContainerElement.classList.remove('visible'); loaderElement.classList.add('visible');
            streamButtonsContainer.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active')); if (clickedButtonElement) clickedButtonElement.classList.add('active');
            if (!streamUrl.startsWith('http://') && !streamUrl.startsWith('https://')) { loaderElement.classList.remove('visible'); displayMessageInPlayerArea(playerAreaElement, `<strong>Invalid URL</strong><span>Link must start with http/https.</span>`, true, streamUrl); return; }
            setTimeout(() => { try { const urlObject = new URL(streamUrl); if (urlObject.pathname.toLowerCase().endsWith('.m3u8')) loadHlsStreamIntoVideo(streamUrl, videoElement, playerAreaElement); else loadUrlIntoIframe(streamUrl, iframeElement, playerAreaElement); } catch (error) { loaderElement.classList.remove('visible'); displayMessageInPlayerArea(playerAreaElement, `<strong>URL Error</strong><span>Could not process link.</span>`, true, streamUrl); } }, 50);
        }

        function clearPlayerState() { /* ... (keep existing code) ... */
            if (currentHlsInstance && videoElement && currentHlsInstance.media === videoElement) { try { currentHlsInstance.destroy(); } catch (e) {} currentHlsInstance = null; }
            if (iframeElement) { if (iframeElement.getAttribute('src') && iframeElement.getAttribute('src') !== 'about:blank') iframeElement.src = 'about:blank'; iframeElement.classList.remove('active'); }
            if (videoElement) { videoElement.pause(); if (videoElement.hasAttribute('src')) videoElement.removeAttribute('src'); if (videoElement.currentSrc) videoElement.load(); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; }
            if (loaderElement) loaderElement.classList.remove('visible'); if (messageContainerElement) messageContainerElement.classList.remove('visible');
            streamButtonsContainer.querySelectorAll('.stream-button.active').forEach(b => b.classList.remove('active'));
            // --- NEW: Hide custom fullscreen button ---
            if (customFullscreenButton) customFullscreenButton.style.display = 'none';
            updateFullscreenButtonState(); // Reset icon
        }

        function displayMessageInPlayerArea(playerArea, messageHtml, showTryNextButton, failedUrl = null) { /* ... (keep existing code - simplified Try Next) ... */
             if (!messageContainerElement || !loaderElement || !playerArea) return;
             if (videoElement) videoElement.classList.remove('active'); if (iframeElement) iframeElement.classList.remove('active'); loaderElement.classList.remove('visible'); messageContainerElement.innerHTML = messageHtml;
             if (showTryNextButton && failedUrl) {
                 const nextButtonElement = findNextAvailableStreamButton(failedUrl);
                 if (nextButtonElement) { const tryNextBtn = document.createElement('button'); tryNextBtn.className = 'try-next-button'; tryNextBtn.textContent = 'Try Next Source'; tryNextBtn.onclick = (event) => { event.stopPropagation(); nextButtonElement.click(); }; messageContainerElement.appendChild(document.createElement('br')); messageContainerElement.appendChild(tryNextBtn); }
                 else { const noMoreSpan = document.createElement('span'); noMoreSpan.style.cssText = 'font-size:0.8em;margin-top:10px;display:block;'; noMoreSpan.textContent = '(No more sources available)'; messageContainerElement.appendChild(noMoreSpan); }
             } messageContainerElement.classList.add('visible');
             // --- NEW: Hide custom fullscreen button ---
             if (customFullscreenButton) customFullscreenButton.style.display = 'none';
             updateFullscreenButtonState(); // Reset icon
        }

        function findNextAvailableStreamButton(failedUrl) { /* ... (keep existing code - simplified) ... */
            if (!failedUrl) return null; const allButtons = streamButtonsContainer.querySelectorAll('.stream-button'); let foundFailed = false;
            for (let i = 0; i < allButtons.length; i++) { if (allButtons[i].dataset.streamUrl === failedUrl) foundFailed = true; else if (foundFailed) return allButtons[i]; } return null;
        }

        function loadHlsStreamIntoVideo(hlsUrl, videoEl, playerArea) { /* ... (keep existing code) ... */
             videoEl.poster = CONFIG.placeholderImage;
            if (Hls.isSupported()) {
                if (currentHlsInstance && currentHlsInstance.media === videoEl) { currentHlsInstance.destroy(); currentHlsInstance = null; } else if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; }
                currentHlsInstance = new Hls({ /* ... HLS config ... */ });
                const hlsErrorListener = (event, data) => { if (!currentHlsInstance || currentHlsInstance.media !== videoEl) return; console.error('HLS Error:', data.type, data.details, data.fatal); let msg = `Stream Error (${data.details||'Unknown'})`; if(data.fatal){ displayMessageInPlayerArea(playerArea, `<strong>${msg}</strong>`, true, hlsUrl); if(currentHlsInstance && currentHlsInstance.media === videoEl){currentHlsInstance.destroy(); currentHlsInstance=null;} videoEl.classList.remove('active'); videoEl.poster=CONFIG.placeholderImage; } };
                const hlsManifestParsedListener = () => { if (!currentHlsInstance || currentHlsInstance.media !== videoEl) return; playerArea.querySelector('.loader').classList.remove('visible'); videoEl.classList.add('active'); videoEl.muted = true; videoEl.play().catch(e => { if(currentHlsInstance && currentHlsInstance.media === videoEl){ displayMessageInPlayerArea(playerArea, `<strong>Playback Error</strong><span>${e.name==='NotAllowedError'?'Click play.':e.message}</span>`, e.name !== 'NotAllowedError', hlsUrl); if(e.name !== 'NotAllowedError') videoEl.classList.remove('active'); playerArea.querySelector('.loader').classList.remove('visible'); } }); };
                currentHlsInstance.on(Hls.Events.ERROR, hlsErrorListener); currentHlsInstance.on(Hls.Events.MANIFEST_PARSED, hlsManifestParsedListener);
                currentHlsInstance.attachMedia(videoEl); currentHlsInstance.loadSource(hlsUrl);
            } else if (videoEl.canPlayType('application/vnd.apple.mpegurl')) {
                 if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; }
                 const handleNativeLoadedMetadata = () => { if (videoEl.getAttribute('src') !== hlsUrl) return; playerArea.querySelector('.loader').classList.remove('visible'); videoEl.classList.add('active'); videoEl.muted = true; videoEl.play().catch(e => { if(videoEl.getAttribute('src') === hlsUrl){ displayMessageInPlayerArea(playerArea, `<strong>Playback Error</strong><span>${e.name==='NotAllowedError'?'Click play.':e.message}</span>`, e.name !== 'NotAllowedError', hlsUrl); if(e.name !== 'NotAllowedError') videoEl.classList.remove('active'); playerArea.querySelector('.loader').classList.remove('visible'); } }); };
                 const handleNativeError = () => { if (videoEl.getAttribute('src') !== hlsUrl) return; const err = videoEl.error; const msg = err ? (err.message || `code ${err.code}`) : 'Unknown'; displayMessageInPlayerArea(playerArea, `<strong>Stream Error</strong><span>Native HLS failed: ${msg}.</span>`, true, hlsUrl); videoEl.classList.remove('active'); videoEl.poster = CONFIG.placeholderImage; playerArea.querySelector('.loader').classList.remove('visible'); };
                 videoEl.removeEventListener('loadedmetadata', handleNativeLoadedMetadata); videoEl.removeEventListener('error', handleNativeError); videoEl.addEventListener('loadedmetadata', handleNativeLoadedMetadata); videoEl.addEventListener('error', handleNativeError);
                 videoEl.src = hlsUrl; videoEl.load();
            } else { displayMessageInPlayerArea(playerArea, `<strong>Unsupported Stream</strong><span>Browser cannot play HLS.</span>`, false); videoEl.classList.remove('active'); videoEl.poster = CONFIG.placeholderImage; playerArea.querySelector('.loader').classList.remove('visible'); }
            // --- NEW: Show custom fullscreen button ---
            if (customFullscreenButton) customFullscreenButton.style.display = 'block';
            updateFullscreenButtonState();
        }

        function loadUrlIntoIframe(iframeUrl, iframeEl, playerArea) { /* ... (keep existing code) ... */
             let iframeLoadTimeoutId = null; let isLoadSuccessful = false;
            if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; }
            const cleanup = () => { clearTimeout(iframeLoadTimeoutId); iframeEl.onload = null; iframeEl.onerror = null; };
            const handleFailure = (reason) => { cleanup(); if (iframeEl.getAttribute('src') === iframeUrl) { displayMessageInPlayerArea(playerArea, `<strong>Stream Error</strong><span>${reason}. Might be offline/blocked.</span>`, true, iframeUrl); iframeEl.classList.remove('active'); iframeEl.src = 'about:blank'; playerArea.querySelector('.loader').classList.remove('visible'); } };
            iframeLoadTimeoutId = setTimeout(() => { if (!isLoadSuccessful && iframeEl.getAttribute('src') === iframeUrl) handleFailure(`Load timeout (${CONFIG.iframeLoadTimeoutMs / 1000}s)`); }, CONFIG.iframeLoadTimeoutMs);
            iframeEl.onload = () => { if (iframeEl.getAttribute('src') === iframeUrl) { isLoadSuccessful = true; cleanup(); playerArea.querySelector('.loader').classList.remove('visible'); iframeEl.classList.add('active'); } else if (iframeEl.getAttribute('src') !== 'about:blank') { /* ignore */ } };
            iframeEl.onerror = () => { if (iframeEl.getAttribute('src') === iframeUrl) handleFailure("onError event fired"); };
            iframeEl.src = iframeUrl;
            // --- NEW: Show custom fullscreen button ---
            if (customFullscreenButton) customFullscreenButton.style.display = 'block';
            updateFullscreenButtonState();
        }

        // --- NEW: Custom Fullscreen Logic ---
        /**
         * Sets up the event listener for the custom fullscreen button.
         */
        function setupCustomFullscreenButton() {
            if (!customFullscreenButton) return;

            // Set initial icon
            updateFullscreenButtonState();

            customFullscreenButton.onclick = () => {
                // Determine which element is active and should be fullscreened
                const elementToFullscreen = iframeElement.classList.contains('active') ? iframeElement : (videoElement.classList.contains('active') ? videoElement : null);

                if (!elementToFullscreen) {
                    console.warn("No active element (iframe/video) found to fullscreen on player page.");
                    return;
                }

                toggleBrowserFullscreen(elementToFullscreen);
            };

            // Listen for fullscreen changes to update button icon
            document.addEventListener('fullscreenchange', updateFullscreenButtonState);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButtonState);
            document.addEventListener('mozfullscreenchange', updateFullscreenButtonState);
            document.addEventListener('MSFullscreenChange', updateFullscreenButtonState);
        }

        /**
         * Toggles fullscreen mode for a given element using the Fullscreen API.
         * @param {HTMLElement} element The element to make fullscreen (iframe or video).
         */
        function toggleBrowserFullscreen(element) {
            if (!element) return;

            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                // --- Enter Fullscreen ---
                console.log("Requesting fullscreen for element:", element);
                if (element.requestFullscreen) {
                    element.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                } else if (element.webkitRequestFullscreen) { /* Safari */
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) { /* Firefox */
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) { /* IE11 */
                    element.msRequestFullscreen();
                }
            } else {
                // --- Exit Fullscreen ---
                console.log("Exiting fullscreen.");
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        }

        /**
         * Updates the appearance (icon, label) of the custom fullscreen button
         * based on the current fullscreen state of the document.
         */
        function updateFullscreenButtonState() {
            if (!customFullscreenButton) return;

            const isFullscreenActive = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

            if (isFullscreenActive) {
                customFullscreenButton.innerHTML = SVG_EXIT_FULLSCREEN;
                customFullscreenButton.setAttribute('aria-label', 'Exit Fullscreen');
                customFullscreenButton.setAttribute('title', 'Exit Fullscreen');
            } else {
                customFullscreenButton.innerHTML = SVG_ENTER_FULLSCREEN;
                customFullscreenButton.setAttribute('aria-label', 'Enter Fullscreen');
                customFullscreenButton.setAttribute('title', 'Enter Fullscreen');
            }
             console.log("Player page fullscreen state changed. Is active:", isFullscreenActive);
        }
        // --- End NEW Custom Fullscreen Logic ---


    })(); // End of IIFE
</script>

</body>
</html>
