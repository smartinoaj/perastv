<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- CSS Variables (Theme) --- */
        :root {
            /* True Grayscale/Black Theme */
            --bg-primary: #0a0a0a; /* Near black */
            --bg-secondary: #1a1a1a; /* Very dark gray */
            --bg-tertiary: #2a2a2a; /* Dark gray */
            --accent-color: #e50914; /* Netflix-like red */
            --text-primary: #ffffff; /* White */
            --text-secondary: #a0a0a0; /* Medium gray */
            --border-color: #3a3a3a; /* Gray for borders */
            --border-color-active: #6b7280; /* Lighter border for hover/focus */
            --error-color: #f87171; /* Light red for errors */
            --font-sans: 'Inter', sans-serif;
        }

        /* --- Basic Reset & Body Styling --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html {
            scroll-behavior: smooth;
            height: 100%; /* Ensure html takes full height */
        }
        body {
            background-color: var(--bg-primary); color: var(--text-primary);
            font-family: var(--font-sans); line-height: 1.6;
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh on mobile */
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            padding-bottom: 60px; /* Add padding to prevent footer overlap */
            position: relative; /* Needed for footer positioning */
        }
        .container { max-width: 1600px; margin: 0 auto; padding: 0 20px; }

        /* --- Main Layout: Header --- */
        header { text-align: center; padding: 30px 0 20px; }
        header img { max-width: 200px; height: auto; } /* Logo size */

        /* --- Search Bar --- */
        .search-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            padding: 0 15px;
        }
        #search-input {
            padding: 12px 18px;
            font-size: 1em;
            border-radius: 25px; /* Pill shape */
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            width: 100%;
            max-width: 500px; /* Limit search bar width */
            transition: all 0.2s ease;
            text-align: center; /* Center the text and placeholder */
        }
        #search-input:focus {
            outline: none;
            border-color: var(--border-color-active);
            background-color: var(--bg-tertiary);
        }
        #search-input::placeholder { color: var(--text-secondary); text-align: center; }
        /* Cross-browser placeholder centering */
        #search-input::-webkit-input-placeholder { text-align: center; }
        #search-input:-moz-placeholder { text-align: center; }
        #search-input::-moz-placeholder { text-align: center; }
        #search-input:-ms-input-placeholder { text-align: center; }


        /* --- Tabs --- */
        .tabs {
            display: flex; justify-content: center; gap: 12px;
            margin-bottom: 40px; flex-wrap: wrap; /* Allow wrapping on small screens */
            padding: 0 10px;
        }
        .tab-button {
            background: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-color); padding: 10px 25px; cursor: pointer;
            border-radius: 20px; font-size: 0.9em; font-weight: 600;
            transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .tab-button:hover { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--bg-tertiary); }
        .tab-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); }

        /* --- Channel Grid (General) --- */
        .channel-grid {
            display: grid;
            /* Default: Auto-fill columns, min 260px wide */
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px; padding: 0 10px 50px; /* Add bottom padding */
            display: none; /* Hidden by default, shown by JS */
        }
        /* --- Grid Column Adjustments for Non-Match Tabs --- */
        @media (min-width: 768px) { /* Medium screens (tablets) */
            .channel-grid:not(#Matches) {
                 grid-template-columns: repeat(2, 1fr); /* 2 columns */
            }
        }
        @media (min-width: 1024px) { /* Large screens (desktops) */
             .channel-grid:not(#Matches) {
                 grid-template-columns: repeat(3, 1fr); /* 3 columns */
            }
        }
        /* No 4-column rule needed */

        /* --- Grid Layout for Matches Tab --- */
        #Matches.channel-grid {
             grid-template-columns: 1fr; /* Always single column */
             max-width: 1000px; /* Limit width of the single column */
             margin: 0 auto; /* Center the grid */
        }

        /* Show active grid */
        .channel-grid.active { display: grid; }


        /* --- Channel Box (General Styling) --- */
        .channel-box {
            background: var(--bg-secondary); border-radius: 10px; padding: 15px;
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid var(--bg-secondary); position: relative; overflow: hidden;
        }

        /* --- Wider & Consistent Match Box (Not Expanded) --- */
        /* This rule makes the non-expanded match boxes wider and the same size */
        #Matches .channel-box:not(.expanded) {
            width: 95%;      /* Use percentage for width relative to the centered grid */
            max-width: 1000px; /* Optional: Ensure it doesn't exceed grid max-width */
            margin-left: auto; /* Center the box within the column */
            margin-right: auto;
        }

        /* Hide filtered-out boxes */
        .channel-box.hidden { display: none; }

        /* Hover effect for non-expanded boxes */
        .channel-box:not(.expanded):hover {
            transform: translateY(-4px); /* Slight lift effect */
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
            border-color: var(--border-color-active);
        }

        /* --- Channel Header (Inside Box) --- */
        .channel-header {
            display: flex; align-items: center;
            justify-content: center; /* Center channel name by default */
            gap: 10px; text-align: center; min-height: 35px; cursor: pointer;
        }
         /* --- Matches Header Layout --- */
        #Matches .channel-header {
             justify-content: center; /* Center team names/logos */
             gap: 0; /* Remove gap, use margins on h3 */
             text-align: center;
        }
        /* Logo styling (used for match logos) */
        .match-logo {
            height: 40px; width: 40px; /* Logo size */
            object-fit: contain; /* Prevent distortion */
            flex-shrink: 0; /* Prevent shrinking */
            border-radius: 4px; /* Slightly rounded corners */
            display: inline-block; /* Align with text */
            vertical-align: middle;
        }
        /* Ensure match logos within header use specific styling if needed */
        .channel-header img.match-logo {
             height: 40px;
             width: auto; /* Allow width to adjust based on height */
             object-fit: contain;
        }
        /* Channel/Match Title */
        .channel-header h3 {
            font-size: 1.1em;
            font-weight: 600; margin: 0;
            word-break: break-word; /* Prevent long names overflowing */
            text-align: center;
            flex-grow: 0; /* Don't grow */
            flex-shrink: 1; /* Allow shrinking if needed */
            /* Add horizontal margin for match titles to create space from logos */
            margin-left: 25px;
            margin-right: 25px;
        }
        /* Reset margins for non-match titles */
         .channel-grid:not(#Matches) .channel-header h3 {
             margin-left: 0;
             margin-right: 0;
         }

        /* Channel Info (League/Time for Matches) */
        .channel-info {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: center; /* Center info text */
            margin-top: 8px; /* Space below header */
            margin-left: 0; /* Reset potential inherited margins */
            margin-bottom: 0;
            font-weight: 500; cursor: pointer; /* Make clickable to toggle */
        }
        .channel-info span { margin: 0 5px; } /* Spacing around separator */

        /* --- Expanded Channel Box Styling --- */
        .channel-box.expanded {
            grid-column: 1 / -1; /* Span full grid width */
            cursor: default; /* Not clickable anymore */
            background: var(--bg-tertiary); /* Slightly lighter background */
            padding-bottom: 20px; z-index: 10; /* Bring to front */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color); /* Highlight border */
            overflow: visible; /* Allow potential dropdowns/tooltips */
            /* Reset width constraints applied to non-expanded match boxes */
            max-width: none;
            width: auto;
            margin-left: 0;
            margin-right: 0;
        }
        /* Make header/info non-clickable when expanded */
        .channel-box.expanded .channel-header,
        .channel-box.expanded .channel-info { cursor: default; }

        /* --- Player Area (Inside Expanded Box) --- */
        .iframe-container { margin-top: 18px; display: none; width: 100%; }
        /* Show container when box is expanded */
        .channel-box.expanded .iframe-container { display: block; }
        .player-area {
            position: relative; width: 100%; aspect-ratio: 16 / 9; /* Maintain 16:9 */
            background-color: #000; border-radius: 8px; overflow: hidden;
            margin-bottom: 18px; min-height: 200px; /* Minimum height on mobile */
            /* Center loader/messages */
            display: flex; justify-content: center; align-items: center;
        }
        /* Player elements (iframe/video) */
        .player-area iframe, .player-area video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: none; display: none; /* Hidden by default */
            object-fit: contain; /* Fit video within player area */
        }
        /* Show active player */
        .player-area iframe.active, .player-area video.active { display: block; }
        /* Message area (for errors, instructions) */
        .player-message {
            color: var(--text-secondary); font-size: 0.9em; padding: 20px;
            text-align: center; display: none; /* Hidden by default */
        }
        .player-message.visible { display: block; }
        .player-message strong { color: var(--text-primary); display: block; margin-bottom: 5px; }
        .player-message button { margin-top: 15px; } /* Spacing for 'Try Next' button */
        /* Loading spinner */
        .loader {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-color); /* Accent color for spinner */
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
        }
        .loader.visible { display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive player height adjustments */
        @media (min-width: 768px) { .channel-box.expanded .player-area { min-height: 400px; max-height: 70vh; } }
        @media (min-width: 1024px) { .channel-box.expanded .player-area { min-height: 480px; } }

        /* --- Stream Buttons (Inside Expanded Box) --- */
        .stream-buttons { text-align: center; margin-top: 15px; }
        /* Language group styling (for matches) */
        .stream-buttons div { margin-bottom: 10px; }
        .stream-buttons strong {
            color: var(--text-secondary); font-size: 0.85em; margin-right: 8px;
            font-weight: 600; text-transform: uppercase;
        }
        /* Individual stream button */
        .stream-button {
            background: var(--bg-secondary); color: var(--text-primary);
            border: 1px solid var(--border-color); padding: 7px 18px;
            border-radius: 20px; cursor: pointer; font-size: 0.85em;
            font-weight: 500; transition: all 0.2s ease;
            display: inline-block; /* Allow multiple buttons per line */
            margin: 4px; /* Spacing between buttons */
        }
        .stream-button:hover { background: #4a4a4a; border-color: #5a5a5a; }
        /* Active stream button */
        .stream-button.active {
            background: var(--accent-color); color: white;
            border-color: var(--accent-color); font-weight: 600;
        }
        /* 'Try Next' button shown on error */
        .try-next-button {
            background: var(--accent-color); color: white;
            border: none; padding: 8px 15px; border-radius: 6px;
            cursor: pointer; font-size: 0.85em; font-weight: 500;
            transition: background-color 0.2s ease;
        }
        .try-next-button:hover { background-color: #b80710; } /* Darker red on hover */

        /* --- Footer --- */
        footer {
            text-align: center; color: var(--text-secondary); font-size: 0.8em;
            padding: 20px 0;
            width: 100%;
            margin-top: 40px; /* Space above footer */
            /* position: absolute; /* Optional: Stick to bottom if content is short */
            /* bottom: 0; */
        }

        /* --- Loading/Error States (General Page Load) --- */
        .loading-message, .error-message { text-align: center; padding: 50px 20px; color: var(--text-secondary); font-size: 1em; font-weight: 500; }

        /* --- Responsive Adjustments --- */
        /* @media (max-width: 1023px) { ... } <-- REMOVED conflicting rule for match box width */

        @media (max-width: 767px) { /* Mobile screens */
             /* Force 1 column for ALL grids */
             .channel-grid { grid-template-columns: 1fr; }
             /* Adjust padding/sizing */
             .channel-box { padding: 15px; }
             .stream-button { padding: 6px 15px; font-size: 0.8em; }
             header img { max-width: 160px; }
             .tabs { gap: 10px; margin-bottom: 30px; }
             .tab-button { padding: 8px 20px; font-size: 0.85em; }
             /* Ensure Matches grid takes full width */
             #Matches.channel-grid { max-width: 100%; }
             /* Adjust match header spacing */
             #Matches .channel-header { gap: 10px; }
             .match-logo, #Matches .channel-header img.match-logo { height: 32px; width: 32px; }
             .channel-info { font-size: 0.75em;}
             /* #Matches .channel-box:not(.expanded) { max-width: 100%; } <-- REMOVED conflicting rule */
             #Matches .channel-header h3 { margin: 0 15px; } /* Adjust title margin */
        }
        @media (max-width: 480px) { /* Very small screens */
            .container { padding: 0 10px; } /* Reduce container padding */
            header img { max-width: 140px; }
            .tabs { gap: 8px; }
            .tab-button { padding: 7px 15px; }
            .channel-box { padding: 12px; }
            .channel-header h3 { font-size: 1em; margin: 0 10px;} /* Smaller title margin */
            .match-logo, #Matches .channel-header img.match-logo { height: 30px; width: 30px; }
            /* Stack language label above buttons */
            .stream-buttons strong { display: block; margin-bottom: 5px; }
            .player-area { min-height: 200px; } /* Ensure minimum player height */
            #search-input { padding: 10px 15px; font-size: 0.95em; }
             .channel-info { font-size: 0.7em;}
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <img src="ptvlogo.png" alt="PERAS TV Logo">
    </header>

    <div class="search-container">
        <input type="search" id="search-input" placeholder="Search channels or matches...">
    </div>

    <div class="tabs">
        <button class="tab-button active" data-tab="PT">PT</button>
        <button class="tab-button" data-tab="UK">UK</button>
        <button class="tab-button" data-tab="ES">ES</button>
        <button class="tab-button" data-tab="Matches">Matches</button>
    </div>

    <div id="loadingMessage" class="loading-message">Loading channels...</div>
    <div id="fetchErrorMessage" class="error-message" style="display: none;"></div>

    <div id="PT" class="channel-grid active"></div>
    <div id="UK" class="channel-grid"></div>
    <div id="ES" class="channel-grid"></div>
    <div id="Matches" class="channel-grid"></div>

</div> <footer>
    <p id="lastUpdated"></p> </footer>

<script>
    /* --- JavaScript --- */

    // --- Configuration Constants ---
    const CONFIG = {
        channelsUrl: "channels.json", // Path to channels data
        matchesUrl: "matches.json",   // Path to matches data
        // Simple black SVG placeholder for video poster
        placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%23000000"/></svg>',
        searchDebounceMs: 300,        // Delay (ms) for search input filtering
        lastTabKey: 'perasTvLastTab'  // LocalStorage key for remembering the last tab
    };

    // --- DOM Element References ---
    const searchInput = document.getElementById('search-input');
    const tabsContainer = document.querySelector('.tabs');
    const channelGrids = document.querySelectorAll('.channel-grid');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const loadingMessage = document.getElementById('loadingMessage');
    const fetchErrorMessage = document.getElementById('fetchErrorMessage');

    // --- Application State ---
    let hlsInstance = null;             // Holds the current HLS.js instance
    let channelsData = {};              // Stores fetched channel data (by language)
    let matchesData = [];               // Stores fetched match data
    let currentlyExpandedBox = null;    // Tracks the currently open channel/match box
    let searchDebounceTimer = null;     // Timer for debouncing search input

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners(); // Set up tab clicks, search, etc.
        updateTimestamp();     // Display initial time
        loadData();            // Fetch channel and match data
    });

    // --- Event Listener Setup ---
    function setupEventListeners() {
        // Tab Button Clicks
        tabsContainer.addEventListener('click', (event) => {
            if (event.target.classList.contains('tab-button')) {
                showTab(event.target.dataset.tab); // Switch to the clicked tab
            }
        });

        // Search Input (Debounced)
        const debouncedFilter = debounce((term) => {
            filterChannels(term); // Filter channels after user stops typing
        }, CONFIG.searchDebounceMs);

        searchInput.addEventListener('input', (event) => {
            debouncedFilter(event.target.value);
        });

        // Global Keydown Listener (for Escape key)
        document.addEventListener('keydown', (event) => {
            // If Escape is pressed and a box is expanded, collapse it
            if (event.key === 'Escape' && currentlyExpandedBox) {
                 toggleExpansion(currentlyExpandedBox);
            }
        });
    }

    // --- Data Fetching & Initial Rendering ---
    async function loadData() {
        loadingMessage.style.display = 'block'; // Show loading message
        fetchErrorMessage.style.display = 'none'; // Hide any previous errors
        try {
            // Add cache-busting query parameter to prevent stale data
            const cacheBuster = `?t=${Date.now()}`;
            // Fetch both channels and matches data concurrently
            const [channelsRes, matchesRes] = await Promise.all([
                fetch(CONFIG.channelsUrl + cacheBuster),
                fetch(CONFIG.matchesUrl + cacheBuster)
            ]);

            // Check if both fetch requests were successful
            if (!channelsRes.ok || !matchesRes.ok) {
                throw new Error(`Failed to load data (Channels: ${channelsRes.status}, Matches: ${matchesRes.status})`);
            }

            // Parse JSON data
            channelsData = await channelsRes.json();
            matchesData = await matchesRes.json();

            // Render all channels and matches into their respective grids
            renderAllChannels();
            loadingMessage.style.display = 'none'; // Hide loading message

            // Restore last viewed tab from LocalStorage or default to 'PT'
            const lastTab = localStorage.getItem(CONFIG.lastTabKey) || 'PT';
            showTab(lastTab); // Activate the appropriate tab and grid

        } catch (error) {
            // Handle errors during data fetching
            console.error("Failed to load channel or match data:", error);
            loadingMessage.style.display = 'none'; // Hide loading message
            fetchErrorMessage.textContent = `Error loading data: ${error.message}. Please try refreshing.`;
            fetchErrorMessage.style.display = 'block'; // Show error message
        }
    }

    // --- Rendering Functions ---
    function renderAllChannels() {
        // Render channels for each language tab
        renderChannels('PT', channelsData.PT || []);
        renderChannels('UK', channelsData.UK || []);
        renderChannels('ES', channelsData.ES || []);
        // Render matches in the 'Matches' tab
        renderMatchChannels(matchesData || []);
        // Add click listeners to all newly created channel/match boxes
        addChannelBoxEventListeners();
    }

    // Renders channel boxes for a specific tab
    function renderChannels(tabId, channels) {
        const grid = document.getElementById(tabId);
        if (!grid) return; // Exit if grid element not found
        grid.innerHTML = ''; // Clear previous content
        // Display message if no channels are available for this tab
        if (!channels || channels.length === 0) {
            grid.innerHTML = '<p class="loading-message">No channels available.</p>';
            return;
        }
        // Create and append a box for each channel
        channels.forEach((channel, index) => {
            const uniqueId = `${tabId}-channel-${index}`; // Create a unique ID
            const box = createChannelBoxElement(channel, uniqueId);
            grid.appendChild(box);
        });
    }

    // Renders match boxes in the 'Matches' tab
    function renderMatchChannels(matches) {
        const grid = document.getElementById('Matches');
        if (!grid) return; // Exit if grid element not found
        grid.innerHTML = ''; // Clear previous content
        // Display message if no matches are available
         if (!matches || matches.length === 0) {
            grid.innerHTML = '<p class="loading-message">No matches available.</p>';
            return;
        }
        // Create and append a box for each match
        matches.forEach((match, index) => {
             const uniqueId = `match-${index}`; // Create a unique ID
            const box = createMatchBoxElement(match, uniqueId);
            grid.appendChild(box);
        });
    }

    // --- Element Creation Functions ---

    // Creates HTML for a standard channel box
    function createChannelBoxElement(channel, uniqueId) {
        const { name, srcs = [] } = channel; // Destructure channel data
        const box = document.createElement('div');
        box.className = 'channel-box';
        box.dataset.channelName = name; // Store name for searching
        box.dataset.sources = JSON.stringify(srcs); // Store sources as JSON string
        box.id = uniqueId; // Assign unique ID

        // Inner HTML structure for the channel box
        box.innerHTML = `
            <div class="channel-header" id="${uniqueId}-header" aria-expanded="false" aria-controls="${uniqueId}-player-container">
                <h3>${name}</h3>
            </div>
            <div class="iframe-container" id="${uniqueId}-player-container" role="region" aria-labelledby="${uniqueId}-header">
                <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message"></div>
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons"></div>
            </div>
        `;
        return box;
    }

     // Creates HTML for a match box
     function createMatchBoxElement(match, uniqueId) {
        // Destructure match data, providing defaults for missing fields
        const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = match;
        const box = document.createElement('div');
        box.className = 'channel-box';
        const allSources = { pt, uk, es }; // Group sources by language
        const matchTitle = `${team1} vs ${team2}`;
        box.dataset.channelName = matchTitle; // Store title for searching
        // Store additional terms for more flexible searching
        box.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase();
        box.dataset.sources = JSON.stringify(allSources); // Store sources as JSON string
        box.id = uniqueId; // Assign unique ID

        // Inner HTML structure for the match box
        // *** THE COMMENT HAS BEEN REMOVED FROM THE LINE BELOW ***
        box.innerHTML = `
            <div class="channel-header" id="${uniqueId}-header" aria-expanded="false" aria-controls="${uniqueId}-player-container">
                 ${logo1 ? `<img src="${logo1}" alt="${team1} logo" class="match-logo">` : '<span class="match-logo"></span>'}
                 <h3>${matchTitle}</h3>
                 ${logo2 ? `<img src="${logo2}" alt="${team2} logo" class="match-logo">` : '<span class="match-logo"></span>'}
            </div>
            <div class="channel-info">
                ${league ? `<span>${league}</span>` : ''}
                ${league && time ? '<span>|</span>' : ''}
                ${time ? `<span>${time}</span>` : ''}
            </div>
             <div class="iframe-container" id="${uniqueId}-player-container" role="region" aria-labelledby="${uniqueId}-header">
                 <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message"></div>
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons"></div>
            </div>
        `;
        // Add error handling for missing logos
        box.querySelectorAll('img.match-logo').forEach(img => {
            img.onerror = () => { img.style.display = 'none'; }; // Hide broken image icons
        });
        return box;
    }

     // Creates a single stream button element
     function createStreamButtonWrapper(label, url, contextBox) {
        const button = document.createElement('button');
        button.className = 'stream-button';
        button.textContent = label; // Button text (e.g., "PM", "DL", "Source 1")
        button.dataset.streamUrl = url; // Store URL in data attribute
        // Set click handler to change the stream
        button.onclick = (e) => {
            e.stopPropagation(); // Prevent click from bubbling up to the box toggle
            changeStream(button, url, contextBox);
        };
        return button;
    }


    // --- Event Listener Setup for Dynamic Channel Boxes ---
    function addChannelBoxEventListeners() {
         document.querySelectorAll('.channel-box').forEach(box => {
            // Use specific listeners for header/info to toggle expand/collapse
            const header = box.querySelector('.channel-header');
            const info = box.querySelector('.channel-info'); // Might be null for non-match boxes

            const toggleHandler = (event) => {
                 // Prevent toggle if a button inside header/info was clicked (unlikely but safe)
                 if (!event.target.closest('.stream-button')) {
                    toggleExpansion(box);
                 }
            };

            if (header) header.addEventListener('click', toggleHandler);
            if (info) info.addEventListener('click', toggleHandler); // Add listener only if info exists

            // Prevent clicks directly on the box (outside header/info/player) from doing anything when expanded
            box.addEventListener('click', (event) => {
                const isExpanded = box.classList.contains('expanded');
                const isClickOnPlayerArea = event.target.closest('.iframe-container');
                const isClickOnHeaderOrInfo = event.target.closest('.channel-header') || event.target.closest('.channel-info');

                // Only toggle if box is NOT expanded and click is NOT on player/header/info
                if (!isExpanded && !isClickOnPlayerArea && !isClickOnHeaderOrInfo) {
                    // This case is less likely now with header/info listeners, but kept for safety
                    // toggleExpansion(box);
                }
                // Clicks inside player area are handled by player controls/buttons
                // Clicks on header/info are handled by their specific listeners
            });
        });
    }

    // --- Tab Management ---
    function showTab(tabId) {
        // Update active state for tab buttons
        tabsContainer.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });
        // Update active state for channel grids
        channelGrids.forEach(grid => {
            grid.classList.toggle('active', grid.id === tabId);
        });
        // Collapse any currently expanded box when switching tabs
        if (currentlyExpandedBox) {
            collapseBox(currentlyExpandedBox);
        }
        // Store the newly selected tab in LocalStorage
        localStorage.setItem(CONFIG.lastTabKey, tabId);
        // Clear search input and filter when switching tabs
        searchInput.value = '';
        filterChannels('');
    }

    // --- Search Filtering ---
    function filterChannels(searchTerm) {
        const term = searchTerm.toLowerCase().trim(); // Normalize search term
        document.querySelectorAll('.channel-box').forEach(box => {
            // Check if the term matches channel name or additional search terms (for matches)
            const channelName = box.dataset.channelName?.toLowerCase() || '';
            const searchTerms = box.dataset.searchTerms?.toLowerCase() || ''; // Includes teams, league
            const isVisible = channelName.includes(term) || searchTerms.includes(term);
            // Show/hide the box based on visibility
            box.classList.toggle('hidden', !isVisible);

            // Collapse the box if it's filtered out while expanded
            if (!isVisible && box.classList.contains('expanded')) {
                 collapseBox(box);
            }
        });
    }

    // --- Channel Box Expansion/Collapse Logic ---
    function toggleExpansion(boxToToggle) {
        const isExpanding = !boxToToggle.classList.contains('expanded');
        const header = boxToToggle.querySelector('.channel-header'); // For aria attribute

        // If expanding a new box, collapse the currently open one first
        if (isExpanding && currentlyExpandedBox && currentlyExpandedBox !== boxToToggle) {
            collapseBox(currentlyExpandedBox);
        }

        // Expand or collapse the target box
        if (isExpanding) {
            expandBox(boxToToggle);
            if(header) header.setAttribute('aria-expanded', 'true');
        } else {
            collapseBox(boxToToggle);
             if(header) header.setAttribute('aria-expanded', 'false');
        }
    }

    // Expands a channel box
    function expandBox(box) {
        box.classList.add('expanded');
        currentlyExpandedBox = box; // Track the expanded box
        populateAndLoadFirstStream(box); // Populate buttons and load the first stream
        // Smoothly scroll the expanded box into view (nearest edge)
        setTimeout(() => {
             box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
             // Focus the first stream button for accessibility after scrolling
             const firstButton = box.querySelector('.stream-button');
             if (firstButton) {
                 setTimeout(() => firstButton.focus({ preventScroll: true }), 50); // Small delay after scroll
             }
        }, 150); // Delay scroll slightly to allow rendering
    }

    // Collapses a channel box
    function collapseBox(box) {
        box.classList.remove('expanded');
        // If this was the currently tracked expanded box, clear the tracker
        if (currentlyExpandedBox === box) {
            currentlyExpandedBox = null;
        }
        clearPlayerInBox(box); // Stop video/iframe, destroy HLS instance
        // Clear stream buttons
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) streamButtonsDiv.innerHTML = '';
        // Update aria attribute
        const header = box.querySelector('.channel-header');
        if(header) {
            header.setAttribute('aria-expanded', 'false');
        }
    }

    // Populates stream buttons and loads the first available stream
    function populateAndLoadFirstStream(box) {
        const sourcesData = box.dataset.sources; // Get sources JSON string
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (!sourcesData || !streamButtonsDiv) return; // Exit if no data or container

        streamButtonsDiv.innerHTML = ''; // Clear existing buttons
        let firstUrl = null; // To store the URL of the first stream found
        let firstButtonElement = null; // To store the first button element created

        try {
            const sources = JSON.parse(sourcesData); // Parse the JSON

            // Handle different source structures (array for channels, object for matches)
            if (Array.isArray(sources)) { // Simple array of sources (channels)
                if (sources.length > 0) {
                    sources.forEach((src, idx) => {
                        // Source can be a string URL or an object {label, url}
                        const url = typeof src === 'object' && src.url ? src.url : src;
                        const label = typeof src === 'object' && src.label ? src.label : `Source ${idx + 1}`;
                        if (!firstUrl) firstUrl = url; // Capture the first URL
                        const button = createStreamButtonWrapper(label, url, box);
                        if (!firstButtonElement) firstButtonElement = button; // Capture the first button
                        streamButtonsDiv.appendChild(button);
                    });
                } else {
                    noStreamsAvailable(streamButtonsDiv); // Show message if no sources
                }
            } else { // Object with language keys (matches)
                let streamCount = 0;
                // Iterate over language keys (pt, uk, es)
                Object.entries(sources).forEach(([lang, langSources]) => {
                    if (langSources && langSources.length > 0) {
                        // Create a container div for each language's buttons
                        const langDiv = document.createElement('div');
                        const strong = document.createElement('strong'); // Language label (e.g., "PT:")
                        strong.textContent = `${lang.toUpperCase()}:`;
                        langDiv.appendChild(strong);
                        // Create buttons for each source within the language
                        langSources.forEach((src, idx) => {
                            const url = typeof src === 'object' && src.url ? src.url : src;
                            const label = typeof src === 'object' && src.label ? src.label : `${idx + 1}`; // Use label or index
                            if (!firstUrl) firstUrl = url; // Capture the very first URL found across all languages
                            const button = createStreamButtonWrapper(label, url, box);
                             if (!firstButtonElement) firstButtonElement = button; // Capture the very first button
                            langDiv.appendChild(button);
                            streamCount++;
                        });
                        streamButtonsDiv.appendChild(langDiv); // Add language group to main button container
                    }
                });
                 if (streamCount === 0) {
                    noStreamsAvailable(streamButtonsDiv); // Show message if no sources found across all languages
                 }
            }

            // If a valid first stream was found, load it
            if (firstUrl && firstButtonElement) {
                 changeStream(firstButtonElement, firstUrl, box); // Pass button to mark as active
            } else {
                clearPlayerInBox(box); // Clear player area if no streams are available
            }
        } catch (e) {
            // Handle errors parsing the sources JSON
            console.error("Failed to parse sources data for box:", box.id, e);
            streamButtonsDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">Error loading stream data.</p>';
             clearPlayerInBox(box); // Clear player on error
        }
    }

     // Displays a message when no streams are available
     function noStreamsAvailable(container) {
         container.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">No streams available.</p>';
    }


    // --- Stream Handling Logic ---

    // Changes the stream source in the player
    function changeStream(clickedButton, url, contextBox) {
        console.log(`Attempting to load stream in box ${contextBox.id}: ${url}`);
        const playerArea = contextBox.querySelector('.player-area');
        const loader = playerArea.querySelector('.loader');
        const messageDiv = playerArea.querySelector('.player-message');

        // --- 1. Clear Previous State ---
        clearPlayerInBox(contextBox); // Stop previous video/HLS, clear iframe src
        messageDiv.classList.remove('visible'); // Hide any previous messages
        loader.classList.add('visible'); // Show loading spinner

        // --- 2. Update Button Active State ---
        const streamButtonsDiv = contextBox.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
             streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
        if (clickedButton) { // Ensure button exists before adding class
            clickedButton.classList.add('active');
        }

        // --- 3. Get Player Elements ---
        const iframe = playerArea.querySelector('iframe');
        const video = playerArea.querySelector('video');

        if (!iframe || !video) { // Should not happen, but safety check
            console.error("Could not find player elements in context box.");
            loader.classList.remove('visible');
            showPlayerMessage(playerArea, `<strong>Error:</strong> Player elements not found.`, false);
            return;
        }

        // --- 4. Load New Stream based on URL type ---
        if (url && typeof url === 'string') {
             if (url.toLowerCase().endsWith('.m3u8')) { // Check if it's an HLS stream
                loadHlsStream(url, video, playerArea);
            } else { // Assume it's an iframe-compatible URL
                loadIframeStream(url, iframe, playerArea);
            }
        } else { // Handle invalid URL
            console.error("Invalid stream URL:", url);
            loader.classList.remove('visible');
            showPlayerMessage(playerArea, `<strong>Error:</strong> Invalid stream URL provided.`, false);
            // Ensure player elements are reset even if URL is invalid
            iframe.src = 'about:blank'; iframe.classList.remove('active');
            video.pause(); video.removeAttribute('src'); video.load(); video.classList.remove('active'); video.poster = '';
        }
    }

     // Clears the player area (stops video/HLS, clears iframe)
     function clearPlayerInBox(box) {
        if (!box) return; // Safety check

        // --- 1. Destroy HLS Instance if it belongs to this box's video element ---
        // Check if hlsInstance exists AND if its attached media element is the video in the box being cleared
        if (hlsInstance && hlsInstance.media === box.querySelector('video')) {
            console.log("Destroying HLS instance for box:", box.id);
            hlsInstance.destroy();
            hlsInstance = null; // Clear the reference
        }

        // --- 2. Reset Player Elements ---
        const playerArea = box.querySelector('.player-area');
        if (!playerArea) return; // Exit if player area not found

        const iframe = playerArea.querySelector('iframe');
        const video = playerArea.querySelector('video');
        const loader = playerArea.querySelector('.loader');
        const messageDiv = playerArea.querySelector('.player-message');

        // Reset iframe
        if (iframe) {
            iframe.src = 'about:blank'; // Clear the source
            iframe.classList.remove('active'); // Hide it
        }
        // Reset video element
        if (video) {
             // Cloning the node is a robust way to remove all event listeners (like HLS ones)
             const newVideo = video.cloneNode(true);
             video.parentNode.replaceChild(newVideo, video);
             // Reset properties on the new node
             newVideo.pause();
             newVideo.removeAttribute('src'); // Remove HLS or native source
             newVideo.load(); // Important to cancel potential pending loads
             newVideo.classList.remove('active'); // Hide it
             newVideo.poster = ''; // Clear poster image
        }
        // Hide loader and message area
        if (loader) loader.classList.remove('visible');
        if (messageDiv) messageDiv.classList.remove('visible');

        // --- 3. Deactivate Stream Buttons (only within this box) ---
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
    }

    // Shows a message (error, info) in the player area
    function showPlayerMessage(playerArea, messageHtml, showTryNext, failedUrl = null, contextBox = null) {
        const messageDiv = playerArea.querySelector('.player-message');
        const loader = playerArea.querySelector('.loader');
        const video = playerArea.querySelector('video');
        const iframe = playerArea.querySelector('iframe');

        if (!messageDiv || !loader) return; // Safety check

        // Hide player elements and loader
        if (video) video.classList.remove('active');
        if (iframe) iframe.classList.remove('active');
        loader.classList.remove('visible');

        // Set message content
        messageDiv.innerHTML = messageHtml;

        // Add "Try Next Source" button if applicable
        if (showTryNext && failedUrl && contextBox) {
            const nextButton = findNextStreamButton(failedUrl, contextBox); // Find the next button
            if (nextButton) {
                const tryNextBtn = document.createElement('button');
                tryNextBtn.className = 'try-next-button';
                tryNextBtn.textContent = 'Try Next Source';
                tryNextBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent triggering box toggle
                    nextButton.click(); // Simulate click on the next stream button
                };
                messageDiv.appendChild(tryNextBtn); // Add button to message area
            }
        }
        messageDiv.classList.add('visible'); // Show the message area
    }

    // Finds the next stream button in the list relative to the failed one
    function findNextStreamButton(failedUrl, contextBox) {
        const buttons = contextBox.querySelectorAll('.stream-button');
        let foundCurrent = false;
        for (let i = 0; i < buttons.length; i++) {
            // Check if this button corresponds to the URL that failed
            if (buttons[i].dataset.streamUrl === failedUrl) {
                foundCurrent = true; // Mark that we found the failed button
            } else if (foundCurrent) {
                // If we already found the failed one, this is the next button
                return buttons[i];
            }
        }
        // Return null if the failed URL was the last one or wasn't found
        return null;
    }

    // Loads an HLS (m3u8) stream using HLS.js or native browser support
    function loadHlsStream(url, videoElement, playerArea) {
        const currentBox = videoElement.closest('.channel-box'); // Get the parent box for context
        videoElement.poster = CONFIG.placeholderImage; // Set placeholder image

        if (Hls.isSupported()) { // Check if HLS.js is supported by the browser
            console.log("HLS.js supported. Initializing...");

             // --- HLS Instance Management ---
             // Destroy previous instance *only if* it exists AND is attached to the *same* video element
             // This prevents destroying an instance belonging to a different, still potentially active, expanded box.
             if (hlsInstance && hlsInstance.media === videoElement) {
                 console.log("Destroying previous HLS instance attached to this video element.");
                 hlsInstance.destroy();
                 hlsInstance = null;
             } else if (hlsInstance && hlsInstance.media !== videoElement) {
                 console.log("Keeping existing HLS instance attached to a different video element.");
             }

            // --- Create New HLS Instance ---
            hlsInstance = new Hls({
                 // Configuration options for HLS.js (timeouts, retries, etc.)
                 manifestLoadingTimeOut: 10000, // 10s timeout for manifest
                 levelLoadingTimeOut: 10000,    // 10s timeout for level playlist
                 fragLoadingTimeOut: 15000,     // 15s timeout for fragment
                 fragLoadingMaxRetry: 4,        // Max retries for fragments
                 levelLoadingMaxRetry: 4,       // Max retries for levels
                 manifestLoadingMaxRetry: 2,    // Max retries for manifest
                 // Optional low latency settings (can sometimes cause issues)
                 // enableWorker: true,
                 // lowLatencyMode: true,
            });

            // --- HLS Error Handling ---
            hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                console.error('HLS.js Error:', event, data);
                 // Check if the error is fatal AND belongs to the currently attached video element
                 if (data.fatal && hlsInstance && videoElement === hlsInstance.media) {
                     console.log(`Fatal HLS error occurred in box ${currentBox.id}`);
                     let userMessage = `<strong>Stream Error</strong> (${data.details}).`;
                     // Provide more specific messages based on error type
                     if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                         userMessage = `<strong>Network Error</strong> loading stream (${data.details}). Check connection or try another source.`;
                     } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                         userMessage = `<strong>Media Playback Error</strong> (${data.details}). The stream might be corrupted or incompatible.`;
                     } else {
                         userMessage = `<strong>Stream Error</strong> (${data.type} - ${data.details}). The stream could not be loaded.`;
                     }

                     showPlayerMessage(playerArea, userMessage, true, url, currentBox); // Show error with "Try Next"

                     // Destroy the HLS instance associated with this error
                     hlsInstance.destroy();
                     hlsInstance = null;

                     // Clean up video element state
                     videoElement.classList.remove('active');
                     videoElement.poster = '';
                 } else if (!data.fatal) {
                     // Log non-fatal errors (e.g., retries, buffer stalls)
                     console.warn("Non-fatal HLS error:", data.details);
                 }
            });

            // --- Load and Attach Source ---
            hlsInstance.loadSource(url);
            hlsInstance.attachMedia(videoElement); // Attach HLS.js to the video element

            // --- Handle Successful Manifest Parsing ---
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                 // Ensure this callback is for the currently active HLS instance/video
                 if (hlsInstance && videoElement === hlsInstance.media) {
                    console.log("HLS Manifest parsed, attempting to play...");
                    playerArea.querySelector('.loader').classList.remove('visible'); // Hide loader
                    videoElement.classList.add('active'); // Show video element
                    videoElement.muted = true; // Mute for autoplay policies
                    // Attempt to play the video
                    videoElement.play().then(() => {
                        console.log("Playback started successfully via HLS.js.");
                    }).catch(e => { // Handle playback errors (e.g., browser restrictions)
                         console.error("HLS.js video play failed:", e);
                         if (e.name === 'NotAllowedError') {
                             // Inform user they need to interact
                             showPlayerMessage(playerArea, `<strong>Playback Paused</strong><br>Browser requires interaction. Click the play button on the video.`, false);
                         } else {
                              // Show other playback errors
                              showPlayerMessage(playerArea, `<strong>Playback Error</strong><br>${e.message}`, true, url, currentBox);
                         }
                         videoElement.classList.remove('active'); // Hide video if play fails
                         playerArea.querySelector('.loader').classList.remove('visible'); // Hide loader too
                    });
                 }
            });

        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) { // Check for native HLS support (Safari, iOS)
            console.log("Using native HLS support.");
            // --- Native HLS Handling ---
            // Clone node to clear potential previous HLS.js listeners or native errors
            const newVideo = videoElement.cloneNode(true);
            videoElement.parentNode.replaceChild(newVideo, videoElement);
            videoElement = newVideo; // Work with the new node

            videoElement.src = url; // Set the m3u8 URL directly

            // --- Native HLS Event Handlers ---
            videoElement.oncanplay = () => {
                 // Check if the src is still the one we intended to load
                 if (videoElement.getAttribute('src') === url) {
                    playerArea.querySelector('.loader').classList.remove('visible');
                    videoElement.classList.add('active');
                    videoElement.muted = true; // Mute for autoplay
                    videoElement.play().catch(e => {
                        console.error("Native HLS play failed:", e);
                        if (e.name === 'NotAllowedError') {
                            showPlayerMessage(playerArea, `<strong>Playback Paused</strong><br>Browser requires interaction. Click play.`, false);
                        } else {
                           showPlayerMessage(playerArea, `<strong>Native HLS Playback Error</strong><br>${e.message}`, true, url, currentBox);
                        }
                         videoElement.classList.remove('active');
                         playerArea.querySelector('.loader').classList.remove('visible');
                    });
                 }
            };
            videoElement.onerror = () => {
                 // Check if the error corresponds to the URL we tried to load
                 if (videoElement.getAttribute('src') === url) {
                     console.error("Native HLS playback error.");
                     showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>Could not load native HLS stream. It might be invalid or blocked.`, true, url, currentBox);
                     videoElement.classList.remove('active');
                     videoElement.poster = '';
                     playerArea.querySelector('.loader').classList.remove('visible');
                 } else {
                     console.log("Ignoring native HLS error for a different src.");
                 }
            };
             videoElement.load(); // Explicitly call load for native HLS


        } else { // HLS not supported at all
            console.error("HLS is not supported by this browser.");
            showPlayerMessage(playerArea, `<strong>Error:</strong> HLS playback is not supported in your browser.`, false);
            videoElement.classList.remove('active'); videoElement.poster = '';
            playerArea.querySelector('.loader').classList.remove('visible');
        }
    }

    // Loads a stream into an iframe
    function loadIframeStream(url, iframeElement, playerArea) {
        const currentBox = iframeElement.closest('.channel-box'); // Get context
        console.log("Loading iframe stream...");

        // --- Iframe Load Timeout ---
        // Set a timer to detect if the iframe fails to load (e.g., network error, blocked)
        let iframeLoadTimeout = setTimeout(() => {
             console.warn("Iframe load timeout reached for:", url);
             // Check if iframe content is accessible or still blank (indicates failure)
             try {
                  // Accessing contentDocument throws error for cross-origin frames that loaded successfully
                  // If it's 'about:blank' or src doesn't match, it definitely failed.
                  if (!iframeElement.contentDocument || iframeElement.contentDocument.URL === 'about:blank' || iframeElement.getAttribute('src') !== url ) {
                        throw new Error("Iframe content not accessible or didn't load.");
                  }
                  // If we get here without error, it likely loaded but is cross-origin restricted. Assume success.
                  console.log("Iframe seems loaded despite timeout (likely cross-origin).");
                   playerArea.querySelector('.loader').classList.remove('visible');
                   iframeElement.classList.add('active');

             } catch (e) { // Catch errors from accessing contentDocument or the thrown error
                  console.error("Iframe failed to load within timeout.");
                  showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>The source took too long to load or might be blocked.`, true, url, currentBox);
                  iframeElement.classList.remove('active');
                  iframeElement.src = 'about:blank'; // Clear src on failure
                  playerArea.querySelector('.loader').classList.remove('visible');
             }
        }, 15000); // 15-second timeout

        // --- Iframe Event Handlers ---
        iframeElement.onload = () => {
            clearTimeout(iframeLoadTimeout); // Cancel timeout if onload fires
             // Check if the loaded src matches the requested url (ignore if changed)
            if (iframeElement.getAttribute('src') === url) {
                 console.log("Iframe onload event fired for:", url);
                 playerArea.querySelector('.loader').classList.remove('visible'); // Hide loader
                 iframeElement.classList.add('active'); // Show iframe
             } else {
                 console.log("Iframe onload fired for a different src, ignoring:", iframeElement.getAttribute('src'));
             }
        };

        iframeElement.onerror = () => {
             clearTimeout(iframeLoadTimeout); // Cancel timeout on error
             // Check if the error is for the url we tried loading
             if (iframeElement.getAttribute('src') === url) {
                 console.error("Iframe onerror event fired for:", url);
                 showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>Failed to load iframe source. It might be blocked or unavailable.`, true, url, currentBox);
                 iframeElement.classList.remove('active'); // Hide iframe
                 iframeElement.src = 'about:blank'; // Clear src on error
                 playerArea.querySelector('.loader').classList.remove('visible');
             } else {
                 console.log("Iframe onerror fired for a different src, ignoring.");
             }
        };

        // --- Set Iframe Source ---
        // Set src *after* attaching onload/onerror and setting timeout
        iframeElement.src = url;
    }


    // --- Utility Functions ---

    // Updates the timestamp in the footer
    function updateTimestamp() {
        const now = new Date();
        // Format time as HH:MM
        lastUpdatedEl.textContent = `Updated: ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
    }

    // Debounce function to limit the rate at which a function can fire
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args); // Execute the function after the wait time
            };
            clearTimeout(timeout); // Reset the timer on each call
            timeout = setTimeout(later, wait); // Set a new timer
        };
    }

</script>

</body>
</html>
