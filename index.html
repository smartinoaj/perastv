<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">

    <link rel="preconnect" href="https://playmatch.live">
    <link rel="preconnect" href="https://thedaddy.to">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css"> <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- Password Protection Styles --- */
        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary); /* Match body background */
            z-index: 1000; /* Ensure it's on top */
            display: flex; /* Hidden by default, shown via JS if needed */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
        }
        #password-form {
            background-color: var(--bg-secondary);
            padding: 30px 40px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #password-form label {
            display: block;
            margin-bottom: 10px;
            color: var(--text-primary);
            font-weight: 500;
        }
        #password-input {
            padding: 10px 15px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            margin-bottom: 20px;
            width: 100%;
            max-width: 250px; /* Limit width */
        }
         #password-input:focus {
            outline: none;
            border-color: var(--border-color-active);
         }
        #password-submit {
            padding: 10px 25px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #password-submit:hover {
            background-color: #c40812; /* Darker accent */
        }
        #password-error {
            color: var(--error-color);
            margin-top: 15px;
            font-size: 0.9em;
            min-height: 1.2em; /* Prevent layout shift */
        }
        /* Hide main content initially */
        .main-container {
            display: none; /* Hidden by default, shown via JS */
        }
        /* Initially hide the password overlay, JS will show if needed */
        #password-overlay.hidden {
             display: none;
        }
        /* Fallback message div - not actively used but kept for structure */
        #devtools-detected-message {
            display: none;
        }

        /* --- Toggle Switch Styles (Shared) --- */
        /* Styles moved to style.css */

        /* Reminder: Optimize images (logos) for faster loading */
        /* Consider using tools like TinyPNG or Squoosh */
    </style>
    </head>
<body>

<div id="devtools-detected-message"></div>

<div id="password-overlay" class="hidden">
    <form id="password-form">
        <label for="password-input">Enter Access Key</label>
        <input type="password" id="password-input" required>
        <button type="submit" id="password-submit">Enter</button>
        <p id="password-error"></p>
    </form>
</div>

<div class="main-container">
    <div class="container">
        <header>
            <img src="ptvlogo.png" alt="PERAS TV Logo">
        </header>

        <div class="search-container">
            <input type="search" id="search-input" placeholder="Search channels or matches..." aria-label="Search channels or matches">
        </div>

        <div class="tabs" role="tablist" aria-label="Content Categories">
            <button class="tab-button" data-tab="Favorites" role="tab" aria-controls="Favorites" aria-selected="false" aria-label="Favorites">
                 <svg class="tab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                     <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                 </svg>
                 </button>
            <button class="tab-button" data-tab="ALL" role="tab" aria-controls="ALL" aria-selected="false">ALL</button> <button class="tab-button" data-tab="PT" role="tab" aria-controls="PT" aria-selected="false">PT</button>
            <button class="tab-button" data-tab="UK" role="tab" aria-controls="UK" aria-selected="false">UK</button>
            <button class="tab-button" data-tab="ES" role="tab" aria-controls="ES" aria-selected="false">ES</button>
            <button class="tab-button" data-tab="Matches" role="tab" aria-controls="Matches" aria-selected="false">Matches</button>
        </div>

        <div class="toggles-container">
            <div class="toggle-switch-container" id="toggle-new-tab-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="open-in-new-tab-toggle">
                    <span class="slider"></span>
                </label>
                <label for="open-in-new-tab-toggle">Open source in new tab</label>
            </div>

            <div class="toggle-switch-container" id="toggle-player-page-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="open-in-player-page-toggle">
                    <span class="slider"></span>
                </label>
                <label for="open-in-player-page-toggle">Open player page in new tab</label>
            </div>
        </div>
        <div id="loadingMessage" class="status-message loading" role="status">Loading channels...</div>
        <div id="fetchErrorMessage" class="status-message error" role="alert" style="display: none;"></div>

        <div id="Favorites" class="channel-grid" role="tabpanel" aria-labelledby="tab-Favorites" tabindex="-1"></div>
        <div id="ALL" class="channel-grid active" role="tabpanel" aria-labelledby="tab-ALL" tabindex="0"></div>
        <div id="PT" class="channel-grid" role="tabpanel" aria-labelledby="tab-PT" tabindex="-1"></div>
        <div id="UK" class="channel-grid" role="tabpanel" aria-labelledby="tab-UK" tabindex="-1"></div>
        <div id="ES" class="channel-grid" role="tabpanel" aria-labelledby="tab-ES" tabindex="-1"></div>
        <div id="Matches" class="channel-grid" role="tabpanel" aria-labelledby="tab-Matches" tabindex="-1"></div>

    </div>

    <footer>
        <p id="lastUpdated">Updated: Fetching time...</p>
        <p class="footer-disclaimer">
            <strong>Disclaimer:</strong> PerasTV does not host any video content. All streams are embedded from external, publicly available sources found on the internet. We are not responsible for the legality, accuracy, or quality of the content provided by these third-party sites. Users are advised to respect copyright laws and use this service responsibly. Stream availability is not guaranteed.
        </p>
    </footer>
</div>
<script>
    // --- Console Access Deterrents (Run Immediately) ---
    function setupConsoleDeterrents() {
        document.addEventListener('contextmenu', (event) => event.preventDefault());
        document.addEventListener('keydown', (event) => {
            if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) || (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                event.preventDefault();
            }
        });
        console.log("Basic console access deterrents initialized.");
    }
    setupConsoleDeterrents();

    const PERSONAL_USE_B64 = "cHR2"; // Replace with your actual Base64 key if needed
    const AUTH_KEY = 'perasTvAuthenticated';

    const passwordOverlay = document.getElementById('password-overlay');
    const passwordForm = document.getElementById('password-form');
    const passwordInput = document.getElementById('password-input');
    const passwordError = document.getElementById('password-error');
    const mainContainer = document.querySelector('.main-container');

    // --- Authentication Check ---
    if (sessionStorage.getItem(AUTH_KEY) === 'true') {
        console.log("Already authenticated.");
        passwordOverlay.classList.add('hidden');
        mainContainer.style.display = 'block';
        initializeApp();
    } else {
        if (typeof PERSONAL_USE_B64 === 'undefined' || PERSONAL_USE_B64 === "PASTE_YOUR_BASE64_PASSWORD_HERE" || PERSONAL_USE_B64 === "") {
             console.error("ERROR: PERSONAL_USE_B64 is not set correctly.");
             passwordOverlay.innerHTML = '<p style="color:var(--error-color); text-align:center;">Configuration Error: Access key not set.</p>';
             passwordOverlay.classList.remove('hidden');
        } else {
            console.log("Authentication required.");
            passwordOverlay.classList.remove('hidden');
            passwordInput.focus();
            passwordForm.addEventListener('submit', (event) => {
                event.preventDefault();
                const enteredValue = passwordInput.value;
                let correctKey = "";
                try { correctKey = atob(PERSONAL_USE_B64); } catch (e) {
                    console.error("Error decoding Base64 key:", e);
                    passwordError.textContent = 'Configuration Error'; return;
                }
                if (enteredValue === correctKey) {
                    console.log("Access key correct.");
                    sessionStorage.setItem(AUTH_KEY, 'true');
                    passwordOverlay.classList.add('hidden');
                    mainContainer.style.display = 'block';
                    initializeApp();
                } else {
                    console.log("Incorrect access key.");
                    passwordError.textContent = 'Incorrect Access Key';
                    passwordInput.value = ''; passwordInput.focus();
                }
            });
        }
    }

    /* --- PerasTV Main Application Logic --- */
    function initializeApp() {
        if (window.appInitialized) return;
        window.appInitialized = true;
        console.log("Initializing PerasTV App...");

        // --- Configuration Constants ---
        const CONFIG = {
            channelsUrl: "channels.json",
            matchesUrl: "matches.json",
            placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%231a1a1a"/></svg>',
            searchDebounceMs: 300,
            lastTabKey: 'perasTvLastTab',
            favoritesKey: 'perasTvFavorites',
            iframeLoadTimeoutMs: 35000,
            openInNewTabKey: 'perasTvOpenInNewTab',       // Key for first toggle
            openInPlayerPageKey: 'perasTvOpenPlayerPage' // Key for second toggle
        };

        // --- DOM Element References ---
        const searchInputElement = document.getElementById('search-input');
        const tabsContainerElement = document.querySelector('.tabs');
        const channelGridElements = document.querySelectorAll('.channel-grid');
        const lastUpdatedTimestampElement = document.getElementById('lastUpdated');
        const initialLoadingMessageElement = document.getElementById('loadingMessage');
        const dataFetchErrorMessageElement = document.getElementById('fetchErrorMessage');
        const openInNewTabToggleElement = document.getElementById('open-in-new-tab-toggle');
        const openInPlayerPageToggleElement = document.getElementById('open-in-player-page-toggle'); // NEW: Player page toggle element

        // --- Application State ---
        let currentHlsInstance = null;
        let allChannelsData = {};
        let allMatchesData = [];
        let currentlyExpandedBoxElement = null;
        let searchDebounceTimerId = null;
        let activeTabId = 'ALL';
        let favoriteItemIds = [];
        let openInNewTabEnabled = false;     // State for first toggle
        let openInPlayerPageEnabled = false; // NEW: State for second toggle

        // --- Disclaimer Text ---
        const BOX_DISCLAIMER_TEXT = `Disclaimer: This site embeds content from external sources. We do not host streams. Availability and quality not guaranteed. Use responsibly.`;

        // --- Initial Setup ---
        loadFavoritesFromStorage();
        loadNewTabToggleState();     // Load state for first toggle
        loadPlayerPageToggleState(); // NEW: Load state for second toggle
        setupGlobalEventListeners();
        updateTimestampDisplay();
        setInterval(updateTimestampDisplay, 60000);
        fetchAndRenderData();


        // --- Favorite Management ---
        function loadFavoritesFromStorage() {
            const storedFavoritesJson = localStorage.getItem(CONFIG.favoritesKey);
            if (storedFavoritesJson) {
                try {
                    const parsedFavorites = JSON.parse(storedFavoritesJson);
                    if (Array.isArray(parsedFavorites) && parsedFavorites.every(item => typeof item === 'string')) {
                        favoriteItemIds = parsedFavorites;
                    } else {
                        console.warn("Invalid favorites data found. Resetting.");
                        favoriteItemIds = []; localStorage.removeItem(CONFIG.favoritesKey);
                    }
                } catch (error) { console.error("Error parsing favorites:", error); favoriteItemIds = []; }
            } else { favoriteItemIds = []; }
            console.log("Loaded favorites:", favoriteItemIds);
        }
        function saveFavoritesToStorage() {
            try { localStorage.setItem(CONFIG.favoritesKey, JSON.stringify(favoriteItemIds)); console.log("Saved favorites:", favoriteItemIds); }
            catch (error) { console.error("Error saving favorites:", error); }
        }
        function toggleFavoriteStatus(itemId, starButtonElement) { /* ... (keep existing code) ... */
            if (!itemId || !starButtonElement) return;
            const itemIndex = favoriteItemIds.indexOf(itemId);
            const isCurrentlyFavorite = itemIndex > -1;
            if (isCurrentlyFavorite) {
                favoriteItemIds.splice(itemIndex, 1);
                starButtonElement.classList.remove('is-favorite');
                starButtonElement.setAttribute('aria-pressed', 'false');
                starButtonElement.setAttribute('aria-label', 'Add to Favorites');
            } else {
                favoriteItemIds.push(itemId);
                starButtonElement.classList.add('is-favorite');
                starButtonElement.setAttribute('aria-pressed', 'true');
                starButtonElement.setAttribute('aria-label', 'Remove from Favorites');
            }
            saveFavoritesToStorage();
            document.querySelectorAll(`.channel-box#${CSS.escape(itemId)} .favorite-button`).forEach(otherStar => {
                if (otherStar !== starButtonElement) {
                    otherStar.classList.toggle('is-favorite', !isCurrentlyFavorite);
                    otherStar.setAttribute('aria-pressed', !isCurrentlyFavorite ? 'true' : 'false');
                    otherStar.setAttribute('aria-label', !isCurrentlyFavorite ? 'Remove from Favorites' : 'Add to Favorites');
                }
            });
            if (activeTabId === 'Favorites') {
                renderFavoritesTabContent();
                addChannelBoxEventListeners(document.getElementById('Favorites'));
            }
        }

        // --- Toggle State Management ---
        function loadNewTabToggleState() {
            const storedState = localStorage.getItem(CONFIG.openInNewTabKey);
            openInNewTabEnabled = (storedState === 'true');
            if (openInNewTabToggleElement) openInNewTabToggleElement.checked = openInNewTabEnabled;
            console.log(`Loaded 'Open source in new tab' state: ${openInNewTabEnabled}`);
        }
        function saveNewTabToggleState() {
            try { localStorage.setItem(CONFIG.openInNewTabKey, openInNewTabEnabled); console.log(`Saved 'Open source in new tab' state: ${openInNewTabEnabled}`); }
            catch (error) { console.error("Error saving 'Open source in new tab' state:", error); }
        }
        // NEW: Load/Save for Player Page Toggle
        function loadPlayerPageToggleState() {
            const storedState = localStorage.getItem(CONFIG.openInPlayerPageKey);
            openInPlayerPageEnabled = (storedState === 'true');
            if (openInPlayerPageToggleElement) openInPlayerPageToggleElement.checked = openInPlayerPageEnabled;
            console.log(`Loaded 'Open player page in new tab' state: ${openInPlayerPageEnabled}`);
        }
        function savePlayerPageToggleState() {
            try { localStorage.setItem(CONFIG.openInPlayerPageKey, openInPlayerPageEnabled); console.log(`Saved 'Open player page in new tab' state: ${openInPlayerPageEnabled}`); }
            catch (error) { console.error("Error saving 'Open player page in new tab' state:", error); }
        }

        // --- Event Listener Setup ---
        function setupGlobalEventListeners() {
            // Tabs
            tabsContainerElement.addEventListener('click', (event) => {
                const tabButton = event.target.closest('.tab-button[data-tab]');
                if (tabButton) activateTab(tabButton.dataset.tab);
            });
            // Search
            searchInputElement.addEventListener('input', (event) => {
                clearTimeout(searchDebounceTimerId);
                searchDebounceTimerId = setTimeout(() => filterVisibleContent(event.target.value), CONFIG.searchDebounceMs);
            });
            // Toggle 1: Open Source in New Tab
            if (openInNewTabToggleElement) {
                openInNewTabToggleElement.addEventListener('change', (event) => {
                    openInNewTabEnabled = event.target.checked;
                    saveNewTabToggleState();
                    // If this is checked, uncheck the other toggle
                    if (openInNewTabEnabled && openInPlayerPageToggleElement) {
                        openInPlayerPageToggleElement.checked = false;
                        openInPlayerPageEnabled = false;
                        savePlayerPageToggleState();
                    }
                    console.log(`'Open source in new tab' toggled: ${openInNewTabEnabled}`);
                });
            }
            // NEW: Toggle 2: Open Player Page in New Tab
            if (openInPlayerPageToggleElement) {
                openInPlayerPageToggleElement.addEventListener('change', (event) => {
                    openInPlayerPageEnabled = event.target.checked;
                    savePlayerPageToggleState();
                    // If this is checked, uncheck the other toggle
                    if (openInPlayerPageEnabled && openInNewTabToggleElement) {
                        openInNewTabToggleElement.checked = false;
                        openInNewTabEnabled = false;
                        saveNewTabToggleState();
                    }
                    console.log(`'Open player page in new tab' toggled: ${openInPlayerPageEnabled}`);
                });
            }
            // Keyboard
            document.addEventListener('keydown', (event) => { /* ... (keep existing keyboard nav logic) ... */
                 if (event.key === 'Escape' && currentlyExpandedBoxElement) {
                    collapseItemBox(currentlyExpandedBoxElement);
                }
                const focusableElements = getFocusableElementsInActiveGrid();
                const currentIndex = focusableElements.indexOf(document.activeElement);
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                     if (document.activeElement && document.activeElement.closest('.channel-box') && !currentlyExpandedBoxElement) {
                        event.preventDefault();
                        let nextIndex = -1;
                        const activeGrid = document.getElementById(activeTabId);
                        const numCols = activeGrid ? getComputedStyle(activeGrid).gridTemplateColumns.split(' ').length : 1;
                        switch (event.key) {
                            case 'ArrowDown': nextIndex = currentIndex + numCols; break;
                            case 'ArrowUp': nextIndex = currentIndex - numCols; break;
                            case 'ArrowRight': nextIndex = (currentIndex + 1) % numCols === 0 && numCols > 1 ? -1 : currentIndex + 1; break;
                            case 'ArrowLeft': nextIndex = currentIndex % numCols === 0 && numCols > 1 ? -1 : currentIndex - 1; break;
                        }
                        if (nextIndex >= 0 && nextIndex < focusableElements.length) { focusableElements[nextIndex].focus(); }
                     } else if (!document.activeElement || document.activeElement === document.body || document.activeElement === searchInputElement || document.activeElement.closest('.tabs')) {
                         focusableElements[0]?.focus();
                     }
                }
                if (event.key === 'Enter' || event.key === 'Ok') {
                     if (document.activeElement && document.activeElement.classList.contains('channel-box') && !currentlyExpandedBoxElement) {
                        event.preventDefault(); toggleItemBoxExpansion(document.activeElement);
                     } else if (document.activeElement && document.activeElement.classList.contains('stream-button')) {
                        event.preventDefault(); document.activeElement.click();
                     } else if (document.activeElement && document.activeElement.classList.contains('tab-button')) {
                        event.preventDefault(); document.activeElement.click();
                     } else if (document.activeElement && document.activeElement.classList.contains('favorite-button')) {
                         event.preventDefault(); document.activeElement.click();
                     }
                }
            });
        }
        function getFocusableElementsInActiveGrid() { /* ... (keep existing code) ... */
            const activeGrid = document.getElementById(activeTabId);
            if (!activeGrid) return [];
            return Array.from(activeGrid.querySelectorAll(':scope > .channel-box:not(.hidden):not(.expanded)'));
        }

        // --- Data Fetching & Rendering ---
        async function fetchAndRenderData() { /* ... (keep existing code) ... */
            showInitialLoadingMessage("Loading channels and matches...");
            dataFetchErrorMessageElement.style.display = 'none';
            try {
                const cacheBuster = `?t=${Date.now()}`;
                const channelsUrl = CONFIG.channelsUrl + cacheBuster;
                const matchesUrl = CONFIG.matchesUrl + cacheBuster;
                const [channelsResponse, matchesResponse] = await Promise.all([ fetch(channelsUrl), fetch(matchesUrl) ]);
                if (!channelsResponse.ok) throw new Error(`Failed to load channels: ${channelsResponse.status} ${channelsResponse.statusText}`);
                if (!matchesResponse.ok) throw new Error(`Failed to load matches: ${matchesResponse.status} ${matchesResponse.statusText}`);
                allChannelsData = await channelsResponse.json();
                allMatchesData = await matchesResponse.json();
                if (typeof allChannelsData !== 'object' || allChannelsData === null) throw new Error("Invalid channels data format.");
                if (!Array.isArray(allMatchesData)) throw new Error("Invalid matches data format.");
                console.log("Data fetched successfully:", { channels: allChannelsData, matches: allMatchesData });
                renderAllContentGrids();
                hideInitialLoadingMessage();
                const lastSavedTabId = localStorage.getItem(CONFIG.lastTabKey);
                const validTabIds = Array.from(tabsContainerElement.querySelectorAll('.tab-button')).map(btn => btn.dataset.tab);
                activateTab(validTabIds.includes(lastSavedTabId) ? lastSavedTabId : 'ALL');
            } catch (error) {
                console.error("Data loading failed:", error);
                hideInitialLoadingMessage();
                showDataFetchErrorMessage(`Error loading data: ${error.message}. Please try refreshing.`);
            }
        }
        function renderAllContentGrids() { /* ... (keep existing code) ... */
             console.log("Rendering all content grids...");
            renderSpecificGridContent('PT', allChannelsData.PT || [], 'channel');
            renderSpecificGridContent('UK', allChannelsData.UK || [], 'channel');
            renderSpecificGridContent('ES', allChannelsData.ES || [], 'channel');
            renderSpecificGridContent('Matches', allMatchesData || [], 'match');
            renderAllTabContent();
            renderFavoritesTabContent();
            addChannelBoxEventListeners();
        }
        function renderSpecificGridContent(gridId, items, itemType) { /* ... (keep existing code, generates uniqueItemId) ... */
            const gridElement = document.getElementById(gridId);
            if (!gridElement) return;
            gridElement.innerHTML = '';
            if (!items || items.length === 0) {
                let emptyMessage = `No ${itemType === 'match' ? 'matches' : 'channels'} listed.`;
                if (gridId === 'Favorites') emptyMessage = 'Favorites list is empty. Click ☆ to add.';
                gridElement.innerHTML = `<p class="status-message info">${emptyMessage}</p>`; return;
            }
            const fragment = document.createDocumentFragment();
            items.forEach((itemData) => {
                let itemElement = null; let uniqueItemId = null;
                if (itemType === 'match') {
                    const globalMatchIndex = allMatchesData.findIndex(m => m === itemData);
                    if (globalMatchIndex !== -1) {
                        uniqueItemId = `match-${globalMatchIndex}`;
                        itemElement = createMatchBoxElement(itemData, uniqueItemId);
                    }
                } else {
                    let category = ''; let categoryIndex = -1;
                    for (const key in allChannelsData) {
                        const index = allChannelsData[key]?.indexOf(itemData);
                        if (index !== -1 && index !== undefined) { category = key; categoryIndex = index; break; }
                    }
                    if (category && categoryIndex !== -1) {
                        uniqueItemId = `${category}-channel-${categoryIndex}`;
                        itemElement = createChannelBoxElement(itemData, uniqueItemId);
                    }
                }
                if (itemElement) fragment.appendChild(itemElement);
                else console.warn(`Failed to create element for item in grid ${gridId}`);
            });
            gridElement.appendChild(fragment);
        }
        function renderAllTabContent() { /* ... (keep existing code) ... */
            const allGridElement = document.getElementById('ALL');
            if (!allGridElement) return;
            allGridElement.innerHTML = '';
            const fragment = document.createDocumentFragment(); let contentAdded = false;
            if (allMatchesData && allMatchesData.length > 0) {
                allMatchesData.forEach((match, index) => {
                    const uniqueId = `match-${index}`;
                    const box = createMatchBoxElement(match, uniqueId); if(box) { fragment.appendChild(box); contentAdded = true; }
                });
            }
            ['PT', 'UK', 'ES'].forEach(category => {
                const channelsInCategory = allChannelsData[category] || [];
                if (channelsInCategory.length > 0) {
                     channelsInCategory.forEach((channel, index) => {
                        const uniqueId = `${category}-channel-${index}`;
                        const box = createChannelBoxElement(channel, uniqueId); if(box) { fragment.appendChild(box); contentAdded = true; }
                    });
                }
            });
            allGridElement.appendChild(fragment);
            if (!contentAdded) allGridElement.innerHTML = '<p class="status-message info">No channels or matches available.</p>';
        }
        function renderFavoritesTabContent() { /* ... (keep existing code) ... */
            const favoritesGridElement = document.getElementById('Favorites');
            if (!favoritesGridElement) return;
            favoritesGridElement.innerHTML = '';
            if (favoriteItemIds.length === 0) {
                favoritesGridElement.innerHTML = '<p class="status-message info">Favorites list is empty.<br>Click ☆ to add.</p>'; return;
            }
            const fragment = document.createDocumentFragment(); let validFavoritesFound = 0;
            favoriteItemIds.forEach(itemId => {
                let itemElement = null;
                if (itemId.startsWith('match-')) {
                    const matchIndex = parseInt(itemId.split('-')[1], 10);
                    if (!isNaN(matchIndex) && matchIndex >= 0 && matchIndex < allMatchesData.length) {
                        itemElement = createMatchBoxElement(allMatchesData[matchIndex], itemId);
                    }
                } else if (itemId.includes('-channel-')) {
                    const parts = itemId.split('-'); const category = parts[0]; const channelIndex = parseInt(parts[parts.length - 1], 10);
                    if (allChannelsData[category] && !isNaN(channelIndex) && channelIndex >= 0 && channelIndex < allChannelsData[category].length) {
                         itemElement = createChannelBoxElement(allChannelsData[category][channelIndex], itemId);
                    }
                }
                if (itemElement) { fragment.appendChild(itemElement); validFavoritesFound++; }
                else { console.warn(`Could not find data for favorite item ID: ${itemId}.`); }
            });
            favoritesGridElement.appendChild(fragment);
            if (validFavoritesFound === 0 && favoriteItemIds.length > 0) {
                 favoritesGridElement.innerHTML = '<p class="status-message info">Previously favorited items could not be found.</p>';
            }
        }

        // --- Element Creation ---
        function createChannelBoxElement(channelData, uniqueItemId) { /* ... (keep existing code) ... */
            if (!channelData || !uniqueItemId || !channelData.name || !Array.isArray(channelData.srcs)) return null;
            const { name, srcs } = channelData;
            const boxElement = document.createElement('div');
            boxElement.className = 'channel-box'; boxElement.id = uniqueItemId; boxElement.tabIndex = 0;
            boxElement.dataset.itemName = name; boxElement.dataset.itemType = 'channel';
            boxElement.dataset.sources = JSON.stringify(srcs); // Keep sources here for embed mode
            boxElement.dataset.itemId = uniqueItemId; // NEW: Store ID explicitly for player page link
            const isFavorite = favoriteItemIds.includes(uniqueItemId);
            boxElement.innerHTML = `
                <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites" aria-pressed="${isFavorite}" tabindex="-1"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></button>
                <div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content"><h3>${name}</h3></div>
                <div class="channel-info"></div>
                <div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header">
                    <div class="player-area">
                        <div class="loader"></div><div class="player-message" role="alert"></div>
                        <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe>
                        <video controls autoplay muted playsinline title="Stream Player" poster="${CONFIG.placeholderImage}"></video>
                    </div>
                    <div class="stream-buttons"></div>
                    <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p>
                </div>`;
            return boxElement;
        }
        function createMatchBoxElement(matchData, uniqueItemId) { /* ... (keep existing code) ... */
             if (!matchData || !uniqueItemId || !matchData.team1 || !matchData.team2) return null;
            const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = matchData;
            const boxElement = document.createElement('div');
            boxElement.className = 'channel-box'; boxElement.id = uniqueItemId; boxElement.tabIndex = 0;
            const matchTitle = `${team1} vs ${team2}`;
            boxElement.dataset.itemName = matchTitle; boxElement.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase();
            boxElement.dataset.itemType = 'match';
            const allSources = { pt: pt || [], uk: uk || [], es: es || [] };
            boxElement.dataset.sources = JSON.stringify(allSources); // Keep sources here for embed mode
            boxElement.dataset.itemId = uniqueItemId; // NEW: Store ID explicitly for player page link
            const isFavorite = favoriteItemIds.includes(uniqueItemId);
            const createLogoHtml = (logoUrl, altText) => logoUrl ? `<img src="${logoUrl}" alt="${altText} logo" class="match-logo" loading="lazy" onerror="this.style.display='none'; this.onerror=null;">` : '<span class="match-logo" aria-label="No logo available" style="display: inline-block; width: 40px;"></span>';
            boxElement.innerHTML = `
                 <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites" aria-pressed="${isFavorite}" tabindex="-1"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></button>
                <div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content"> ${createLogoHtml(logo1, team1)} <h3>${matchTitle}</h3> ${createLogoHtml(logo2, team2)}</div>
                <div class="channel-info">${league ? `<span>${league}</span>` : ''} ${league && time ? '<span aria-hidden="true"> | </span>' : ''} ${time ? `<span>${time}</span>` : ''}</div>
                <div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header">
                    <div class="player-area">
                        <div class="loader"></div><div class="player-message" role="alert"></div>
                        <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe>
                        <video controls autoplay muted playsinline title="Stream Player" poster="${CONFIG.placeholderImage}"></video>
                    </div>
                    <div class="stream-buttons"></div>
                    <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p>
                </div>`;
            return boxElement;
        }
        /**
         * Creates a single stream source button element with its click handler.
         * **MODIFIED:** Click handler now checks BOTH toggles (`openInPlayerPageEnabled` first).
         * @param {string} label - Text label for the button (e.g., 'PM', 'DL', 'Source 1').
         * @param {string} url - The stream URL associated with this button.
         * @param {HTMLDivElement} parentBoxElement - The parent channel/match box element.
         * @returns {HTMLButtonElement} The created button element.
         */
        function createStreamSourceButton(label, url, parentBoxElement) {
           const buttonElement = document.createElement('button');
           buttonElement.className = 'stream-button';
           buttonElement.textContent = label || 'Source';
           buttonElement.dataset.streamUrl = url; // Store original URL

           // --- MODIFIED Click Event Listener ---
           buttonElement.onclick = (event) => {
               event.stopPropagation(); // Prevent box expansion toggle

               const itemId = parentBoxElement.dataset.itemId; // Get the unique ID (e.g., PT-channel-0)

               // --- Priority 1: Open Dedicated Player Page ---
               if (openInPlayerPageEnabled && itemId) {
                   const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`;
                   console.log(`Opening player page in new tab: ${label} (${playerPageUrl})`);
                   window.open(playerPageUrl, '_blank');

                   // Optional highlight
                   buttonElement.classList.add('active');
                   setTimeout(() => buttonElement.classList.remove('active'), 500);

               // --- Priority 2: Open Original Source in New Tab ---
               } else if (openInNewTabEnabled) {
                   console.log(`Opening source in new tab: ${label} (${url})`);
                   window.open(url, '_blank');

                   // Optional highlight
                   buttonElement.classList.add('active');
                   setTimeout(() => buttonElement.classList.remove('active'), 500);

               // --- Default: Load in Embedded Player ---
               } else {
                   console.log(`Loading stream in player: ${label} (${url})`);
                   loadStreamIntoPlayer(buttonElement, url, parentBoxElement);
               }
           };
           return buttonElement;
       }

        // --- Event Listener Setup for Channel Boxes ---
        function addChannelBoxEventListeners(scopeElement = document) { /* ... (keep existing code) ... */
             if (!scopeElement) return;
             scopeElement.querySelectorAll('.channel-box:not([data-listener-added="true"])').forEach(boxElement => {
                const headerElement = boxElement.querySelector('.channel-header');
                const infoElement = boxElement.querySelector('.channel-info');
                const favoriteButtonElement = boxElement.querySelector('.favorite-button');
                const boxId = boxElement.id;
                const handleExpansionToggle = (event) => { if (!event.target.closest('.favorite-button')) toggleItemBoxExpansion(boxElement); };
                if (headerElement) headerElement.addEventListener('click', handleExpansionToggle);
                if (infoElement && getComputedStyle(infoElement).display !== 'none') infoElement.addEventListener('click', handleExpansionToggle);
                if (favoriteButtonElement && boxId) favoriteButtonElement.addEventListener('click', (event) => { event.stopPropagation(); toggleFavoriteStatus(boxId, favoriteButtonElement); });
                else if (!boxId) console.warn("Could not attach favorite listener: Box ID missing.", boxElement);
                boxElement.addEventListener('keydown', (event) => { if ((event.key === 'Enter' || event.key === 'Ok') && !boxElement.classList.contains('expanded')) { event.preventDefault(); toggleItemBoxExpansion(boxElement); } });
                boxElement.dataset.listenerAdded = 'true';
            });
        }

        // --- Tab Management ---
        function activateTab(tabIdToShow) { /* ... (keep existing code) ... */
            if (tabIdToShow === activeTabId && document.getElementById(tabIdToShow)?.classList.contains('active')) return;
            console.log(`Activating tab: ${tabIdToShow}`);
            activeTabId = tabIdToShow;
            tabsContainerElement.querySelectorAll('.tab-button').forEach(btn => {
                const isActive = btn.dataset.tab === tabIdToShow;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            });
            channelGridElements.forEach(grid => {
                const isGridActive = grid.id === tabIdToShow;
                grid.classList.toggle('active', isGridActive);
                grid.setAttribute('tabindex', isGridActive ? '0' : '-1');
            });
            if (currentlyExpandedBoxElement) collapseItemBox(currentlyExpandedBoxElement);
            localStorage.setItem(CONFIG.lastTabKey, tabIdToShow);
            if (tabIdToShow === 'Favorites') {
                renderFavoritesTabContent();
                addChannelBoxEventListeners(document.getElementById('Favorites'));
            }
            filterVisibleContent(searchInputElement.value);
            setTimeout(() => document.getElementById(tabIdToShow)?.focus({ preventScroll: true }), 50);
        }

        // --- Search Filtering ---
        function filterVisibleContent(searchTerm) { /* ... (keep existing code) ... */
             const normalizedSearchTerm = searchTerm.toLowerCase().trim();
            const isSearching = normalizedSearchTerm !== '';
            console.log(`Filtering content for term: "${normalizedSearchTerm}" on tab: ${activeTabId}`);
            let resultsFoundInActiveTab = false;
            const activeGridElement = document.getElementById(activeTabId);
            const allBoxes = document.querySelectorAll('.channel-box');
            allBoxes.forEach(boxElement => {
                const parentGridId = boxElement.closest('.channel-grid')?.id; if (!parentGridId) return;
                const itemName = boxElement.dataset.itemName?.toLowerCase() || '';
                const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || '';
                const matchesSearch = itemName.includes(normalizedSearchTerm) || additionalSearchTerms.includes(normalizedSearchTerm);
                let shouldBeVisible = false;
                if (!isSearching) { shouldBeVisible = (parentGridId === activeTabId); }
                else {
                    if (parentGridId === activeTabId) shouldBeVisible = matchesSearch;
                    else if (activeTabId === 'ALL') shouldBeVisible = matchesSearch;
                    else if (activeTabId === 'Favorites') shouldBeVisible = matchesSearch && favoriteItemIds.includes(boxElement.id);
                }
                if (!boxElement.classList.contains('expanded')) {
                    boxElement.classList.toggle('hidden', !shouldBeVisible);
                    boxElement.tabIndex = shouldBeVisible ? 0 : -1;
                } else { boxElement.classList.remove('hidden'); boxElement.tabIndex = -1; }
                if (shouldBeVisible && parentGridId === activeTabId && !boxElement.classList.contains('expanded')) { resultsFoundInActiveTab = true; }
            });
            if (activeGridElement) {
                 let noResultsMsgEl = activeGridElement.querySelector('.status-message.info.no-results');
                 if (!noResultsMsgEl) {
                     noResultsMsgEl = document.createElement('p'); noResultsMsgEl.className = 'status-message info no-results';
                     noResultsMsgEl.style.display = 'none'; activeGridElement.prepend(noResultsMsgEl);
                 }
                 if (isSearching && !resultsFoundInActiveTab) {
                     noResultsMsgEl.innerHTML = `No results found for "<strong>${searchTerm}</strong>" in this section.`;
                     noResultsMsgEl.style.display = 'block';
                 } else { noResultsMsgEl.style.display = 'none'; }
            }
        }

        // --- Channel Box Expansion ---
        function toggleItemBoxExpansion(boxElement) { /* ... (keep existing code) ... */
             if (!boxElement) return;
            const isCurrentlyExpanded = boxElement.classList.contains('expanded');
            const headerElement = boxElement.querySelector('.channel-header');
            if (!isCurrentlyExpanded && currentlyExpandedBoxElement && currentlyExpandedBoxElement !== boxElement) {
                collapseItemBox(currentlyExpandedBoxElement);
            }
            if (!isCurrentlyExpanded) {
                expandItemBox(boxElement); if (headerElement) headerElement.setAttribute('aria-expanded', 'true');
            } else {
                collapseItemBox(boxElement); if (headerElement) headerElement.setAttribute('aria-expanded', 'false');
            }
        }
        function expandItemBox(boxElement) { /* ... (keep existing code) ... */
            boxElement.classList.add('expanded'); boxElement.classList.remove('hidden');
            boxElement.tabIndex = -1; currentlyExpandedBoxElement = boxElement;
            populateStreamsAndLoadFirst(boxElement); // This now checks toggles
            setTimeout(() => {
                 boxElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                 const firstStreamButton = boxElement.querySelector('.stream-button');
                 if (firstStreamButton) setTimeout(() => firstStreamButton.focus({ preventScroll: true }), 150);
                 else boxElement.querySelector('.iframe-container')?.focus();
            }, 100);
        }
        function collapseItemBox(boxElement) { /* ... (keep existing code) ... */
            const wasCurrentlyExpanded = (currentlyExpandedBoxElement === boxElement);
            boxElement.classList.remove('expanded');
            if (wasCurrentlyExpanded) currentlyExpandedBoxElement = null;
            clearPlayerStateInBox(boxElement);
            const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) streamButtonsContainer.innerHTML = '';
            const headerElement = boxElement.querySelector('.channel-header'); if(headerElement) headerElement.setAttribute('aria-expanded', 'false');
            const normalizedSearchTerm = searchInputElement.value.toLowerCase().trim(); const isSearching = normalizedSearchTerm !== '';
            const parentGridId = boxElement.closest('.channel-grid')?.id; const itemName = boxElement.dataset.itemName?.toLowerCase() || '';
            const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || ''; const matchesSearch = itemName.includes(normalizedSearchTerm) || additionalSearchTerms.includes(normalizedSearchTerm);
            let shouldBeVisibleAfterCollapse = false;
            if (!isSearching) { shouldBeVisibleAfterCollapse = (parentGridId === activeTabId); }
            else {
                if (parentGridId === activeTabId) shouldBeVisibleAfterCollapse = matchesSearch;
                else if (activeTabId === 'ALL') shouldBeVisibleAfterCollapse = matchesSearch;
                else if (activeTabId === 'Favorites') shouldBeVisibleAfterCollapse = matchesSearch && favoriteItemIds.includes(boxElement.id);
            }
            boxElement.classList.toggle('hidden', !shouldBeVisibleAfterCollapse);
            boxElement.tabIndex = shouldBeVisibleAfterCollapse ? 0 : -1;
            if (wasCurrentlyExpanded && shouldBeVisibleAfterCollapse) setTimeout(() => boxElement.focus({ preventScroll: true }), 50);
            else if (wasCurrentlyExpanded) setTimeout(() => document.getElementById(activeTabId)?.focus({ preventScroll: true }), 50);
        }

        /**
         * Populates stream buttons. Attempts auto-load ONLY if BOTH toggles are OFF.
         * Displays message if either toggle is ON.
         * @param {HTMLDivElement} boxElement - The expanded box element.
         */
        function populateStreamsAndLoadFirst(boxElement) {
            const sourcesJson = boxElement.dataset.sources;
            const streamButtonsContainer = boxElement.querySelector('.stream-buttons');
            const playerAreaElement = boxElement.querySelector('.player-area');
            if (!sourcesJson || !streamButtonsContainer || !playerAreaElement) {
                 displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); return;
            }
            streamButtonsContainer.innerHTML = '';
            let firstStreamUrl = null; let firstStreamButtonElement = null; let streamCount = 0;
            const fragment = document.createDocumentFragment();
            try {
                const sourcesData = JSON.parse(sourcesJson);
                // --- Populate Buttons (Logic remains the same) ---
                if (Array.isArray(sourcesData)) { // Channel
                    sourcesData.forEach((src) => {
                        const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null);
                        const label = typeof src === 'object' && src.label ? src.label : `Source ${streamCount + 1}`;
                        if (url) {
                             if (!firstStreamUrl) firstStreamUrl = url;
                             const button = createStreamSourceButton(label, url, boxElement);
                             if (!firstStreamButtonElement) firstStreamButtonElement = button;
                             fragment.appendChild(button); streamCount++;
                        }
                    });
                } else if (typeof sourcesData === 'object' && sourcesData !== null) { // Match
                    Object.entries(sourcesData).forEach(([langKey, sourcesInLang]) => {
                        if (sourcesInLang && Array.isArray(sourcesInLang) && sourcesInLang.length > 0) {
                            const langGroupDiv = document.createElement('div');
                            const langLabel = document.createElement('strong'); langLabel.textContent = `${langKey.toUpperCase()}:`; langGroupDiv.appendChild(langLabel);
                            sourcesInLang.forEach((src) => {
                                const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null);
                                const label = typeof src === 'object' && src.label ? src.label : `Src ${streamCount + 1}`;
                                 if (url) {
                                     if (!firstStreamUrl) firstStreamUrl = url;
                                     const button = createStreamSourceButton(label, url, boxElement);
                                     if (!firstStreamButtonElement) firstStreamButtonElement = button;
                                     langGroupDiv.appendChild(button); streamCount++;
                                }
                            });
                            fragment.appendChild(langGroupDiv);
                        }
                    });
                }
                streamButtonsContainer.appendChild(fragment);

                // --- Handle Auto-load / Messages based on Toggles ---
                if (streamCount === 0) {
                    displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer);
                    clearPlayerStateInBox(boxElement);
                } else if (openInPlayerPageEnabled) {
                    console.log("Skipping auto-load: 'Open player page' is enabled.");
                    displayMessageInPlayerArea(playerAreaElement, `<strong>Select a source</strong><span>'Open player page in new tab' is active. Click a button to open.</span>`, false);
                    clearPlayerStateInBox(boxElement); // Clear player area as it won't be used
                } else if (openInNewTabEnabled) {
                    console.log("Skipping auto-load: 'Open source in new tab' is enabled.");
                    displayMessageInPlayerArea(playerAreaElement, `<strong>Select a source</strong><span>'Open source in new tab' is active. Click a button to open.</span>`, false);
                    clearPlayerStateInBox(boxElement); // Clear player area as it won't be used
                } else if (firstStreamUrl && firstStreamButtonElement) {
                     // BOTH toggles are OFF, proceed with auto-load if player isn't already active
                     const videoEl = boxElement.querySelector('video'); const iframeEl = boxElement.querySelector('iframe');
                     if (!videoEl.classList.contains('active') && !iframeEl.classList.contains('active')) {
                        console.log("Auto-loading first stream (both toggles OFF).");
                        loadStreamIntoPlayer(firstStreamButtonElement, firstStreamUrl, boxElement);
                     } else {
                        console.log("Skipping auto-load, player already active.");
                        // Highlight active button if needed
                        const activeSrc = videoEl.src || iframeEl.src;
                        if (activeSrc) streamButtonsContainer.querySelectorAll('.stream-button').forEach(btn => btn.classList.toggle('active', btn.dataset.streamUrl === activeSrc));
                     }
                } else {
                     console.error("Inconsistency: Streams counted, but no first URL/Button.", boxElement.id);
                     displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerStateInBox(boxElement);
                }
            } catch (error) {
                console.error("Failed to parse sources/create buttons:", boxElement.id, error);
                streamButtonsContainer.innerHTML = '<p class="status-message error">Error loading sources.</p>';
                clearPlayerStateInBox(boxElement);
            }
        }
        function displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer) { /* ... (keep existing code) ... */
             const message = 'No stream sources listed for this item.';
             if (streamButtonsContainer) streamButtonsContainer.innerHTML = `<p style="color: var(--text-secondary); font-size: 0.9em; padding: 10px 0;">${message}</p>`;
             if (playerAreaElement) displayMessageInPlayerArea(playerAreaElement, `<strong>No Streams Available</strong><span>${message}</span>`, false);
        }

        // --- Stream Handling (Only used when BOTH toggles are false) ---
        function loadStreamIntoPlayer(clickedButtonElement, streamUrl, parentBoxElement) { /* ... (keep existing code, including safety check for toggles) ... */
            if (!parentBoxElement || !streamUrl || typeof streamUrl !== 'string') return;
            // Safety Check: Abort if either toggle is ON
            if (openInNewTabEnabled || openInPlayerPageEnabled) {
                console.warn("loadStreamIntoPlayer called, but a new tab toggle is enabled. Aborting.");
                clearPlayerStateInBox(parentBoxElement); // Clear player area
                return;
            }
            console.log(`>>> loadStreamIntoPlayer START for box ${parentBoxElement.id}: ${streamUrl}`);
            const playerAreaElement = parentBoxElement.querySelector('.player-area');
            const loaderElement = playerAreaElement?.querySelector('.loader');
            const messageContainerElement = playerAreaElement?.querySelector('.player-message');
            const iframeElement = playerAreaElement?.querySelector('iframe');
            const videoElement = playerAreaElement?.querySelector('video');
            if (!playerAreaElement || !loaderElement || !messageContainerElement || !iframeElement || !videoElement) return;
            clearPlayerStateInBox(parentBoxElement);
            messageContainerElement.classList.remove('visible'); loaderElement.classList.add('visible');
            const streamButtonsContainer = parentBoxElement.querySelector('.stream-buttons');
            if (streamButtonsContainer) streamButtonsContainer.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
            if (clickedButtonElement) clickedButtonElement.classList.add('active');
            if (!streamUrl.startsWith('http://') && !streamUrl.startsWith('https://')) {
                loaderElement.classList.remove('visible');
                displayMessageInPlayerArea(playerAreaElement, `<strong>Invalid URL</strong><span>Link must start with http/https.</span>`, true, streamUrl, parentBoxElement);
                return;
            }
            setTimeout(() => {
                try {
                    const urlObject = new URL(streamUrl);
                    if (urlObject.pathname.toLowerCase().endsWith('.m3u8')) loadHlsStreamIntoVideo(streamUrl, videoElement, playerAreaElement);
                    else loadUrlIntoIframe(streamUrl, iframeElement, playerAreaElement);
                } catch (error) {
                    loaderElement.classList.remove('visible');
                    displayMessageInPlayerArea(playerAreaElement, `<strong>URL Error</strong><span>Could not process link.</span>`, true, streamUrl, parentBoxElement);
                }
            }, 50);
        }
        function clearPlayerStateInBox(boxElement) { /* ... (keep existing code) ... */
             if (!boxElement) return;
            // console.log(`--- clearPlayerStateInBox START for box: ${boxElement.id}`);
            const playerAreaElement = boxElement.querySelector('.player-area'); if (!playerAreaElement) return;
            const videoElement = playerAreaElement.querySelector('video'); const iframeElement = playerAreaElement.querySelector('iframe');
            const loaderElement = playerAreaElement.querySelector('.loader'); const messageContainerElement = playerAreaElement.querySelector('.player-message');
            if (currentHlsInstance && videoElement && currentHlsInstance.media === videoElement) { try { currentHlsInstance.destroy(); } catch (e) { console.error("HLS destroy error:", e); } currentHlsInstance = null; }
            if (iframeElement) { if (iframeElement.getAttribute('src') && iframeElement.getAttribute('src') !== 'about:blank') iframeElement.src = 'about:blank'; iframeElement.classList.remove('active'); }
            if (videoElement) { videoElement.pause(); if (videoElement.hasAttribute('src')) videoElement.removeAttribute('src'); if (videoElement.currentSrc) videoElement.load(); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; }
            if (loaderElement) loaderElement.classList.remove('visible'); if (messageContainerElement) messageContainerElement.classList.remove('visible');
            const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) streamButtonsContainer.querySelectorAll('.stream-button.active').forEach(b => b.classList.remove('active'));
            // console.log(`--- clearPlayerStateInBox END for box: ${boxElement.id}`);
        }
        /**
         * Displays message. Adds "Try Next" button ONLY if BOTH toggles are OFF.
         * @param {HTMLDivElement} playerAreaElement
         * @param {string} messageHtml
         * @param {boolean} showTryNextButton - Intention to show button if conditions met
         * @param {string} [failedUrl=null]
         * @param {HTMLDivElement} [parentBoxElement=null]
         */
        function displayMessageInPlayerArea(playerAreaElement, messageHtml, showTryNextButton, failedUrl = null, parentBoxElement = null) {
             const messageContainerElement = playerAreaElement?.querySelector('.player-message');
             const loaderElement = playerAreaElement?.querySelector('.loader');
             const videoElement = playerAreaElement?.querySelector('video');
             const iframeElement = playerAreaElement?.querySelector('iframe');
             if (!messageContainerElement || !loaderElement || !playerAreaElement) return;
             // console.log("Displaying message in player area:", messageHtml.substring(0, 50) + "...");
             if (videoElement) videoElement.classList.remove('active'); if (iframeElement) iframeElement.classList.remove('active');
             loaderElement.classList.remove('visible');
             messageContainerElement.innerHTML = messageHtml;

             // MODIFIED: Check BOTH toggles before adding "Try Next"
             if (showTryNextButton && failedUrl && parentBoxElement && !openInNewTabEnabled && !openInPlayerPageEnabled) {
                 const nextButtonElement = findNextAvailableStreamButton(failedUrl, parentBoxElement);
                 if (nextButtonElement) {
                     const tryNextBtn = document.createElement('button'); tryNextBtn.className = 'try-next-button'; tryNextBtn.textContent = 'Try Next Source';
                     tryNextBtn.onclick = (event) => { event.stopPropagation(); nextButtonElement.click(); };
                     messageContainerElement.appendChild(document.createElement('br')); messageContainerElement.appendChild(tryNextBtn);
                 } else {
                     const noMoreSpan = document.createElement('span'); noMoreSpan.style.cssText = 'font-size:0.8em;margin-top:10px;display:block;'; noMoreSpan.textContent = '(No more sources available)'; messageContainerElement.appendChild(noMoreSpan);
                 }
             } else if (showTryNextButton && (openInNewTabEnabled || openInPlayerPageEnabled)) {
                  console.log("   'Try Next Source' button skipped because a new tab toggle is enabled.");
             }
             messageContainerElement.classList.add('visible');
        }
        function findNextAvailableStreamButton(failedUrl, parentBoxElement) { /* ... (keep existing code) ... */
             if (!failedUrl || !parentBoxElement) return null;
            const allButtonsInBox = parentBoxElement.querySelectorAll('.stream-button'); let foundFailedButton = false;
            for (let i = 0; i < allButtonsInBox.length; i++) {
                const currentButton = allButtonsInBox[i]; if (currentButton.dataset.streamUrl === failedUrl) foundFailedButton = true;
                else if (foundFailedButton) return currentButton;
            } return null;
        }
        function loadHlsStreamIntoVideo(hlsUrl, videoElement, playerAreaElement) { /* ... (keep existing code, including safety check) ... */
            if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadHlsStreamIntoVideo called, but toggle enabled. Aborting."); return; }
            /* ... rest of HLS loading logic ... */
             const parentBoxElement = videoElement.closest('.channel-box'); videoElement.poster = CONFIG.placeholderImage;
            if (Hls.isSupported()) {
                if (currentHlsInstance && currentHlsInstance.media === videoElement) { currentHlsInstance.destroy(); currentHlsInstance = null; }
                else if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; }
                currentHlsInstance = new Hls({ liveSyncDurationCount: 2, manifestLoadingTimeOut: 15000, levelLoadingTimeOut: 15000, fragLoadingTimeOut: 20000, manifestLoadErrorMaxRetry: 3, levelLoadErrorMaxRetry: 4, fragLoadErrorMaxRetry: 5 });
                const hlsErrorListener = (event, data) => { /* ... error handling ... */
                    if (!currentHlsInstance || currentHlsInstance.media !== videoElement) return;
                    console.error('HLS.js Error:', data.type, data.details, data.fatal); let userMessage = `Stream Error (${data.details || 'Unknown'}).`;
                    if (data.type === Hls.ErrorTypes.NETWORK_ERROR) userMessage = `Network Error (${data.details}).`;
                    else if (data.type === Hls.ErrorTypes.MEDIA_ERROR && data.details !== 'bufferStalledError') userMessage = `Media Error (${data.details}).`;
                    if (data.fatal) { displayMessageInPlayerArea(playerAreaElement, `<strong>${userMessage}</strong>`, true, hlsUrl, parentBoxElement); if (currentHlsInstance && currentHlsInstance.media === videoElement) { currentHlsInstance.destroy(); currentHlsInstance = null; } videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; }
                };
                const hlsManifestParsedListener = () => { /* ... manifest parsed handling ... */
                     if (!currentHlsInstance || currentHlsInstance.media !== videoElement) return;
                    playerAreaElement.querySelector('.loader').classList.remove('visible'); videoElement.classList.add('active'); videoElement.muted = true;
                    videoElement.play().catch(error => { if (currentHlsInstance && currentHlsInstance.media === videoElement) { displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>${error.name === 'NotAllowedError' ? 'Click play to start.' : error.message}</span>`, error.name !== 'NotAllowedError', hlsUrl, parentBoxElement); if(error.name !== 'NotAllowedError') videoElement.classList.remove('active'); playerAreaElement.querySelector('.loader').classList.remove('visible'); } });
                };
                currentHlsInstance.on(Hls.Events.ERROR, hlsErrorListener); currentHlsInstance.on(Hls.Events.MANIFEST_PARSED, hlsManifestParsedListener);
                currentHlsInstance.attachMedia(videoElement); currentHlsInstance.loadSource(hlsUrl);
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; }
                const handleNativeLoadedMetadata = () => { /* ... native load handling ... */
                    if (videoElement.getAttribute('src') !== hlsUrl) return; playerAreaElement.querySelector('.loader').classList.remove('visible'); videoElement.classList.add('active'); videoElement.muted = true; videoElement.play().catch(error => { if (videoElement.getAttribute('src') === hlsUrl) { displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>${error.name === 'NotAllowedError' ? 'Click play.' : error.message}</span>`, error.name !== 'NotAllowedError', hlsUrl, parentBoxElement); if(error.name !== 'NotAllowedError') videoElement.classList.remove('active'); playerAreaElement.querySelector('.loader').classList.remove('visible'); } });
                };
                const handleNativeError = () => { /* ... native error handling ... */
                     if (videoElement.getAttribute('src') !== hlsUrl) return; const error = videoElement.error; const msg = error ? (error.message || `code ${error.code}`) : 'Unknown'; displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>Native HLS failed: ${msg}.</span>`, true, hlsUrl, parentBoxElement); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; playerAreaElement.querySelector('.loader').classList.remove('visible');
                };
                videoElement.removeEventListener('loadedmetadata', handleNativeLoadedMetadata); videoElement.removeEventListener('error', handleNativeError);
                videoElement.addEventListener('loadedmetadata', handleNativeLoadedMetadata); videoElement.addEventListener('error', handleNativeError);
                videoElement.src = hlsUrl; videoElement.load();
            } else {
                displayMessageInPlayerArea(playerAreaElement, `<strong>Unsupported Stream</strong><span>Browser cannot play HLS (.m3u8).</span>`, false); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; playerAreaElement.querySelector('.loader').classList.remove('visible');
            }
        }
        function loadUrlIntoIframe(iframeUrl, iframeElement, playerAreaElement) { /* ... (keep existing code, including safety check) ... */
            if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadUrlIntoIframe called, but toggle enabled. Aborting."); return; }
            /* ... rest of iframe loading logic ... */
             const parentBoxElement = iframeElement.closest('.channel-box'); let iframeLoadTimeoutId = null; let isLoadSuccessful = false;
            if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; }
            const cleanupIframeLoad = () => { clearTimeout(iframeLoadTimeoutId); iframeElement.onload = null; iframeElement.onerror = null; };
            const handleIframeLoadFailure = (reason) => { cleanupIframeLoad(); if (iframeElement.getAttribute('src') === iframeUrl) { displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>${reason}. Might be offline/blocked.</span>`, true, iframeUrl, parentBoxElement); iframeElement.classList.remove('active'); iframeElement.src = 'about:blank'; playerAreaElement.querySelector('.loader').classList.remove('visible'); } };
            iframeLoadTimeoutId = setTimeout(() => { if (!isLoadSuccessful && iframeElement.getAttribute('src') === iframeUrl) handleIframeLoadFailure(`Load timeout (${CONFIG.iframeLoadTimeoutMs / 1000}s)`); }, CONFIG.iframeLoadTimeoutMs);
            iframeElement.onload = () => { if (iframeElement.getAttribute('src') === iframeUrl) { isLoadSuccessful = true; cleanupIframeLoad(); playerAreaElement.querySelector('.loader').classList.remove('visible'); iframeElement.classList.add('active'); } else if (iframeElement.getAttribute('src') !== 'about:blank') { /* ignore */ } };
            iframeElement.onerror = () => { if (iframeElement.getAttribute('src') === iframeUrl) handleIframeLoadFailure("onError event fired"); };
            iframeElement.src = iframeUrl;
        }

        // --- Utility Functions ---
        function updateTimestampDisplay() { /* ... (keep existing code) ... */
             try { const now = new Date(); const timeString = new Intl.DateTimeFormat(navigator.language || 'en-US', { hour: '2-digit', minute: '2-digit' }).format(now); lastUpdatedTimestampElement.textContent = `Updated: ${timeString}`; } catch (error) { lastUpdatedTimestampElement.textContent = "Updated: Error"; }
        }
        function showInitialLoadingMessage(text = "Loading...") { /* ... (keep existing code) ... */
             initialLoadingMessageElement.textContent = text; initialLoadingMessageElement.style.display = 'block';
        }
        function hideInitialLoadingMessage() { /* ... (keep existing code) ... */
              initialLoadingMessageElement.style.display = 'none';
        }
        function showDataFetchErrorMessage(text = "An error occurred.") { /* ... (keep existing code) ... */
               dataFetchErrorMessageElement.innerHTML = `<strong>Error</strong><span>${text}</span>`; dataFetchErrorMessageElement.style.display = 'block';
        }

    } // End of initializeApp() function
</script>

</body>
</html>
