<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        :root {
            /* Grayish-black color scheme */
            --bg-primary: #111827; /* Very dark gray */
            --bg-secondary: #1f2937; /* Dark gray */
            --bg-tertiary: #374151; /* Medium gray */
            --accent-color: #dc2626; /* Red accent */
            --text-primary: #f3f4f6; /* Light gray (near white) */
            --text-secondary: #9ca3af; /* Medium gray */
            --border-color: #374151;
            --font-sans: 'Inter', sans-serif;
        }

        /* Basic Reset & Body Styling */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth; /* Smooth scroll for jumping to expanded item */
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-sans);
            line-height: 1.6;
            overscroll-behavior-y: contain;
        }

        /* Password Screen */
        #passwordScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-primary); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10000; padding: 20px;
        }
        #passwordScreen h2 { color: var(--text-primary); margin-bottom: 15px; font-weight: 600; }
        #passwordInput {
            padding: 12px 15px; font-size: 1em; border-radius: 8px;
            border: 1px solid var(--border-color); background-color: var(--bg-secondary);
            color: var(--text-primary); margin: 10px 0; width: 100%;
            max-width: 300px; text-align: center;
        }
        #passwordScreen button {
            padding: 12px 30px; font-size: 1em; border: none;
            background-color: var(--accent-color); color: white; border-radius: 8px;
            cursor: pointer; font-weight: 600; transition: background-color 0.2s ease;
        }
        #passwordScreen button:hover { background-color: #b91c1c; /* Darker red */ }
        #errorMessage { color: #f87171; margin-top: 15px; display: none; font-weight: 600; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); } 25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); } 75% { transform: translateX(-6px); }
        }
        .shake { animation: shake 0.4s ease-in-out; }

        /* Main Container & Header */
        .container { max-width: 1400px; margin: 0 auto; padding: 0 15px; }
        header { text-align: center; padding: 25px 0 15px; }
        header img { max-width: 220px; height: auto; }

        /* Tabs */
        .tabs {
            display: flex; justify-content: center; gap: 10px;
            margin-bottom: 30px; flex-wrap: wrap; padding: 0 10px;
        }
        .tab-button {
            background: var(--bg-secondary); color: var(--text-secondary);
            border: 1px solid var(--border-color); padding: 10px 20px; cursor: pointer;
            border-radius: 8px; font-size: 0.95em; font-weight: 600; transition: all 0.2s ease;
        }
        .tab-button:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        .tab-button.active {
            background: var(--accent-color); color: white; border-color: var(--accent-color);
        }

        /* Channel Grid */
        .channel-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px; padding: 0 10px 40px; display: none; /* Hidden by default */
        }
        .channel-grid.active { display: grid; }
        #Matches.channel-grid {
            grid-template-columns: 1fr; max-width: 900px; margin: 0 auto;
        }
         #Matches.channel-grid.active { display: grid; }

        /* Channel Box */
        .channel-box {
            background: var(--bg-secondary); border-radius: 12px;
            padding: 15px; cursor: pointer; transition: all 0.3s ease;
            border: 1px solid var(--border-color); position: relative;
            overflow: hidden; /* Important for initial state */
        }
        .channel-box:not(.expanded):hover { /* Hover effect only when not expanded */
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: var(--text-secondary);
        }
        .channel-header {
            display: flex; align-items: center; justify-content: center;
            gap: 10px; text-align: center; min-height: 50px; flex-wrap: wrap;
        }
        .channel-header img { height: 28px; width: auto; object-fit: contain; flex-shrink: 0; }
        .channel-header h3 { font-size: 1.1em; font-weight: 600; margin: 0; flex-grow: 1; word-break: break-word; }
        .match-time { font-size: 0.85em; color: var(--text-secondary); text-align: center; margin-top: 8px; margin-bottom: 5px; }

        /* Expanded Channel Box Styling */
        .channel-box.expanded {
            grid-column: 1 / -1; /* Span full width of the grid */
            cursor: default; /* Not clickable when expanded */
            background: var(--bg-tertiary); /* Slightly lighter background when expanded */
            padding-bottom: 20px; /* More space at the bottom */
            z-index: 10;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            border-color: var(--accent-color);
            /* Ensure header stays visible */
            overflow: visible;
        }

        /* Iframe/Video Container inside the box */
        .iframe-container {
            margin-top: 15px;
            display: none; /* Hidden by default */
            width: 100%;
        }
        .channel-box.expanded .iframe-container {
            display: block; /* Show when box is expanded */
        }

        .player-area {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9; /* Maintain aspect ratio */
            background-color: #000; /* Black background */
            border-radius: 8px;
            overflow: hidden; /* Clip iframe/video */
            margin-bottom: 15px;
            min-height: 200px; /* Minimum height */
        }
        /* Make iframe/video fill the player area */
        .player-area iframe,
        .player-area video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            display: none; /* Hide both initially */
            object-fit: contain; /* Fit video within bounds */
        }
        .player-area iframe.active,
        .player-area video.active {
            display: block; /* Show the active one */
        }
        /* Increase height on larger screens when expanded */
        @media (min-width: 768px) {
            .channel-box.expanded .player-area {
                 min-height: 400px; /* Larger minimum height */
                 max-height: 70vh; /* Limit max height */
            }
        }
         @media (min-width: 1024px) {
            .channel-box.expanded .player-area {
                 min-height: 500px;
            }
        }


        /* Stream Buttons inside the box */
        .stream-buttons {
            text-align: center;
            margin-top: 10px; /* Spacing below player */
        }
        .stream-buttons div { margin-bottom: 8px; }
        .stream-buttons strong { color: var(--text-secondary); font-size: 0.9em; margin-right: 5px; }
        .stream-button {
            background: var(--bg-secondary); /* Darker buttons inside expanded */
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px; margin: 3px; border-radius: 6px; cursor: pointer;
            font-size: 0.85em; font-weight: 500; transition: all 0.2s ease;
            display: inline-block;
        }
        .stream-button:hover { background: #4b5563; border-color: #6b7280; }
        .stream-button.active {
            background: var(--accent-color); color: white;
            border-color: var(--accent-color); font-weight: 600;
        }

        /* Footer */
        footer { text-align: center; color: var(--text-secondary); font-size: 0.85em; margin-top: 30px; padding-bottom: 20px; }

        /* Loading/Error States */
        .loading-message, .error-message { text-align: center; padding: 40px 20px; color: var(--text-secondary); font-size: 1.1em; }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container { padding: 0 10px; }
            header img { max-width: 180px; }
            .tabs { gap: 8px; margin-bottom: 20px; }
            .tab-button { padding: 8px 15px; font-size: 0.9em; }
            .channel-grid { grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; }
            #Matches.channel-grid { max-width: 100%; }
            .stream-button { padding: 5px 10px; font-size: 0.8em; }
        }
        @media (max-width: 480px) {
            header img { max-width: 150px; }
            .channel-grid { grid-template-columns: 1fr; gap: 12px; }
            .channel-box { padding: 12px; }
            .channel-header h3 { font-size: 1em; }
            .channel-header img { height: 24px; }
            .stream-buttons strong { display: block; margin-bottom: 3px; }
            .player-area { min-height: 180px; } /* Adjust min height for small screens */
        }

    </style>
</head>
<body>

<div id="passwordScreen">
    <h2>Enter Password</h2>
    <input type="password" id="passwordInput" placeholder="******">
    <button id="passwordButton">Enter</button>
    <p id="errorMessage">Incorrect Password!</p>
</div>

<div class="container">
    <header>
        <img src="ptvlogo.png" alt="PERAS TV Logo">
    </header>

    <div class="tabs">
        <button class="tab-button active" data-tab="PT">PT</button>
        <button class="tab-button" data-tab="UK">UK</button>
        <button class="tab-button" data-tab="ES">ES</button>
        <button class="tab-button" data-tab="Matches">Matches</button>
    </div>

    <div id="loadingMessage" class="loading-message">Loading channels...</div>
    <div id="fetchErrorMessage" class="error-message" style="display: none;"></div>

    <div id="PT" class="channel-grid active"></div>
    <div id="UK" class="channel-grid"></div>
    <div id="ES" class="channel-grid"></div>
    <div id="Matches" class="channel-grid"></div>

    <footer>
        <p id="lastUpdated"></p>
    </footer>
</div>

<script>
    // --- Configuration ---
    const CONFIG = {
        password: "ptv123",
        channelsUrl: "channels.json",
        matchesUrl: "matches.json",
        placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%23000"/></svg>'
    };

    // --- DOM Elements ---
    const passwordScreen = document.getElementById('passwordScreen');
    const passwordInput = document.getElementById('passwordInput');
    const passwordButton = document.getElementById('passwordButton');
    const passwordErrorMessage = document.getElementById('errorMessage');
    const tabsContainer = document.querySelector('.tabs');
    const channelGrids = document.querySelectorAll('.channel-grid');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const loadingMessage = document.getElementById('loadingMessage');
    const fetchErrorMessage = document.getElementById('fetchErrorMessage');

    // --- State ---
    let hlsInstance = null;
    let channelsData = {};
    let matchesData = [];
    let currentlyExpandedBox = null; // Track the currently expanded box

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        setupPasswordProtection();
        setupEventListeners();
        updateTimestamp();
        loadData();
    });

    // --- Password Protection ---
    function setupPasswordProtection() {
        if (sessionStorage.getItem('authenticated') === 'true') {
            hidePasswordScreen();
        } else {
            document.body.style.overflow = 'hidden';
            passwordScreen.style.display = 'flex';
            passwordInput.focus();
        }
    }

    function verifyPassword() {
        if (passwordInput.value === CONFIG.password) {
            sessionStorage.setItem('authenticated', 'true');
            hidePasswordScreen();
        } else {
            passwordErrorMessage.style.display = 'block';
            passwordInput.classList.add('shake');
            passwordInput.value = '';
            passwordInput.focus();
            setTimeout(() => passwordInput.classList.remove('shake'), 500);
        }
    }

    function hidePasswordScreen() {
        passwordScreen.style.display = 'none';
        document.body.style.overflow = '';
    }

    // --- Event Listeners ---
    function setupEventListeners() {
        // Password
        passwordButton.addEventListener('click', verifyPassword);
        passwordInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') verifyPassword();
            passwordErrorMessage.style.display = 'none';
        });

        // Tabs
        tabsContainer.addEventListener('click', (event) => {
            if (event.target.classList.contains('tab-button')) {
                showTab(event.target.dataset.tab);
            }
        });

        // Close expanded box with Escape key (if one is open)
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && currentlyExpandedBox) {
                 toggleExpansion(currentlyExpandedBox); // Collapse the current box
            }
        });
    }

    // --- Data Fetching & Rendering ---
    async function loadData() {
        loadingMessage.style.display = 'block';
        fetchErrorMessage.style.display = 'none';
        try {
            const [channelsRes, matchesRes] = await Promise.all([
                fetch(CONFIG.channelsUrl),
                fetch(CONFIG.matchesUrl)
            ]);

            if (!channelsRes.ok || !matchesRes.ok) {
                throw new Error(`Failed to load data (Channels: ${channelsRes.status}, Matches: ${matchesRes.status})`);
            }

            channelsData = await channelsRes.json();
            matchesData = await matchesRes.json();

            renderAllChannels();
            loadingMessage.style.display = 'none';

        } catch (error) {
            console.error("Failed to load channel or match data:", error);
            loadingMessage.style.display = 'none';
            fetchErrorMessage.textContent = `Error loading data: ${error.message}. Please try refreshing.`;
            fetchErrorMessage.style.display = 'block';
        }
    }

    function renderAllChannels() {
        renderChannels('PT', channelsData.PT || []);
        renderChannels('UK', channelsData.UK || []);
        renderChannels('ES', channelsData.ES || []);
        renderMatchChannels(matchesData || []);
        addChannelBoxEventListeners(); // Add listeners *after* elements are in the DOM
    }

    function renderChannels(tabId, channels) {
        const grid = document.getElementById(tabId);
        if (!grid) return;
        grid.innerHTML = '';
        if (!channels || channels.length === 0) {
            grid.innerHTML = '<p class="loading-message">No channels available.</p>';
            return;
        }
        channels.forEach((channel, index) => {
            const box = createChannelBoxElement(channel, tabId, index);
            grid.appendChild(box);
        });
    }

    function renderMatchChannels(matches) {
        const grid = document.getElementById('Matches');
        if (!grid) return;
        grid.innerHTML = '';
         if (!matches || matches.length === 0) {
            grid.innerHTML = '<p class="loading-message">No matches available.</p>';
            return;
        }
        matches.forEach((match, index) => {
            const box = createMatchBoxElement(match, index);
            grid.appendChild(box);
        });
    }

    // --- Element Creation ---
    function createChannelBoxElement(channel, tabId, index) {
        const { name, srcs = [] } = channel;
        const box = document.createElement('div');
        box.className = 'channel-box';
        // Store data needed for expansion
        box.dataset.channelName = name;
        box.dataset.sources = JSON.stringify(srcs);

        box.innerHTML = `
            <div class="channel-header">
                <h3>${name}</h3>
            </div>
            <div class="iframe-container">
                <div class="player-area">
                    <iframe allow="autoplay; fullscreen" allowfullscreen></iframe>
                    <video controls autoplay muted playsinline></video>
                </div>
                <div class="stream-buttons">
                    </div>
            </div>
        `;
        return box;
    }

     function createMatchBoxElement(match, index) {
        const { team1, team2, logo1 = '', logo2 = '', time = '', pt = [], uk = [], es = [] } = match;
        const box = document.createElement('div');
        box.className = 'channel-box';
        const allSources = { pt, uk, es };
        box.dataset.channelName = `${team1} vs ${team2}`;
        box.dataset.sources = JSON.stringify(allSources);

        box.innerHTML = `
            <div class="channel-header">
                ${logo1 ? `<img src="${logo1}" alt="${team1} logo">` : ''}
                <h3>${team1} vs ${team2}</h3>
                 ${logo2 ? `<img src="${logo2}" alt="${team2} logo">` : ''}
            </div>
            ${time ? `<p class="match-time">${time}</p>` : ''}
             <div class="iframe-container">
                 <div class="player-area">
                    <iframe allow="autoplay; fullscreen" allowfullscreen></iframe>
                    <video controls autoplay muted playsinline></video>
                </div>
                <div class="stream-buttons">
                    </div>
            </div>
        `;
        return box;
    }

    // --- Event Listener Setup for Channel Boxes ---
    function addChannelBoxEventListeners() {
         document.querySelectorAll('.channel-box').forEach(box => {
             // Use event delegation on the header part for clicking to expand/collapse
            const header = box.querySelector('.channel-header');
            if (header) {
                 header.addEventListener('click', (event) => {
                     // Prevent clicks on internal elements within header if needed
                     // if (event.target !== header && !header.contains(event.target)) return;
                     toggleExpansion(box);
                 });
            }

            // Prevent clicks inside the iframe-container from bubbling up and collapsing
            const iframeContainer = box.querySelector('.iframe-container');
            if (iframeContainer) {
                 iframeContainer.addEventListener('click', (event) => {
                     event.stopPropagation();
                 });
            }
        });
    }

    // --- Tab Management ---
    function showTab(tabId) {
        tabsContainer.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });
        channelGrids.forEach(grid => {
            grid.classList.toggle('active', grid.id === tabId);
        });
        // Collapse any open channel when switching tabs
        if (currentlyExpandedBox) {
            collapseBox(currentlyExpandedBox);
        }
    }

    // --- Channel Box Expansion ---
    function toggleExpansion(boxToToggle) {
        const isExpanding = !boxToToggle.classList.contains('expanded');

        // If another box is already expanded, collapse it first
        if (isExpanding && currentlyExpandedBox && currentlyExpandedBox !== boxToToggle) {
            collapseBox(currentlyExpandedBox);
        }

        // Toggle the target box
        if (isExpanding) {
            expandBox(boxToToggle);
        } else {
            collapseBox(boxToToggle);
        }
    }

    function expandBox(box) {
        box.classList.add('expanded');
        currentlyExpandedBox = box;

        // Populate buttons and load first stream
        populateAndLoadFirstStream(box);

        // Scroll the box into view smoothly
        box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    function collapseBox(box) {
        box.classList.remove('expanded');
        if (currentlyExpandedBox === box) {
            currentlyExpandedBox = null;
        }
        // Clear player when collapsing
        clearPlayerInBox(box);
        // Clear buttons
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.innerHTML = '';
        }
    }

    function populateAndLoadFirstStream(box) {
        const sourcesData = box.dataset.sources;
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (!sourcesData || !streamButtonsDiv) return;

        streamButtonsDiv.innerHTML = ''; // Clear previous buttons
        let firstUrl = null;

        try {
            const sources = JSON.parse(sourcesData);

            if (Array.isArray(sources)) { // Regular channels
                if (sources.length > 0) {
                    sources.forEach((src, idx) => {
                        const url = typeof src === 'object' ? src.url : src;
                        const label = typeof src === 'object' ? src.label : `Stream ${idx + 1}`;
                        if (!firstUrl) firstUrl = url;
                        const button = createStreamButton(label, url, box); // Pass box context
                        streamButtonsDiv.appendChild(button);
                    });
                } else {
                     streamButtonsDiv.innerHTML = '<p>No streams available.</p>';
                }
            } else { // Match sources (object)
                let streamCount = 0;
                Object.entries(sources).forEach(([lang, langSources]) => {
                    if (langSources && langSources.length > 0) {
                        const langDiv = document.createElement('div');
                        const strong = document.createElement('strong');
                        strong.textContent = `${lang.toUpperCase()}:`;
                        langDiv.appendChild(strong);
                        langSources.forEach((src, idx) => {
                            const url = typeof src === 'object' ? src.url : src;
                            const label = typeof src === 'object' ? src.label : `${idx + 1}`;
                            if (!firstUrl) firstUrl = url;
                            const button = createStreamButton(label, url, box); // Pass box context
                            langDiv.appendChild(button);
                            streamCount++;
                        });
                        streamButtonsDiv.appendChild(langDiv);
                    }
                });
                 if (streamCount === 0) {
                     streamButtonsDiv.innerHTML = '<p>No streams available.</p>';
                }
            }

            // Load the first stream if found
            if (firstUrl) {
                 const firstButton = streamButtonsDiv.querySelector('.stream-button');
                 if (firstButton) {
                     changeStream(firstButton, firstUrl, box);
                 }
            } else {
                clearPlayerInBox(box); // No streams, ensure player is cleared
            }

        } catch (e) {
            console.error("Failed to parse sources data for box:", e);
            streamButtonsDiv.innerHTML = '<p>Error loading stream data.</p>';
        }
    }

    function createStreamButton(label, url, contextBox) {
        const button = document.createElement('button');
        button.className = 'stream-button';
        button.textContent = label;
        button.onclick = (event) => {
            event.stopPropagation(); // Prevent collapse
            changeStream(button, url, contextBox);
        };
        return button;
    }

    // --- Stream Handling (within a specific box) ---
    function changeStream(clickedButton, url, contextBox) {
        console.log(`Attempting to load stream in box: ${url}`);
        clearPlayerInBox(contextBox); // Clear previous stream in this box

        // Activate the clicked button within this box
        const streamButtonsDiv = contextBox.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
             streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
        clickedButton.classList.add('active');

        // Get player elements specific to this box
        const iframe = contextBox.querySelector('.player-area iframe');
        const video = contextBox.querySelector('.player-area video');

        if (!iframe || !video) {
            console.error("Could not find player elements in context box.");
            return;
        }

        // Determine stream type and load
        if (url && typeof url === 'string') {
             if (url.toLowerCase().endsWith('.m3u8')) {
                loadHlsStream(url, video); // Pass the specific video element
            } else {
                loadIframeStream(url, iframe); // Pass the specific iframe element
            }
        } else {
            console.error("Invalid stream URL:", url);
            alert("Invalid stream URL provided.");
        }
    }

     function clearPlayerInBox(box) {
         // Stop HLS playback if it belongs to this box
        if (hlsInstance && currentlyExpandedBox === box) {
            hlsInstance.destroy();
            hlsInstance = null;
        }
        // Clear iframe src
        const iframe = box.querySelector('.player-area iframe');
        if (iframe) {
             iframe.src = 'about:blank';
             iframe.classList.remove('active');
        }
        // Clear video src and stop
        const video = box.querySelector('.player-area video');
        if (video) {
             video.pause();
             video.removeAttribute('src');
             video.load();
             video.classList.remove('active');
        }
        // Deactivate buttons in this box
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
    }

    function loadHlsStream(url, videoElement) {
        videoElement.poster = CONFIG.placeholderImage;
        videoElement.classList.add('active');

        if (Hls.isSupported()) {
            console.log("HLS.js is supported. Initializing...");
            // Ensure previous instance related to this box is destroyed
            if (hlsInstance) hlsInstance.destroy();

            hlsInstance = new Hls({ /* Optional config */ });

            hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                console.error('HLS.js Error:', event, data);
                 if (data.fatal) {
                    alert(`Stream Error: ${data.details}. Try another source.`);
                    // Clean up on fatal error
                    if(hlsInstance) hlsInstance.destroy();
                    hlsInstance = null;
                    videoElement.classList.remove('active'); // Hide player on error
                 }
            });

            hlsInstance.loadSource(url);
            hlsInstance.attachMedia(videoElement);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                console.log("HLS Manifest parsed, attempting to play...");
                videoElement.play().catch(e => console.error("Video play failed:", e));
            });

        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            console.log("Using native HLS support.");
            videoElement.src = url;
            videoElement.play().catch(e => console.error("Video play failed:", e));
        } else {
            console.error("HLS is not supported by this browser.");
            alert("HLS playback is not supported in your browser.");
            videoElement.classList.remove('active');
        }
    }

    function loadIframeStream(url, iframeElement) {
        console.log("Loading iframe stream...");
        iframeElement.src = url;
        iframeElement.classList.add('active');
        iframeElement.onload = () => console.log("Iframe onload event fired.");
        iframeElement.onerror = () => {
             console.error("Iframe onerror event fired.");
             alert("Failed to load the iframe source. It might be blocked or unavailable.");
             iframeElement.classList.remove('active');
        };
    }

    // --- Utility ---
    function updateTimestamp() {
        const now = new Date();
        lastUpdatedEl.textContent = `Last updated: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }

</script>

</body>
</html>
