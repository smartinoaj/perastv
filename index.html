<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- CSS Variables (Theme) --- */
        :root {
            /* Theme Colors */
            --bg-primary: #0a0a0a; /* Main background */
            --bg-secondary: #1a1a1a; /* Card/input background */
            --bg-tertiary: #2a2a2a; /* Expanded card/hover background */
            --accent-color: #e50914; /* Red accent */
            --text-primary: #ffffff; /* Primary text */
            --text-secondary: #a0a0a0; /* Secondary text (placeholders, info) */
            --border-color: #4a4a4a; /* Slightly softer border */
            --border-color-active: #6b7280; /* Border for active/focused elements */
            --error-color: #f87171; /* Red for errors */
            --favorite-color: #facc15; /* Gold/Yellow for favorite star */
            --info-color: #3b82f6; /* Blue for informational messages */
            --font-sans: 'Inter', sans-serif; /* Main font */
        }

        /* --- Basic Reset & Body Styling --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; height: 100%; }
        body {
            background-color: var(--bg-primary); color: var(--text-primary);
            font-family: var(--font-sans); line-height: 1.6;
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh issues */
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
            padding-bottom: 120px; /* Space for footer */
            position: relative; /* Needed for footer positioning? */
        }
        .container { max-width: 1600px; margin: 0 auto; padding: 0 20px; }

        /* --- Header --- */
        header { text-align: center; padding: 30px 0 20px; }
        header img { max-width: 200px; height: auto; }

        /* --- Search Bar --- */
        .search-container { display: flex; justify-content: center; margin-bottom: 30px; padding: 0 15px; }
        #search-input {
            padding: 12px 18px; font-size: 1em; border-radius: 25px;
            border: 1px solid var(--border-color); background-color: var(--bg-secondary);
            color: var(--text-primary); width: 100%; max-width: 500px;
            transition: all 0.2s ease; text-align: center;
            appearance: none; /* Remove default search input styling */
        }
        #search-input:focus { outline: none; border-color: var(--border-color-active); background-color: var(--bg-tertiary); }
        #search-input::placeholder { color: var(--text-secondary); text-align: center; }
        /* Cross-browser placeholder centering */
        #search-input::-webkit-input-placeholder { text-align: center; }
        #search-input:-moz-placeholder { text-align: center; }
        #search-input::-moz-placeholder { text-align: center; }
        #search-input:-ms-input-placeholder { text-align: center; }

        /* --- Tabs --- */
        .tabs { display: flex; justify-content: center; gap: 12px; margin-bottom: 40px; flex-wrap: wrap; padding: 0 10px; }
        .tab-button {
            background: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-color); padding: 10px 25px; cursor: pointer;
            border-radius: 20px; font-size: 0.9em; font-weight: 600;
            transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px;
            display: inline-flex; align-items: center; gap: 6px; /* Align icon and text */
            white-space: nowrap; /* Prevent wrapping */
        }
        .tab-button .tab-icon { width: 1em; height: 1em; fill: currentColor; flex-shrink: 0; }
        .tab-button:hover { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--bg-tertiary); }
        .tab-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); }
        .tab-button.active .tab-icon { fill: white; }

        /* Favorites Tab Button Styling */
        .tab-button[data-tab="Favorites"] { color: var(--favorite-color); border-color: var(--favorite-color); padding: 10px 15px; } /* Slightly less padding for icon-only */
        .tab-button[data-tab="Favorites"] .tab-icon { fill: var(--favorite-color); }
        .tab-button[data-tab="Favorites"]:hover { background: var(--favorite-color); color: var(--bg-secondary); border-color: var(--favorite-color); }
        .tab-button[data-tab="Favorites"]:hover .tab-icon { fill: var(--bg-secondary); }
        .tab-button[data-tab="Favorites"].active { background: var(--favorite-color); color: var(--bg-secondary); border-color: var(--favorite-color); }
        .tab-button[data-tab="Favorites"].active .tab-icon { fill: var(--bg-secondary); }

        /* --- Channel Grid (General) --- */
        .channel-grid {
            display: grid;
            /* Responsive columns: Start with 1, increase for larger screens */
            grid-template-columns: 1fr;
            gap: 20px; padding: 0 10px 50px;
            display: none; /* Hidden by default, shown when active */
        }
        /* Grid Columns adjustments based on screen size and specific tabs */
        @media (min-width: 640px) { /* Small screens and up */
             /* Most grids go to 2 columns */
            .channel-grid#PT, .channel-grid#UK, .channel-grid#ES,
            .channel-grid#ALL, .channel-grid#Favorites { grid-template-columns: repeat(2, 1fr); }
             /* Matches grid remains single column but wider */
            #Matches.channel-grid { grid-template-columns: 1fr; max-width: 800px; margin: 0 auto; }
        }
        @media (min-width: 1024px) { /* Medium screens and up */
             /* Most grids go to 3 columns */
            .channel-grid#PT, .channel-grid#UK, .channel-grid#ES,
            .channel-grid#ALL, .channel-grid#Favorites { grid-template-columns: repeat(3, 1fr); }
             /* Matches grid stays wide single column */
            #Matches.channel-grid { max-width: 1000px; }
        }
        @media (min-width: 1280px) { /* Large screens and up */
             /* Most grids go to 4 columns */
            .channel-grid#PT, .channel-grid#UK, .channel-grid#ES,
            .channel-grid#ALL, .channel-grid#Favorites { grid-template-columns: repeat(4, 1fr); }
        }

        /* Show active grid */
        .channel-grid.active { display: grid; }

        /* --- Channel Box (General Styling) --- */
        .channel-box {
            background: var(--bg-secondary); border-radius: 10px; padding: 15px;
            cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            border: 1px solid transparent; /* Start with transparent border for smooth transition */
            position: relative; overflow: hidden;
            display: flex; /* Use flexbox for vertical centering if needed */
            flex-direction: column; /* Stack header/info vertically */
        }
        /* Specific styling for MATCH boxes when NOT expanded (full width in Matches/ALL tabs) */
        #Matches .channel-box[id^="match-"]:not(.expanded),
        #ALL .channel-box[id^="match-"]:not(.expanded) {
            grid-column: 1 / -1; /* Span full grid width */
             /* Max width is handled by the grid container's max-width */
             width: 100%; /* Take full width of the grid column */
             margin: auto;
        }
        /* Channel boxes in ALL/Favorites should behave like normal grid items */
        #ALL .channel-box:not([id^="match-"]):not(.expanded),
        #Favorites .channel-box:not(.expanded) {
            grid-column: auto / span 1; width: auto; max-width: none; margin: 0;
        }
        /* Hide filtered-out boxes */
        .channel-box.hidden { display: none; }
        /* Hover effect for non-expanded boxes */
        .channel-box:not(.expanded):hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
            border-color: var(--border-color-active);
        }

        /* --- Favorite Button (Star Icon) --- */
        .favorite-button {
            position: absolute; top: 10px; right: 10px;
            background: none; border: none; padding: 5px; cursor: pointer;
            z-index: 5; /* Above other content */
            color: var(--text-secondary); transition: color 0.2s ease;
        }
        .favorite-button svg { width: 20px; height: 20px; fill: none; stroke: currentColor; stroke-width: 1.5; }
        .favorite-button:hover { color: var(--text-primary); }
        .favorite-button.is-favorite { color: var(--favorite-color); }
        .favorite-button.is-favorite svg { fill: currentColor; stroke-width: 0; } /* Fill when favorited */

        /* --- Channel Header --- */
        .channel-header {
            display: flex; align-items: center; justify-content: center; /* Center items horizontally */
            gap: 10px; text-align: center; min-height: 40px; /* Ensure consistent height */
            cursor: pointer; padding-right: 30px; /* Space for favorite button */
            width: 100%; /* Ensure header takes full width */
        }
        /* Matches Header Layout (adjust gap if needed) */
        .channel-box[id^="match-"] .channel-header { justify-content: center; gap: 15px; }
        /* Logo styling for MATCHES */
        .match-logo {
            height: 40px; width: 40px; object-fit: contain; /* Scale nicely */
            flex-shrink: 0; border-radius: 4px; display: inline-block; vertical-align: middle;
            /* REMOVED background-color */
        }
        /* Title */
        .channel-header h3 {
            font-size: 1.1em; font-weight: 600; margin: 0;
            word-break: break-word; /* Prevent long names overflowing */
            text-align: center;
            flex-grow: 1; /* Allow title to take available space */
            flex-shrink: 1;
            padding: 0 5px; /* Small padding around text */
        }
        /* Spacing around match titles */
        .channel-box[id^="match-"] .channel-header h3 { margin-left: 5px; margin-right: 5px; flex-grow: 0;} /* Don't let match titles grow excessively */
        /* Center channel title when no logo is present */
        /* .channel-box:not([id^="match-"]) .channel-header h3 { } */ /* No specific rule needed if header is centered */


        /* Channel Info (for Matches) */
        .channel-info {
            font-size: 0.8em; color: var(--text-secondary); text-align: center;
            margin-top: 8px; margin-bottom: 0; font-weight: 500; cursor: pointer;
            display: block; /* Shown by default, hidden via CSS below */
        }
        /* Hide info section for regular channels */
        .channel-box:not([id^="match-"]) .channel-info { display: none; }
        .channel-info span { margin: 0 5px; }

        /* --- Expanded Channel Box --- */
        .channel-box.expanded {
            /* **MODIFIED: Always span full width** */
            grid-column: 1 / -1 !important; /* Span all columns, !important to override grid settings */
            width: 100%; /* Take full width */
            max-width: 1200px; /* Still limit maximum width on very large screens */
            margin: 20px auto; /* Center horizontally with vertical margin */
            position: relative;
            cursor: default; background: var(--bg-tertiary);
            padding-bottom: 20px; z-index: 10; /* Bring to front */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color); overflow: visible; /* Allow potential overflows? */
            display: flex !important; /* Override .hidden if expanded, keep flex for consistency */
            flex-direction: column; /* Ensure content stacks vertically */
        }
        /* Non-clickable header/info when expanded */
        .channel-box.expanded .channel-header,
        .channel-box.expanded .channel-info { cursor: default; }

        /* --- Player Area --- */
        .iframe-container { margin-top: 18px; display: none; width: 100%; }
        .channel-box.expanded .iframe-container { display: block; }
        .player-area {
            position: relative; width: 100%; aspect-ratio: 16 / 9; /* Maintain aspect ratio */
            background-color: #000; border-radius: 8px; overflow: hidden;
            margin-bottom: 18px; min-height: 200px; /* Minimum height */
            display: flex; justify-content: center; align-items: center; /* Center loader/message */
        }
        .player-area iframe, .player-area video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: none; display: none; /* Hidden until active */
            object-fit: contain; /* Ensure video fits without cropping */
        }
        .player-area iframe.active, .player-area video.active { display: block; } /* Show active player */
        /* Message displayed within the player area (errors, info) */
        .player-message {
            color: var(--text-secondary); font-size: 0.9em; padding: 20px;
            text-align: center; display: none; /* Hidden by default */
            max-width: 80%; /* Prevent message being too wide */
        }
        .player-message.visible { display: block; }
        .player-message strong { color: var(--text-primary); display: block; margin-bottom: 5px; font-weight: 600; }
        .player-message span { font-size: 0.9em; display: block; margin-top: 5px; line-height: 1.4; }
        .player-message button { margin-top: 15px; } /* Spacing for Try Next button */
        /* Loading spinner */
        .loader {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid var(--border-color); border-top-color: var(--accent-color);
            animation: spin 1s linear infinite; display: none; /* Hidden by default */
        }
        .loader.visible { display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Adjust player size for larger screens */
        @media (min-width: 768px) { .channel-box.expanded .player-area { min-height: 400px; max-height: 70vh; } }
        @media (min-width: 1024px) { .channel-box.expanded .player-area { min-height: 480px; } }

        /* --- Stream Buttons --- */
        .stream-buttons { text-align: center; margin-top: 15px; margin-bottom: 15px; padding: 0 10px; }
        .stream-buttons div { margin-bottom: 10px; } /* Spacing for language groups */
        .stream-buttons strong { /* Language label (PT:, UK:) */
            color: var(--text-secondary); font-size: 0.85em; margin-right: 8px;
            font-weight: 600; text-transform: uppercase; display: inline-block; /* Keep on same line as first button */
        }
        .stream-button {
            background: var(--bg-secondary); color: var(--text-primary);
            border: 1px solid var(--border-color); padding: 7px 18px; border-radius: 20px;
            cursor: pointer; font-size: 0.85em; font-weight: 500;
            transition: all 0.2s ease; display: inline-block; margin: 4px; /* Spacing between buttons */
            vertical-align: middle; /* Align with label */
        }
        .stream-button:hover { background: #4a4a4a; border-color: #5a5a5a; }
        .stream-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); font-weight: 600; }
        /* "Try Next Source" button styling */
        .try-next-button {
            background: var(--info-color); color: white; border: none;
            padding: 8px 15px; border-radius: 6px; cursor: pointer;
            font-size: 0.85em; font-weight: 500; transition: background-color 0.2s ease;
        }
        .try-next-button:hover { background-color: #2563eb; } /* Darker blue */

        /* --- Disclaimer inside Expanded Box --- */
        .box-disclaimer { font-size: 0.7em; color: #888; text-align: center; padding: 0 15px; margin-top: 10px; line-height: 1.4; display: none; }
        .channel-box.expanded .box-disclaimer { display: block; }

        /* --- Footer --- */
        footer { text-align: center; color: var(--text-secondary); font-size: 0.8em; padding: 20px 0; width: 100%; margin-top: 40px; }
        .footer-disclaimer { font-size: 0.75em; margin-top: 15px; padding: 0 20px; max-width: 800px; margin-left: auto; margin-right: auto; line-height: 1.5; color: #888; }

        /* --- General Loading/Error/Info Messages (outside grids) --- */
        .status-message {
            text-align: center; padding: 30px 20px; /* Reduced padding */
            color: var(--text-secondary); font-size: 1em; font-weight: 500;
            border-radius: 8px; margin: 20px auto; max-width: 600px;
            line-height: 1.5;
        }
        .status-message.loading { background-color: var(--bg-secondary); border: 1px dashed var(--border-color); }
        .status-message.error { background-color: rgba(248, 113, 113, 0.1); border: 1px solid var(--error-color); color: var(--error-color); }
        /* Info message used for empty states within grids */
        .status-message.info { background-color: rgba(59, 130, 246, 0.1); border: 1px solid var(--info-color); color: var(--info-color); }
        .status-message strong { color: var(--text-primary); display: block; margin-bottom: 10px; font-size: 1.1em; }
        .status-message span { display: block; font-size: 0.9em; } /* For sub-text in error messages */


        /* --- Responsive Adjustments --- */
        @media (max-width: 767px) { /* Apply below 768px */
             /* Grids become single column (already default, but ensures override) */
             .channel-grid { grid-template-columns: 1fr; }
             .channel-box { padding: 15px; }
             .stream-button { padding: 6px 15px; font-size: 0.8em; }
             header img { max-width: 160px; }
             .tabs { gap: 10px; margin-bottom: 30px; }
             .tab-button { padding: 8px 15px; font-size: 0.85em; }
             /* Ensure match boxes take full width */
             #Matches .channel-box[id^="match-"]:not(.expanded),
             #ALL .channel-box[id^="match-"]:not(.expanded) { max-width: 100%; }
             /* Adjust match header layout */
             #Matches .channel-header, #ALL .channel-box[id^="match-"] .channel-header { gap: 10px; }
             .match-logo { height: 32px; width: 32px; }
             .channel-info { font-size: 0.75em;}
             .channel-box[id^="match-"] .channel-header h3 { margin: 0 5px; font-size: 1em; } /* Reduce margin/size */
             .favorite-button { top: 8px; right: 8px; }
             .favorite-button svg { width: 18px; height: 18px; }
        }
        @media (max-width: 480px) { /* Apply below 480px */
            .container { padding: 0 10px; }
            header img { max-width: 140px; }
            .tabs { gap: 8px; }
            .tab-button { padding: 7px 12px; }
            .channel-box { padding: 12px; }
            .channel-header h3 { font-size: 1em;}
            .channel-box[id^="match-"] .channel-header h3 { margin: 0 5px;}
            .match-logo { height: 30px; width: 30px; }
            /* Stack language label above buttons */
            .stream-buttons strong { display: block; margin-bottom: 5px; margin-right: 0; text-align: center; }
            .stream-buttons div { text-align: center; } /* Center buttons under label */
            .player-area { min-height: 200px; }
            #search-input { padding: 10px 15px; font-size: 0.95em; }
             .channel-info { font-size: 0.7em;}
             .footer-disclaimer { font-size: 0.7em; }
             .box-disclaimer { font-size: 0.65em; }
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <img src="ptvlogo.png" alt="PERAS TV Logo">
    </header>

    <div class="search-container">
        <input type="search" id="search-input" placeholder="Search channels or matches..." aria-label="Search channels or matches">
    </div>

    <div class="tabs" role="tablist" aria-label="Content Categories">
        <button class="tab-button" data-tab="Favorites" role="tab" aria-controls="Favorites" aria-selected="false" aria-label="Favorites">
             <svg class="tab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                 <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
             </svg>
             </button>
        <button class="tab-button" data-tab="ALL" role="tab" aria-controls="ALL" aria-selected="true">ALL</button> <button class="tab-button" data-tab="PT" role="tab" aria-controls="PT" aria-selected="false">PT</button>
        <button class="tab-button" data-tab="UK" role="tab" aria-controls="UK" aria-selected="false">UK</button>
        <button class="tab-button" data-tab="ES" role="tab" aria-controls="ES" aria-selected="false">ES</button>
        <button class="tab-button" data-tab="Matches" role="tab" aria-controls="Matches" aria-selected="false">Matches</button>
    </div>

    <div id="loadingMessage" class="status-message loading" role="status">Loading channels...</div>
    <div id="fetchErrorMessage" class="status-message error" role="alert" style="display: none;"></div>

    <div id="Favorites" class="channel-grid" role="tabpanel" aria-labelledby="tab-Favorites" tabindex="0"></div>
    <div id="ALL" class="channel-grid" role="tabpanel" aria-labelledby="tab-ALL" tabindex="0"></div>
    <div id="PT" class="channel-grid" role="tabpanel" aria-labelledby="tab-PT" tabindex="0"></div>
    <div id="UK" class="channel-grid" role="tabpanel" aria-labelledby="tab-UK" tabindex="0"></div>
    <div id="ES" class="channel-grid" role="tabpanel" aria-labelledby="tab-ES" tabindex="0"></div>
    <div id="Matches" class="channel-grid" role="tabpanel" aria-labelledby="tab-Matches" tabindex="0"></div>

</div> <footer>
    <p id="lastUpdated">Updated: Fetching time...</p>
    <p class="footer-disclaimer">
        <strong>Disclaimer:</strong> PerasTV does not host any video content. All streams are embedded from external, publicly available sources found on the internet. We are not responsible for the legality, accuracy, or quality of the content provided by these third-party sites. Users are advised to respect copyright laws and use this service responsibly. Stream availability is not guaranteed.
    </p>
</footer>

<script>
    /* --- PerasTV Main Script --- */

    // --- Configuration Constants ---
    const CONFIG = {
        channelsUrl: "channels.json", // URL for channel data
        matchesUrl: "matches.json",   // URL for match data
        // Placeholder image used before HLS stream loads or if logo fails
        placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%231a1a1a"/></svg>',
        searchDebounceMs: 300,      // Delay (ms) for search input before filtering
        lastTabKey: 'perasTvLastTab', // localStorage key for remembering the last active tab
        favoritesKey: 'perasTvFavorites', // localStorage key for storing favorite item IDs
        iframeLoadTimeoutMs: 20000 // Timeout (ms) for waiting for an iframe stream to load
    };

    // --- DOM Element References ---
    // Use descriptive names for clarity
    const searchInputElement = document.getElementById('search-input');
    const tabsContainerElement = document.querySelector('.tabs');
    const channelGridElements = document.querySelectorAll('.channel-grid'); // NodeList of all grid divs
    const lastUpdatedTimestampElement = document.getElementById('lastUpdated');
    const initialLoadingMessageElement = document.getElementById('loadingMessage');
    const dataFetchErrorMessageElement = document.getElementById('fetchErrorMessage');

    // --- Application State ---
    // Use meaningful variable names
    let currentHlsInstance = null;             // Holds the active HLS.js player instance
    let allChannelsData = {};              // Stores fetched channel data (categorized: { PT: [], UK: [], ... })
    let allMatchesData = [];               // Stores fetched match data (Array of match objects)
    let currentlyExpandedBoxElement = null;    // Reference to the currently open channel/match box DIV
    let searchDebounceTimerId = null;     // Timer ID for debouncing search input
    let activeTabId = 'ALL';            // ID ('ALL', 'PT', 'Favorites', etc.) of the currently active tab
    let favoriteItemIds = [];                 // Array to hold favorite item IDs (e.g., 'match-0', 'PT-channel-2')

    // --- Disclaimer Text (used inside expanded boxes) ---
    const BOX_DISCLAIMER_TEXT = `
        Disclaimer: This site embeds content from external sources.
        We do not host streams. Availability and quality not guaranteed. Use responsibly.
    `;

    // --- Initialization ---
    // Wait for the DOM to be fully loaded before running scripts
    document.addEventListener('DOMContentLoaded', () => {
        console.log("PerasTV Initializing...");
        loadFavoritesFromStorage(); // Load favorites from localStorage first
        setupGlobalEventListeners();     // Set up tab clicks, search, keyboard shortcuts
        updateTimestampDisplay();         // Display initial time
        setInterval(updateTimestampDisplay, 60000); // Update time every minute
        fetchAndRenderData();           // Fetch channel/match data and render the UI
    });

    // --- Favorite Management ---

    /**
     * Loads favorite item IDs from localStorage into the `favoriteItemIds` array.
     * Includes basic validation.
     */
    function loadFavoritesFromStorage() {
        const storedFavoritesJson = localStorage.getItem(CONFIG.favoritesKey);
        if (storedFavoritesJson) {
            try {
                const parsedFavorites = JSON.parse(storedFavoritesJson);
                // Validate: Ensure it's an array of strings
                if (Array.isArray(parsedFavorites) && parsedFavorites.every(item => typeof item === 'string')) {
                    favoriteItemIds = parsedFavorites;
                } else {
                    console.warn("Invalid favorites data found in localStorage. Resetting.");
                    favoriteItemIds = [];
                    localStorage.removeItem(CONFIG.favoritesKey); // Clear invalid data
                }
            } catch (error) {
                console.error("Error parsing favorites from localStorage:", error);
                favoriteItemIds = []; // Reset on parsing error
            }
        } else {
            favoriteItemIds = []; // Initialize as empty if nothing is stored
        }
        console.log("Loaded favorites:", favoriteItemIds);
    }

    /**
     * Saves the current `favoriteItemIds` array to localStorage.
     */
    function saveFavoritesToStorage() {
        try {
            localStorage.setItem(CONFIG.favoritesKey, JSON.stringify(favoriteItemIds));
            console.log("Saved favorites:", favoriteItemIds);
        } catch (error) {
            console.error("Error saving favorites to localStorage:", error);
            // Consider notifying the user if storage fails (e.g., quota exceeded)
            // showTemporaryMessage("Could not save favorites.", "error");
        }
    }

    /**
     * Toggles the favorite status of an item (channel or match) based on its unique ID.
     * Updates the UI (star icon) and persists the change to localStorage.
     * @param {string} itemId - The unique ID of the item (e.g., 'match-1', 'UK-channel-0').
     * @param {HTMLButtonElement} starButtonElement - The favorite button element that was clicked.
     */
    function toggleFavoriteStatus(itemId, starButtonElement) {
        if (!itemId || !starButtonElement) {
            console.error("toggleFavoriteStatus called with invalid arguments.");
            return;
        }

        const itemIndex = favoriteItemIds.indexOf(itemId);
        const isCurrentlyFavorite = itemIndex > -1;

        if (isCurrentlyFavorite) {
            // --- Remove from favorites ---
            favoriteItemIds.splice(itemIndex, 1);
            starButtonElement.classList.remove('is-favorite');
            starButtonElement.setAttribute('aria-pressed', 'false');
            starButtonElement.setAttribute('aria-label', 'Add to Favorites');
            console.log(`Item removed from favorites: ${itemId}`);
        } else {
            // --- Add to favorites ---
            favoriteItemIds.push(itemId);
            starButtonElement.classList.add('is-favorite');
            starButtonElement.setAttribute('aria-pressed', 'true');
            starButtonElement.setAttribute('aria-label', 'Remove from Favorites');
            console.log(`Item added to favorites: ${itemId}`);
        }
        saveFavoritesToStorage(); // Persist changes immediately

        // --- Update Visual State on Other Instances ---
        // Find any other box elements with the same ID (e.g., in 'ALL' tab vs 'PT' tab)
        // and update their star icon state to match.
        document.querySelectorAll(`.channel-box#${CSS.escape(itemId)} .favorite-button`).forEach(otherStar => {
            if (otherStar !== starButtonElement) { // Don't update the button that was just clicked
                otherStar.classList.toggle('is-favorite', !isCurrentlyFavorite);
                otherStar.setAttribute('aria-pressed', !isCurrentlyFavorite ? 'true' : 'false');
                otherStar.setAttribute('aria-label', !isCurrentlyFavorite ? 'Remove from Favorites' : 'Add to Favorites');
            }
        });

        // --- Re-render Favorites Tab if Active ---
        // If the user is currently viewing the Favorites tab, update it immediately.
        if (activeTabId === 'Favorites') {
            renderFavoritesTabContent(); // Re-render the content
            addChannelBoxEventListeners(document.getElementById('Favorites')); // Re-attach listeners to new elements
        }
    }


    // --- Event Listener Setup ---

    /**
     * Sets up global event listeners for tabs, search, keyboard interactions, etc.
     */
    function setupGlobalEventListeners() {
        // --- Tab Switching Listener ---
        tabsContainerElement.addEventListener('click', (event) => {
            // Find the clicked tab button using closest() for better reliability
            const tabButton = event.target.closest('.tab-button[data-tab]');
            if (tabButton) {
                const tabIdToShow = tabButton.dataset.tab;
                activateTab(tabIdToShow); // Handle tab activation logic
            }
        });

        // --- Search Input Listener (with Debounce) ---
        searchInputElement.addEventListener('input', (event) => {
            // Clear any existing debounce timer
            clearTimeout(searchDebounceTimerId);
            // Set a new timer to filter content after a short delay
            searchDebounceTimerId = setTimeout(() => {
                filterVisibleContent(event.target.value); // Call the filtering function
            }, CONFIG.searchDebounceMs);
        });

        // --- Global Keydown Listener ---
        document.addEventListener('keydown', (event) => {
            // Close the currently expanded box when the Escape key is pressed
            if (event.key === 'Escape' && currentlyExpandedBoxElement) {
                collapseItemBox(currentlyExpandedBoxElement); // Use the collapse function
            }
            // Potentially add other keyboard shortcuts here (e.g., focus search, navigate tabs)
        });

        // NOTE: Listeners for dynamically created channel/match boxes are added
        // separately in `addChannelBoxEventListeners` after rendering.
    }

    // --- Data Fetching & Initial Rendering ---

    /**
     * Fetches channel and match data from the specified JSON URLs.
     * Handles loading states, errors, and triggers the initial rendering.
     */
    async function fetchAndRenderData() {
        showInitialLoadingMessage("Loading channels and matches...");
        dataFetchErrorMessageElement.style.display = 'none'; // Hide previous errors

        try {
            // Use cache-busting query parameter to ensure fresh data
            const cacheBuster = `?t=${Date.now()}`;
            const channelsUrl = CONFIG.channelsUrl + cacheBuster;
            const matchesUrl = CONFIG.matchesUrl + cacheBuster;

            console.log(`Fetching channels from: ${channelsUrl}`);
            console.log(`Fetching matches from: ${matchesUrl}`);

            // Fetch both data sources concurrently
            const [channelsResponse, matchesResponse] = await Promise.all([
                fetch(channelsUrl),
                fetch(matchesUrl)
            ]);

            // --- Check Response Status ---
            if (!channelsResponse.ok) {
                throw new Error(`Failed to load channels: ${channelsResponse.status} ${channelsResponse.statusText}`);
            }
            if (!matchesResponse.ok) {
                throw new Error(`Failed to load matches: ${matchesResponse.status} ${matchesResponse.statusText}`);
            }

            // --- Parse JSON Data ---
            allChannelsData = await channelsResponse.json();
            allMatchesData = await matchesResponse.json();

            // --- Basic Data Validation ---
            // Ensure channels data is an object and matches data is an array
            if (typeof allChannelsData !== 'object' || allChannelsData === null) {
                throw new Error("Invalid channels data format received (expected an object).");
            }
            if (!Array.isArray(allMatchesData)) {
                throw new Error("Invalid matches data format received (expected an array).");
            }

            console.log("Data fetched successfully:", { channels: allChannelsData, matches: allMatchesData });

            // --- Render UI ---
            renderAllContentGrids(); // Render content into ALL grid containers

            hideInitialLoadingMessage(); // Hide the main loading message

            // --- Restore Last Viewed Tab ---
            // Get the last saved tab ID from localStorage
            const lastSavedTabId = localStorage.getItem(CONFIG.lastTabKey);
            // Get a list of valid tab IDs from the buttons
            const validTabIds = Array.from(tabsContainerElement.querySelectorAll('.tab-button')).map(btn => btn.dataset.tab);
            // Activate the saved tab if it's valid, otherwise default to 'ALL'
            activateTab(validTabIds.includes(lastSavedTabId) ? lastSavedTabId : 'ALL');

        } catch (error) {
            console.error("Data loading failed:", error);
            hideInitialLoadingMessage();
            // Display a user-friendly error message
            showDataFetchErrorMessage(`Error loading data: ${error.message}. Please check the console or try refreshing the page.`);
        }
    }

    // --- Rendering Functions ---

    /**
     * Renders content into all channel grid containers based on fetched data.
     * This is the main function called after successful data fetching.
     */
    function renderAllContentGrids() {
        console.log("Rendering all content grids...");
        // Render channels into their specific category tabs (PT, UK, ES)
        renderSpecificGridContent('PT', allChannelsData.PT || [], 'channel');
        renderSpecificGridContent('UK', allChannelsData.UK || [], 'channel');
        renderSpecificGridContent('ES', allChannelsData.ES || [], 'channel');
        // Render matches into the Matches tab
        renderSpecificGridContent('Matches', allMatchesData || [], 'match');
        // Populate the 'ALL' tab by combining matches and all channel categories
        renderAllTabContent();
        // Populate the 'Favorites' tab based on the `favoriteItemIds` array
        renderFavoritesTabContent();

        // IMPORTANT: Add event listeners to all newly created channel/match boxes
        // across all the grids after they have been added to the DOM.
        addChannelBoxEventListeners();
    }

    /**
     * Renders items (channels or matches) into a specific grid container element.
     * Handles empty states for the specific grid.
     * @param {string} gridId - The ID of the grid element (e.g., 'PT', 'Matches', 'Favorites').
     * @param {Array} items - Array of channel or match data objects.
     * @param {'channel' | 'match'} itemType - The type of item being rendered.
     */
    function renderSpecificGridContent(gridId, items, itemType) {
        const gridElement = document.getElementById(gridId);
        if (!gridElement) {
            console.error(`Grid element not found for rendering: #${gridId}`);
            return;
        }
        gridElement.innerHTML = ''; // Clear any previous content (like old items or empty messages)

        // --- Handle Empty Grid ---
        if (!items || items.length === 0) {
            let emptyMessage = `No ${itemType === 'match' ? 'matches' : 'channels'} currently listed in this section.`;
            // Provide a more helpful message for the empty Favorites tab
            if (gridId === 'Favorites') {
                emptyMessage = 'Your favorites list is empty.<br>Click the star icon ☆ on any channel or match to add it here.';
            }
            // Display the message using the standard status message styling
            gridElement.innerHTML = `<p class="status-message info">${emptyMessage}</p>`;
            return; // Stop execution for this grid
        }

        // --- Render Items ---
        // Create a document fragment for efficient batch appending
        const fragment = document.createDocumentFragment();
        items.forEach((itemData, index) => {
            let itemElement = null;
            // Generate a unique ID for the item. This ID needs to be consistent across renders
            // and ideally reflect the item's origin for reliable favoriting.
            let uniqueItemId;

            if (itemType === 'match') {
                // Find the original index of this match in the global `allMatchesData` array
                const globalMatchIndex = allMatchesData.findIndex(m => m === itemData); // Simple reference check
                uniqueItemId = `match-${globalMatchIndex}`; // e.g., match-0, match-1
                itemElement = createMatchBoxElement(itemData, uniqueItemId);
            } else { // itemType === 'channel'
                // Find the original index within its category in `allChannelsData`
                const category = gridId; // Assuming gridId matches the category key (PT, UK, ES)
                const categoryIndex = allChannelsData[category]?.findIndex(c => c === itemData);
                uniqueItemId = `${category}-channel-${categoryIndex}`; // e.g., PT-channel-0, UK-channel-1
                itemElement = createChannelBoxElement(itemData, uniqueItemId);
            }

            if (itemElement) {
                fragment.appendChild(itemElement); // Add the created box to the fragment
            } else {
                 console.warn(`Failed to create element for item at index ${index} in grid ${gridId}`);
            }
        });

        // Append all created elements to the grid at once
        gridElement.appendChild(fragment);
    }

    /**
     * Populates the 'ALL' tab grid with both matches and channels from all categories.
     */
    function renderAllTabContent() {
        const allGridElement = document.getElementById('ALL');
        if (!allGridElement) {
            console.error("Grid element #ALL not found.");
            return;
        }
        allGridElement.innerHTML = ''; // Clear previous content

        const fragment = document.createDocumentFragment();
        let contentAdded = false;

        // 1. Add Matches First (if any)
        if (allMatchesData && allMatchesData.length > 0) {
            allMatchesData.forEach((match, index) => {
                const uniqueId = `match-${index}`; // Use global index for consistent ID
                const box = createMatchBoxElement(match, uniqueId);
                 if(box) {
                     fragment.appendChild(box);
                     contentAdded = true;
                 }
            });
        }

        // 2. Add Channels from each category (PT, UK, ES)
        ['PT', 'UK', 'ES'].forEach(category => {
            const channelsInCategory = allChannelsData[category] || [];
            if (channelsInCategory.length > 0) {
                 channelsInCategory.forEach((channel, index) => {
                    const uniqueId = `${category}-channel-${index}`; // Use category-specific index
                    const box = createChannelBoxElement(channel, uniqueId);
                     if(box) {
                         fragment.appendChild(box);
                         contentAdded = true;
                     }
                });
            }
        });

        // Append the fragment to the grid
        allGridElement.appendChild(fragment);

         // If no content was added at all, display an empty message
         if (!contentAdded) {
             allGridElement.innerHTML = '<p class="status-message info">No channels or matches are currently available.</p>';
         }
    }

    /**
     * Renders the content of the 'Favorites' tab based on the `favoriteItemIds` array.
     * Retrieves the corresponding data from `allChannelsData` and `allMatchesData`.
     */
    function renderFavoritesTabContent() {
        const favoritesGridElement = document.getElementById('Favorites');
        if (!favoritesGridElement) {
            console.error("Grid element #Favorites not found.");
            return;
        }
        favoritesGridElement.innerHTML = ''; // Clear previous favorites content

        // --- Handle Empty Favorites List ---
        if (favoriteItemIds.length === 0) {
            favoritesGridElement.innerHTML = '<p class="status-message info">Your favorites list is empty.<br>Click the star icon ☆ on any channel or match to add it.</p>';
            return;
        }

        const fragment = document.createDocumentFragment();
        let validFavoritesFound = 0;

        // --- Iterate through stored favorite IDs ---
        favoriteItemIds.forEach(itemId => {
            let itemData = null; // To store the found channel/match object
            let itemElement = null; // To store the created HTML element

            // --- Find the corresponding data based on the ID format ---
            // Check if it's a match ID (e.g., 'match-5')
            if (itemId.startsWith('match-')) {
                const matchIndex = parseInt(itemId.split('-')[1], 10);
                // Check if index is valid within the current matches data
                if (!isNaN(matchIndex) && matchIndex >= 0 && matchIndex < allMatchesData.length) {
                    itemData = allMatchesData[matchIndex];
                    itemElement = createMatchBoxElement(itemData, itemId); // Use the original ID
                }
            }
            // Check if it's a channel ID (e.g., 'PT-channel-0')
            else if (itemId.includes('-channel-')) {
                const parts = itemId.split('-'); // [ 'PT', 'channel', '0' ]
                const category = parts[0];
                const channelIndex = parseInt(parts[parts.length - 1], 10);
                // Check if category exists and index is valid
                if (allChannelsData[category] && !isNaN(channelIndex) && channelIndex >= 0 && channelIndex < allChannelsData[category].length) {
                    itemData = allChannelsData[category][channelIndex];
                     itemElement = createChannelBoxElement(itemData, itemId); // Use the original ID
                }
            }

            // --- Add the element if found ---
            if (itemElement) {
                fragment.appendChild(itemElement);
                validFavoritesFound++;
            } else {
                // This happens if an item was favorited but is no longer present in the source JSON files
                console.warn(`Could not find data for favorite item ID: ${itemId}. It might have been removed from the source data.`);
                // OPTIONAL: Automatically remove such 'orphaned' favorites
                // const indexToRemove = favoriteItemIds.indexOf(itemId);
                // if (indexToRemove > -1) favoriteItemIds.splice(indexToRemove, 1);
                // saveFavoritesToStorage(); // Save if modified
            }
        });

        // Append all found favorite elements to the grid
        favoritesGridElement.appendChild(fragment);

        // --- Handle Case Where All Favorites Were Orphans ---
        if (validFavoritesFound === 0 && favoriteItemIds.length > 0) {
             favoritesGridElement.innerHTML = '<p class="status-message info">Your previously favorited items could not be found.<br>They might have been removed or updated in the source list.</p>';
        }

        // NOTE: Event listeners must be re-added to these new elements by the calling function
        // using addChannelBoxEventListeners(favoritesGridElement);
    }


    // --- Element Creation ---

    /**
     * Creates the HTML element (DIV) for a single channel box.
     * **MODIFIED: Does NOT include channel logos.**
     * @param {object} channelData - Channel data object { name, srcs: [{ label, url }] }. Logo property is ignored.
     * @param {string} uniqueItemId - The unique identifier for this channel box element (e.g., 'PT-channel-0').
     * @returns {HTMLDivElement | null} The created channel box element or null on error.
     */
    function createChannelBoxElement(channelData, uniqueItemId) {
        // Basic validation of input data
        if (!channelData || !uniqueItemId || !channelData.name || !Array.isArray(channelData.srcs)) {
             console.error("Invalid channel data provided for creating element:", { id: uniqueItemId, data: channelData });
             return null; // Return null if data is insufficient
        }
        // Destructure needed properties, ignoring 'logo'
        const { name, srcs } = channelData;

        const boxElement = document.createElement('div');
        boxElement.className = 'channel-box';
        boxElement.id = uniqueItemId;
        // Store essential data directly on the element for easy access later (search, expansion)
        boxElement.dataset.itemName = name; // Use consistent 'itemName' for search
        boxElement.dataset.itemType = 'channel';
        boxElement.dataset.sources = JSON.stringify(srcs); // Store sources JSON string

        const isFavorite = favoriteItemIds.includes(uniqueItemId); // Check if this ID is in the favorites array

        // --- Construct Inner HTML (NO LOGO) ---
        boxElement.innerHTML = `
            <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}"
                    aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites"
                    aria-pressed="${isFavorite}">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true">
                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                </svg>
            </button>
            <div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content">
                <h3>${name}</h3>
            </div>
            <div class="channel-info"></div>
            <div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header">
                <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message" role="alert"></div>
                    <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture"
                            allowfullscreen
                            title="Stream Player"
                            sandbox="allow-scripts allow-same-origin allow-presentation allow-fullscreen"></iframe>
                    <video controls autoplay muted playsinline
                           title="Stream Player"
                           poster="${CONFIG.placeholderImage}"></video>
                </div>
                <div class="stream-buttons">
                    </div>
                <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p>
            </div>
        `;
        return boxElement;
    }

     /**
      * Creates the HTML element (DIV) for a single match box.
      * **MODIFIED: Uses helper that no longer adds background to placeholder spans.**
      * @param {object} matchData - Match data object { team1, team2, logo1?, logo2?, time?, league?, pt:[], uk:[], es:[] }.
      * @param {string} uniqueItemId - The unique identifier for this match box element (e.g., 'match-0').
      * @returns {HTMLDivElement | null} The created match box element or null on error.
      */
     function createMatchBoxElement(matchData, uniqueItemId) {
         // Basic validation
         if (!matchData || !uniqueItemId || !matchData.team1 || !matchData.team2) {
             console.error("Invalid match data provided for creating element:", { id: uniqueItemId, data: matchData });
             return null;
         }
        const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = matchData;

        const boxElement = document.createElement('div');
        boxElement.className = 'channel-box';
        boxElement.id = uniqueItemId;

        // --- Store Data on Element ---
        const matchTitle = `${team1} vs ${team2}`;
        boxElement.dataset.itemName = matchTitle; // Primary display/search name
        // Add additional terms for better searchability
        boxElement.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase();
        boxElement.dataset.itemType = 'match';
        // Group sources by language for structured access
        const allSources = { pt: pt || [], uk: uk || [], es: es || [] };
        boxElement.dataset.sources = JSON.stringify(allSources);

        const isFavorite = favoriteItemIds.includes(uniqueItemId);

        // --- Helper function for Logo HTML (reduces repetition) ---
        const createLogoHtml = (logoUrl, altText) => {
            return logoUrl
                ? `<img src="${logoUrl}" alt="${altText} logo" class="match-logo" onerror="this.style.display='none'; this.onerror=null;">`
                // Provide a styled placeholder span if no logo URL exists (NO background)
                : '<span class="match-logo" aria-label="No logo available" style="display: inline-block; width: 40px;"></span>';
        };

        // --- Construct Inner HTML ---
        boxElement.innerHTML = `
             <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}"
                     aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites"
                     aria-pressed="${isFavorite}">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true">
                     <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                 </svg>
             </button>
            <div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content">
                 ${createLogoHtml(logo1, team1)}
                 <h3>${matchTitle}</h3>
                 ${createLogoHtml(logo2, team2)}
            </div>
            <div class="channel-info">
                ${league ? `<span>${league}</span>` : ''}
                ${league && time ? '<span aria-hidden="true"> | </span>' : ''}
                ${time ? `<span>${time}</span>` : ''}
            </div>
             <div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header">
                 <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message" role="alert"></div>
                    <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture"
                            allowfullscreen
                            title="Stream Player"
                            sandbox="allow-scripts allow-same-origin allow-presentation allow-fullscreen"></iframe>
                    <video controls autoplay muted playsinline
                           title="Stream Player"
                           poster="${CONFIG.placeholderImage}"></video>
                </div>
                <div class="stream-buttons">
                    </div>
                <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p>
            </div>
        `;
        return boxElement;
    }

     /**
      * Creates a single stream source button element with its click handler.
      * @param {string} label - Text label for the button (e.g., 'PM', 'DL', 'Source 1').
      * @param {string} url - The stream URL associated with this button.
      * @param {HTMLDivElement} parentBoxElement - The parent channel/match box element.
      * @returns {HTMLButtonElement} The created button element.
      */
     function createStreamSourceButton(label, url, parentBoxElement) {
        const buttonElement = document.createElement('button');
        buttonElement.className = 'stream-button';
        buttonElement.textContent = label || 'Source'; // Use 'Source' as a fallback label
        buttonElement.dataset.streamUrl = url; // Store URL for easy access

        // --- Add Click Event Listener ---
        buttonElement.onclick = (event) => {
            event.stopPropagation(); // IMPORTANT: Prevent the click from bubbling up and toggling the box expansion
            loadStreamIntoPlayer(buttonElement, url, parentBoxElement); // Call function to load the stream
        };
        return buttonElement;
    }


    // --- Event Listener Setup for Channel Boxes ---

    /**
     * Adds necessary click event listeners (toggle expansion, toggle favorite)
     * to all channel/match box elements within a given scope (or the whole document).
     * Uses a data attribute `data-listener-added` to prevent adding listeners multiple times.
     * @param {HTMLElement} [scopeElement=document] - Optional scope to search within (e.g., a specific grid). Defaults to the entire document.
     */
    function addChannelBoxEventListeners(scopeElement = document) {
         if (!scopeElement) return;

         // Find all channel boxes within the scope that *haven't* had listeners attached yet
         scopeElement.querySelectorAll('.channel-box:not([data-listener-added="true"])').forEach(boxElement => {
            const headerElement = boxElement.querySelector('.channel-header');
            const infoElement = boxElement.querySelector('.channel-info'); // Used by matches
            const favoriteButtonElement = boxElement.querySelector('.favorite-button');
            const boxId = boxElement.id; // Get the unique ID (crucial for favorites)

            // --- Expansion Toggle Handler ---
            // This function handles clicks on the header or info section to expand/collapse the box
            const handleExpansionToggle = (event) => {
                 // IMPORTANT: Ensure the click wasn't on the favorite button itself
                 if (!event.target.closest('.favorite-button')) {
                    toggleItemBoxExpansion(boxElement); // Call the main toggle function
                 }
            };

            // Add listener to the header (present on both channels and matches)
            if (headerElement) {
                headerElement.addEventListener('click', handleExpansionToggle);
            }
            // Add listener to the info section *only if* it's visible (i.e., for matches)
            // This prevents channels from being expandable by clicking the (hidden) info area
            if (infoElement && getComputedStyle(infoElement).display !== 'none') {
                 infoElement.addEventListener('click', handleExpansionToggle);
            }

            // --- Favorite Button Handler ---
            if (favoriteButtonElement && boxId) { // Ensure button and ID exist
                favoriteButtonElement.addEventListener('click', (event) => {
                    event.stopPropagation(); // IMPORTANT: Stop click from bubbling to the header/info toggle handler
                    toggleFavoriteStatus(boxId, favoriteButtonElement); // Call the favorite toggle function
                });
            } else if (!boxId) {
                 console.warn("Could not attach favorite listener: Box ID missing.", boxElement);
            }

            // --- Mark as Processed ---
            // Set a data attribute to prevent adding these listeners again if this function is called multiple times
            boxElement.dataset.listenerAdded = 'true';
        });
    }

    // --- Tab Management ---

    /**
     * Activates the specified tab, updates UI (button styles, grid visibility),
     * collapses any open item box, and saves the active tab to localStorage.
     * @param {string} tabIdToShow - The ID ('ALL', 'PT', 'Favorites', etc.) of the tab to activate.
     */
    function activateTab(tabIdToShow) {
        // Prevent unnecessary actions if the tab is already active
        if (tabIdToShow === activeTabId && document.getElementById(tabIdToShow)?.classList.contains('active')) {
             // console.log(`Tab ${tabIdToShow} is already active.`);
             return;
        }

        console.log(`Activating tab: ${tabIdToShow}`);
        activeTabId = tabIdToShow; // Update the global state

        // --- Update Tab Button Styles and Accessibility Attributes ---
        tabsContainerElement.querySelectorAll('.tab-button').forEach(btn => {
            const isButtonActive = btn.dataset.tab === tabIdToShow;
            btn.classList.toggle('active', isButtonActive); // Add/remove 'active' class
            btn.setAttribute('aria-selected', isButtonActive ? 'true' : 'false'); // Set ARIA selected state
        });

        // --- Update Grid Visibility ---
        channelGridElements.forEach(grid => {
            const isGridActive = grid.id === tabIdToShow;
            grid.classList.toggle('active', isGridActive); // Show the active grid, hide others
            // Set tabindex for keyboard navigation (active grid focusable, others not)
            grid.setAttribute('tabindex', isGridActive ? '0' : '-1');
        });

        // --- Collapse Any Open Box ---
        // Ensure a clean state when switching tabs
        if (currentlyExpandedBoxElement) {
            collapseItemBox(currentlyExpandedBoxElement);
        }

        // --- Persist Last Viewed Tab ---
        localStorage.setItem(CONFIG.lastTabKey, tabIdToShow);

        // --- Special Handling for Favorites Tab ---
        // If switching *to* the Favorites tab, ensure its content is up-to-date
        // (as favorites might have been changed while viewing another tab).
        if (tabIdToShow === 'Favorites') {
            renderFavoritesTabContent(); // Re-render the content
            // Re-attach listeners specifically to the newly rendered elements in the Favorites grid
            addChannelBoxEventListeners(document.getElementById('Favorites'));
        }

        // --- Re-apply Search Filter ---
        // Ensure the current search term (if any) is applied to the newly visible content
        filterVisibleContent(searchInputElement.value);

        // Optionally focus the active grid for keyboard navigation, with a slight delay
        // setTimeout(() => { document.getElementById(tabIdToShow)?.focus(); }, 50);
    }

    // --- Search Filtering ---

    /**
     * Filters the visible channel/match boxes based on the search term.
     * Hides boxes that don't match and shows a "No results" message if applicable.
     * Considers the currently active tab.
     * @param {string} searchTerm - The term entered in the search input.
     */
    function filterVisibleContent(searchTerm) {
        const normalizedSearchTerm = searchTerm.toLowerCase().trim();
        const isSearching = normalizedSearchTerm !== '';
        console.log(`Filtering content for term: "${normalizedSearchTerm}" on tab: ${activeTabId}`);

        let resultsFoundInActiveTab = false;
        const activeGridElement = document.getElementById(activeTabId);

        // Iterate through ALL channel/match boxes present in the DOM
        document.querySelectorAll('.channel-box').forEach(boxElement => {
            const parentGridId = boxElement.closest('.channel-grid')?.id;
            if (!parentGridId) return; // Should not happen, but safety check

            // Get search data from the element's datasets
            const itemName = boxElement.dataset.itemName?.toLowerCase() || '';
            const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || ''; // For matches

            // --- Determine if the box matches the search term ---
            const matchesSearch = itemName.includes(normalizedSearchTerm) || additionalSearchTerms.includes(normalizedSearchTerm);

            let shouldBeVisible = false;

            // --- Visibility Logic ---
            if (!isSearching) {
                // If search is empty, visibility depends *only* on whether the box is in the currently active tab.
                shouldBeVisible = (parentGridId === activeTabId);
            } else {
                // If searching, visibility depends on BOTH matching the search term AND being relevant to the active tab.
                if (parentGridId === activeTabId) {
                    // If the box is naturally in the active tab, it just needs to match the search.
                    shouldBeVisible = matchesSearch;
                } else if (activeTabId === 'ALL') {
                     // If on the 'ALL' tab, any box matching the search should be visible.
                     shouldBeVisible = matchesSearch;
                } else if (activeTabId === 'Favorites') {
                     // If on the 'Favorites' tab, the box must match the search AND be in the favorites list.
                     shouldBeVisible = matchesSearch && favoriteItemIds.includes(boxElement.id);
                }
                // Boxes in other non-active, non-ALL, non-Favorites tabs remain hidden during search.
            }

            // --- Apply Visibility ---
            // Toggle the 'hidden' class unless the box is currently expanded (don't hide expanded boxes via filter)
            if (!boxElement.classList.contains('expanded')) {
                boxElement.classList.toggle('hidden', !shouldBeVisible);
            } else {
                 // Ensure expanded boxes are never hidden by the filter, even if they don't match
                 boxElement.classList.remove('hidden');
            }

            // Track if any results were found *within the currently active grid*
            if (shouldBeVisible && parentGridId === activeTabId) {
                resultsFoundInActiveTab = true;
            }

            // --- Collapse Logic (Optional but recommended) ---
            // If a box is expanded but should *not* be visible according to the filter rules
            // (e.g., search term changed, or tab switched), collapse it.
            if (boxElement.classList.contains('expanded') && !shouldBeVisible) {
                 // collapseItemBox(boxElement); // Decide if auto-collapsing is desired UX
            }
        });

        // --- Show/Hide "No Results" Message for the Active Grid ---
        if (activeGridElement) {
             // Find or create the message element within the active grid
             let noResultsMessageElement = activeGridElement.querySelector('.status-message.info.no-results');
             if (!noResultsMessageElement) {
                 noResultsMessageElement = document.createElement('p');
                 noResultsMessageElement.className = 'status-message info no-results'; // Add specific class
                 noResultsMessageElement.style.display = 'none'; // Start hidden
                 // Prepend it so it appears above any remaining items if needed
                 activeGridElement.prepend(noResultsMessageElement);
             }

             // Show message only if searching AND no results were found in the *active* tab
             if (isSearching && !resultsFoundInActiveTab) {
                 noResultsMessageElement.innerHTML = `No results found for "<strong>${searchTerm}</strong>" in this section.`;
                 noResultsMessageElement.style.display = 'block';
             } else {
                 // Hide the message if not searching or if results were found
                 noResultsMessageElement.style.display = 'none';
             }
        }
    }


    // --- Channel Box Expansion ---

    /**
     * Toggles the expanded/collapsed state of a channel/match box element.
     * Manages the `currentlyExpandedBoxElement` state.
     * @param {HTMLDivElement} boxElement - The box element to expand or collapse.
     */
    function toggleItemBoxExpansion(boxElement) {
        if (!boxElement) return;

        const isCurrentlyExpanded = boxElement.classList.contains('expanded');
        const headerElement = boxElement.querySelector('.channel-header');

        // --- Collapse Other Box If Expanding New One ---
        // If we are about to expand this box, and another box is already expanded, collapse the other one first.
        if (!isCurrentlyExpanded && currentlyExpandedBoxElement && currentlyExpandedBoxElement !== boxElement) {
            collapseItemBox(currentlyExpandedBoxElement);
        }

        // --- Perform Expand or Collapse ---
        if (!isCurrentlyExpanded) {
            // Expand the clicked box
            expandItemBox(boxElement);
            if (headerElement) headerElement.setAttribute('aria-expanded', 'true');
        } else {
            // Collapse the clicked box
            collapseItemBox(boxElement);
             if (headerElement) headerElement.setAttribute('aria-expanded', 'false');
        }
    }

    /**
     * Expands a specific channel/match box, populates its streams, and scrolls it into view.
     * @param {HTMLDivElement} boxElement - The box element to expand.
     */
    function expandItemBox(boxElement) {
        boxElement.classList.add('expanded');
        boxElement.classList.remove('hidden'); // Ensure it's visible regardless of filters
        currentlyExpandedBoxElement = boxElement; // Update global tracker

        populateStreamsAndLoadFirst(boxElement); // Load stream buttons and attempt to play

        // --- Smooth Scroll into View ---
        // Use a short timeout to allow the browser to render the expanded state before scrolling
        setTimeout(() => {
             boxElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); // Scroll gently
             // --- Focus Management (Accessibility) ---
             // Optionally focus the first stream button for better keyboard navigation
             const firstStreamButton = boxElement.querySelector('.stream-button');
             if (firstStreamButton) {
                 // Delay focus slightly more to ensure visibility after scroll animation
                 setTimeout(() => firstStreamButton.focus({ preventScroll: true }), 150);
             } else {
                 // If no stream buttons, focus the container itself? Or the header?
                 // boxElement.querySelector('.iframe-container')?.focus(); // Requires tabindex="-1"
             }
        }, 100); // Adjust delay as needed
    }

    /**
     * Collapses a specific channel/match box and cleans up its player state.
     * @param {HTMLDivElement} boxElement - The box element to collapse.
     */
    function collapseItemBox(boxElement) {
        boxElement.classList.remove('expanded');

        // If this was the globally tracked expanded box, clear the tracker
        if (currentlyExpandedBoxElement === boxElement) {
            currentlyExpandedBoxElement = null;
        }

        // --- Clean Up Player and Buttons ---
        clearPlayerStateInBox(boxElement); // Stop video/HLS, clear iframe src
        const streamButtonsContainer = boxElement.querySelector('.stream-buttons');
        if (streamButtonsContainer) streamButtonsContainer.innerHTML = ''; // Remove stream buttons

        // Update accessibility attribute on the header
        const headerElement = boxElement.querySelector('.channel-header');
        if(headerElement) headerElement.setAttribute('aria-expanded', 'false');

        // --- Re-apply Filter ---
        // If the search input is currently empty, re-applying the filter might hide
        // the box again if it doesn't belong to the active tab.
        if (searchInputElement.value === '') {
            filterVisibleContent('');
        }
    }

    /**
     * Populates the stream buttons container within an expanded box based on its stored sources data.
     * Attempts to automatically load the first available stream.
     * @param {HTMLDivElement} boxElement - The expanded box element.
     */
    function populateStreamsAndLoadFirst(boxElement) {
        const sourcesJson = boxElement.dataset.sources;
        const streamButtonsContainer = boxElement.querySelector('.stream-buttons');
        const playerAreaElement = boxElement.querySelector('.player-area'); // Needed for 'no streams' message

        if (!sourcesJson || !streamButtonsContainer || !playerAreaElement) {
             console.error("Missing sources data, button container, or player area for box:", boxElement.id);
             displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); // Show message
             return;
        }

        streamButtonsContainer.innerHTML = ''; // Clear any existing buttons
        let firstStreamUrl = null;
        let firstStreamButtonElement = null;
        let streamCount = 0;
        const fragment = document.createDocumentFragment(); // Use fragment for efficiency

        try {
            const sourcesData = JSON.parse(sourcesJson);

            // --- Determine Source Structure (Channel Array vs Match Object) ---
            if (Array.isArray(sourcesData)) {
                // --- Handle Channel Sources (Simple Array) ---
                sourcesData.forEach((src) => {
                    // Handle both {label, url} objects and simple string URLs
                    const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null);
                    const label = typeof src === 'object' && src.label ? src.label : `Source ${streamCount + 1}`;

                    if (url) { // Only process if a valid URL exists
                         if (!firstStreamUrl) firstStreamUrl = url; // Capture the first URL found
                         const button = createStreamSourceButton(label, url, boxElement);
                         if (!firstStreamButtonElement) firstStreamButtonElement = button; // Capture the first button element
                         fragment.appendChild(button);
                         streamCount++;
                    } else {
                        console.warn("Skipping invalid channel source entry:", src, "in box:", boxElement.id);
                    }
                });

            } else if (typeof sourcesData === 'object' && sourcesData !== null) {
                // --- Handle Match Sources (Object grouped by language: {pt: [], uk: [], es: []}) ---
                Object.entries(sourcesData).forEach(([langKey, sourcesInLang]) => {
                    // Check if the language category has a non-empty array of sources
                    if (sourcesInLang && Array.isArray(sourcesInLang) && sourcesInLang.length > 0) {
                        // Create a container div for this language group
                        const langGroupDiv = document.createElement('div');
                        const langLabel = document.createElement('strong');
                        langLabel.textContent = `${langKey.toUpperCase()}:`; // e.g., PT:
                        langGroupDiv.appendChild(langLabel);

                        sourcesInLang.forEach((src) => {
                            const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null);
                            const label = typeof src === 'object' && src.label ? src.label : `Src ${streamCount + 1}`; // Use label or generic

                             if (url) {
                                 if (!firstStreamUrl) firstStreamUrl = url; // Capture first URL overall
                                 const button = createStreamSourceButton(label, url, boxElement);
                                 if (!firstStreamButtonElement) firstStreamButtonElement = button; // Capture first button overall
                                 langGroupDiv.appendChild(button); // Add button to the language group
                                 streamCount++;
                            } else {
                                console.warn("Skipping invalid match source entry:", src, "in lang:", langKey, "box:", boxElement.id);
                            }
                        });
                        fragment.appendChild(langGroupDiv); // Add the whole language group to the fragment
                    }
                });
            }

            // --- Append Buttons and Load First Stream ---
            streamButtonsContainer.appendChild(fragment); // Add all buttons to the DOM

            if (streamCount === 0) {
                // If no valid streams were found after parsing
                displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer);
                clearPlayerStateInBox(boxElement); // Ensure player is cleared
            } else if (firstStreamUrl && firstStreamButtonElement) {
                // If streams were found, try loading the first one
                 loadStreamIntoPlayer(firstStreamButtonElement, firstStreamUrl, boxElement);
            } else {
                // Fallback: Should not happen if streamCount > 0, but handle defensively
                 console.error("Inconsistency: Streams counted, but no first URL/Button element found.", boxElement.id);
                 displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer);
                 clearPlayerStateInBox(boxElement);
            }

        } catch (error) {
            console.error("Failed to parse sources data or create buttons for box:", boxElement.id, error);
            streamButtonsContainer.innerHTML = '<p class="status-message error" style="padding: 10px;">Error loading stream sources.</p>';
             clearPlayerStateInBox(boxElement); // Clear player on error
        }
    }

    /**
     * Displays a "No streams available" message in the player area and buttons container.
     * @param {HTMLDivElement} playerAreaElement - The player area element.
     * @param {HTMLDivElement} streamButtonsContainer - The stream buttons container element.
     */
     function displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer) {
         const message = 'No stream sources listed for this item.';
         if (streamButtonsContainer) {
            // Display simple text in the buttons area
            streamButtonsContainer.innerHTML = `<p style="color: var(--text-secondary); font-size: 0.9em; padding: 10px 0;">${message}</p>`;
         }
         if (playerAreaElement) {
             // Display a more prominent message in the player area itself
             displayMessageInPlayerArea(playerAreaElement, `<strong>No Streams Available</strong><span>${message}</span>`, false);
         }
    }


    // --- Stream Handling ---

    /**
     * Loads the selected stream URL into the appropriate player (HLS or iframe).
     * Handles UI updates (loader, button states, messages).
     * @param {HTMLButtonElement | null} clickedButtonElement - The button that was clicked (null if called programmatically for the first stream).
     * @param {string} streamUrl - The URL of the stream to load.
     * @param {HTMLDivElement} parentBoxElement - The parent channel/match box element.
     */
    function loadStreamIntoPlayer(clickedButtonElement, streamUrl, parentBoxElement) {
        // --- Validate Inputs ---
        if (!parentBoxElement || !streamUrl || typeof streamUrl !== 'string') {
            console.error("loadStreamIntoPlayer called with invalid parameters:", { streamUrl, parentBoxElement });
            return;
        }

        console.log(`Attempting to load stream in box ${parentBoxElement.id}: ${streamUrl}`);
        const playerAreaElement = parentBoxElement.querySelector('.player-area');
        const loaderElement = playerAreaElement?.querySelector('.loader');
        const messageContainerElement = playerAreaElement?.querySelector('.player-message');

        if (!playerAreaElement || !loaderElement || !messageContainerElement) {
            console.error("Player area elements (area, loader, message) not found in box:", parentBoxElement.id);
            return;
        }

        // --- Prepare UI for Loading ---
        clearPlayerStateInBox(parentBoxElement); // Crucial: Stop previous stream, clear HLS/iframe
        messageContainerElement.classList.remove('visible'); // Hide previous messages
        loaderElement.classList.add('visible');       // Show loading spinner

        // --- Update Button Styles ---
        const streamButtonsContainer = parentBoxElement.querySelector('.stream-buttons');
        if (streamButtonsContainer) {
             // Remove 'active' class from all buttons within this box
             streamButtonsContainer.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
        // Add 'active' class to the clicked button (if one was provided)
        if (clickedButtonElement) {
            clickedButtonElement.classList.add('active');
        }

        // --- Get Player Elements ---
        const iframeElement = playerAreaElement.querySelector('iframe');
        const videoElement = playerAreaElement.querySelector('video');

        if (!iframeElement || !videoElement) {
            console.error("Could not find player elements (iframe/video) in box:", parentBoxElement.id);
            loaderElement.classList.remove('visible');
            displayMessageInPlayerArea(playerAreaElement, `<strong>Internal Error</strong><span>Player elements missing.</span>`, false);
            return;
        }

        // --- Basic URL Format Check ---
        if (!streamUrl.startsWith('http://') && !streamUrl.startsWith('https://')) {
            console.error("Invalid stream URL protocol:", streamUrl);
            loaderElement.classList.remove('visible');
            displayMessageInPlayerArea(playerAreaElement, `<strong>Invalid URL</strong><span>Stream link must start with http or https.</span>`, true, streamUrl, parentBoxElement);
            return;
        }

        // --- Determine Stream Type and Load ---
        try {
            // Use URL API for robust path checking, handles potential query params/hashes
            const urlObject = new URL(streamUrl);
            if (urlObject.pathname.toLowerCase().endsWith('.m3u8')) {
                 console.log("Detected HLS stream (.m3u8).");
                loadHlsStreamIntoVideo(streamUrl, videoElement, playerAreaElement);
            } else {
                 console.log("Detected standard stream (loading in iframe).");
                loadUrlIntoIframe(streamUrl, iframeElement, playerAreaElement);
            }
        } catch (error) {
            // Catch errors from `new URL(streamUrl)` if the URL is fundamentally malformed
            console.error("Error processing stream URL:", error);
            loaderElement.classList.remove('visible');
            displayMessageInPlayerArea(playerAreaElement, `<strong>URL Error</strong><span>Could not process the stream link.</span>`, true, streamUrl, parentBoxElement);
        }
    }

     /**
      * Clears the state of the player within a specific box.
      * Stops HLS playback, destroys the instance, clears video/iframe sources,
      * hides player elements, and resets UI indicators (loader, message).
      * @param {HTMLDivElement} boxElement - The channel/match box element containing the player.
      */
     function clearPlayerStateInBox(boxElement) {
        if (!boxElement) return;
        const playerAreaElement = boxElement.querySelector('.player-area');
        if (!playerAreaElement) return; // Nothing to clear if player area doesn't exist

        const videoElement = playerAreaElement.querySelector('video');
        const iframeElement = playerAreaElement.querySelector('iframe');
        const loaderElement = playerAreaElement.querySelector('.loader');
        const messageContainerElement = playerAreaElement.querySelector('.player-message');

        // --- Stop and Destroy HLS Instance (if it belongs to this video element) ---
        if (currentHlsInstance && videoElement && currentHlsInstance.media === videoElement) {
            console.log(`Destroying active HLS instance for box: ${boxElement.id}`);
            currentHlsInstance.destroy();
            currentHlsInstance = null; // Clear the global reference
        }

        // --- Reset Iframe ---
        if (iframeElement) {
             iframeElement.src = 'about:blank'; // Clear the source to stop loading/playback
             iframeElement.classList.remove('active'); // Hide the iframe
        }

        // --- Reset Video Element ---
        if (videoElement) {
             // Replacing the node is often the most reliable way to fully reset state and listeners
             // const newVideo = videoElement.cloneNode(true);
             // videoElement.parentNode?.replaceChild(newVideo, videoElement);
             // videoElement = newVideo; // Work with the new node from now on if needed

             // Simpler approach: Pause, remove src, load() to reset
             videoElement.pause();
             videoElement.removeAttribute('src'); // Remove HLS or native source
             videoElement.load(); // Request browser to reset internal state
             videoElement.classList.remove('active'); // Hide the video element
             videoElement.poster = CONFIG.placeholderImage; // Reset poster image
        }

        // --- Reset UI Indicators ---
        if (loaderElement) loaderElement.classList.remove('visible');
        if (messageContainerElement) messageContainerElement.classList.remove('visible');

        // --- Deactivate Stream Buttons (Visual Cue) ---
        // Although buttons are removed on collapse, clear active state here too for robustness
        const streamButtonsContainer = boxElement.querySelector('.stream-buttons');
        if (streamButtonsContainer) {
            streamButtonsContainer.querySelectorAll('.stream-button.active').forEach(b => b.classList.remove('active'));
        }
        console.log(`Player state cleared for box: ${boxElement.id}`);
    }

    /**
     * Displays a message (error, info) within the player area overlay.
     * Automatically handles hiding player elements and the loader.
     * @param {HTMLDivElement} playerAreaElement - The player area element.
     * @param {string} messageHtml - The HTML content for the message (use `<strong>` and `<span>` for structure).
     * @param {boolean} showTryNextButton - Whether to display the 'Try Next Source' button.
     * @param {string} [failedUrl=null] - The URL that failed (required if `showTryNextButton` is true).
     * @param {HTMLDivElement} [parentBoxElement=null] - The parent box (required if `showTryNextButton` is true).
     */
    function displayMessageInPlayerArea(playerAreaElement, messageHtml, showTryNextButton, failedUrl = null, parentBoxElement = null) {
        const messageContainerElement = playerAreaElement?.querySelector('.player-message');
        const loaderElement = playerAreaElement?.querySelector('.loader');
        const videoElement = playerAreaElement?.querySelector('video');
        const iframeElement = playerAreaElement?.querySelector('iframe');

        // Ensure essential elements exist
        if (!messageContainerElement || !loaderElement || !playerAreaElement) {
             console.error("Cannot display player message - essential elements missing.");
             return;
        }

        // --- Hide Player & Loader ---
        if (videoElement) videoElement.classList.remove('active');
        if (iframeElement) iframeElement.classList.remove('active');
        loaderElement.classList.remove('visible');

        // --- Set Message Content ---
        messageContainerElement.innerHTML = messageHtml; // Set the main message text/HTML

        // --- Add "Try Next" Button (if applicable) ---
        if (showTryNextButton && failedUrl && parentBoxElement) {
            // Find the *next* button element in the DOM after the failed one
            const nextButtonElement = findNextAvailableStreamButton(failedUrl, parentBoxElement);

            if (nextButtonElement) { // Check if a next button was actually found
                const tryNextBtn = document.createElement('button');
                tryNextBtn.className = 'try-next-button';
                tryNextBtn.textContent = 'Try Next Source';
                // Add click listener to simulate clicking the next button
                tryNextBtn.onclick = (event) => {
                    event.stopPropagation(); // Prevent bubbling
                    nextButtonElement.click(); // Trigger the click handler of the next button
                };
                // Append the button below the message text
                messageContainerElement.appendChild(document.createElement('br')); // Add space
                messageContainerElement.appendChild(tryNextBtn);
            } else {
                // Optionally, indicate that there are no more sources to try
                const noMoreSourcesSpan = document.createElement('span');
                noMoreSourcesSpan.style.fontSize = '0.8em';
                noMoreSourcesSpan.style.marginTop = '10px';
                noMoreSourcesSpan.style.display = 'block';
                noMoreSourcesSpan.textContent = '(No more sources available)';
                messageContainerElement.appendChild(noMoreSourcesSpan);
            }
        }

        // --- Make the Message Visible ---
        messageContainerElement.classList.add('visible');
    }

    /**
     * Finds the next stream button element in the DOM following the one associated with the failed URL.
     * @param {string} failedUrl - The URL of the stream source that failed.
     * @param {HTMLDivElement} parentBoxElement - The parent channel/match box containing the buttons.
     * @returns {HTMLButtonElement | null} The next button element, or null if none is found after the failed one.
     */
    function findNextAvailableStreamButton(failedUrl, parentBoxElement) {
        if (!failedUrl || !parentBoxElement) return null;

        // Get all stream buttons within this specific box, in the order they appear in the DOM
        const allButtonsInBox = parentBoxElement.querySelectorAll('.stream-button');
        let foundFailedButton = false;

        for (let i = 0; i < allButtonsInBox.length; i++) {
            const currentButton = allButtonsInBox[i];
            // Check if this button corresponds to the URL that failed
            if (currentButton.dataset.streamUrl === failedUrl) {
                foundFailedButton = true;
            }
            // If we have already found the failed button, the *current* button in the loop is the next one
            else if (foundFailedButton) {
                return currentButton; // Return the next button element immediately
            }
        }

        // If the loop finishes without finding a button *after* the failed one (or the failed one wasn't found)
        return null;
    }

    /**
     * Loads an HLS (.m3u8) stream into a video element using HLS.js or native browser support.
     * Handles HLS.js instance management, event listeners, and error reporting.
     * @param {string} hlsUrl - The HLS stream URL (.m3u8).
     * @param {HTMLVideoElement} videoElement - The <video> element to attach the stream to.
     * @param {HTMLDivElement} playerAreaElement - The containing player area element for UI updates.
     */
     function loadHlsStreamIntoVideo(hlsUrl, videoElement, playerAreaElement) {
        const parentBoxElement = videoElement.closest('.channel-box'); // Get parent box for context
        videoElement.poster = CONFIG.placeholderImage; // Show placeholder image initially

        // --- Use HLS.js if supported by the browser ---
        if (Hls.isSupported()) {
            console.log("HLS.js is supported. Initializing new instance...");

            // --- HLS Instance Management ---
            // Destroy any previous HLS instance *if* it was attached to this specific video element.
            // This prevents issues if multiple boxes are expanded/streams loaded quickly.
             if (currentHlsInstance && currentHlsInstance.media === videoElement) {
                 console.log(`Destroying existing HLS.js instance for video in box: ${parentBoxElement?.id}`);
                 currentHlsInstance.destroy();
             }
             // Create a new HLS instance regardless. The global `currentHlsInstance` will point to this new one.
            currentHlsInstance = new Hls({
                // --- HLS.js Configuration Options ---
                // More robust timeout settings
                manifestLoadingTimeOut: 15000, // 15 seconds for manifest
                levelLoadingTimeOut: 15000,    // 15 seconds for level playlists
                fragLoadingTimeOut: 20000,     // 20 seconds for fragments
                // Retry settings (adjust based on stream reliability)
                manifestLoadErrorMaxRetry: 2, // Retry manifest load twice on error
                levelLoadErrorMaxRetry: 3,    // Retry level load 3 times
                fragLoadErrorMaxRetry: 4,     // Retry fragment load 4 times (might help with temporary network issues)
                // Start closer to the live edge (adjust `liveSyncDurationCount` based on segment duration)
                liveSyncDurationCount: 3, // Try starting 3 segments from the edge
                // Other potentially useful options (use with caution)
                // enableSoftwareAES: true, // Can help with some encrypted streams, might increase CPU load
                // lowLatencyMode: true, // Experimental, might break some streams
            });

            // --- HLS.js Event Listeners ---

            // --- Error Handling ---
            currentHlsInstance.on(Hls.Events.ERROR, function (event, data) {
                 // IMPORTANT: Check if this error belongs to the *currently active* HLS instance and video element.
                 // This prevents handling errors from old/destroyed instances.
                 if (!currentHlsInstance || currentHlsInstance.media !== videoElement) {
                     console.log("Ignoring HLS error from an old/inactive instance.");
                     return;
                 }

                console.error('HLS.js Error:', { event, type: data.type, details: data.details, fatal: data.fatal });
                let userMessage = `<strong>Stream Error</strong> (${data.details || 'Unknown HLS error'}).`; // Default

                // Provide more specific user messages
                switch (data.type) {
                    case Hls.ErrorTypes.NETWORK_ERROR:
                        userMessage = `<strong>Network Error</strong> (${data.details}). Check connection or try another source.`;
                        break;
                    case Hls.ErrorTypes.MEDIA_ERROR:
                         // Handle specific media errors differently if needed
                         if (data.details === 'bufferStalledError' && !data.fatal) {
                             console.warn("HLS buffer stalled (non-fatal), attempting recovery...");
                             // HLS.js often recovers; maybe show a subtle buffering indicator?
                             return; // Don't treat recoverable stall as a fatal error immediately
                         }
                         userMessage = `<strong>Media Playback Error</strong> (${data.details}). Stream data might be invalid.`;
                        break;
                    // Add cases for MUX_ERROR, OTHER_ERROR if specific handling is needed
                }

                 // If the error is marked as fatal by HLS.js:
                 if (data.fatal) {
                    console.error("Fatal HLS error occurred. Cleaning up.");
                    displayMessageInPlayerArea(playerAreaElement, userMessage, true, hlsUrl, parentBoxElement);
                    currentHlsInstance.destroy(); // Destroy the failed instance
                    currentHlsInstance = null;
                    videoElement.classList.remove('active'); // Hide the video element
                    videoElement.poster = ''; // Remove poster on error
                 } else {
                     console.warn("Non-fatal HLS error occurred:", data.details);
                     // Log non-fatal errors but usually allow HLS.js to attempt recovery.
                 }
            });

            // --- Manifest Parsed ---
            // Fired when the main playlist is loaded and parsed successfully.
            currentHlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                 if (currentHlsInstance && currentHlsInstance.media === videoElement) {
                    console.log("HLS Manifest parsed successfully.");
                    playerAreaElement.querySelector('.loader').classList.remove('visible'); // Hide loader
                    videoElement.classList.add('active'); // Show video element
                    videoElement.muted = true; // Ensure muted for autoplay policies
                    // Attempt to play the video
                    videoElement.play().then(() => {
                         console.log("HLS playback initiated via play().");
                    }).catch(error => {
                         console.error("HLS videoElement.play() failed:", error);
                         // Handle browsers blocking autoplay
                         if (error.name === 'NotAllowedError') {
                             displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Paused</strong><span>Click the play button in the video player to start.</span>`, false);
                             // Don't destroy HLS here; user needs to interact.
                         } else {
                             // Handle other unexpected playback errors
                             displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>Could not start video (${error.name}).</span>`, true, hlsUrl, parentBoxElement);
                             videoElement.classList.remove('active'); // Hide video on fatal play error
                         }
                         playerAreaElement.querySelector('.loader').classList.remove('visible'); // Ensure loader is hidden on error too
                    });
                 }
            });

            // --- Attach Media and Load Source ---
            currentHlsInstance.attachMedia(videoElement); // Link HLS.js to the video element
            // Load the HLS source URL *after* attaching media and setting up listeners
            currentHlsInstance.loadSource(hlsUrl);

        // --- Use Native HLS Support (iOS/Safari) ---
        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            console.log("Using native browser HLS support.");
            // Native HLS works by setting the video element's `src` attribute.

            // It's often best practice to replace the video node to ensure a clean state,
            // especially when switching sources frequently.
            const newVideoElement = videoElement.cloneNode(true); // Create a fresh clone
            videoElement.parentNode?.replaceChild(newVideoElement, videoElement); // Replace the old node
            videoElement = newVideoElement; // Update our reference to the new node

            // --- Native HLS Event Listeners (on the new node) ---
            videoElement.onloadedmetadata = () => {
                // Check if the source is still the one we intended (important due to async nature)
                if (videoElement.getAttribute('src') === hlsUrl) {
                    console.log("Native HLS metadata loaded.");
                    playerAreaElement.querySelector('.loader').classList.remove('visible');
                    videoElement.classList.add('active');
                    videoElement.muted = true; // Mute for autoplay
                    // Attempt to play
                    videoElement.play().then(() => {
                         console.log("Native HLS playback initiated via play().");
                    }).catch(error => {
                        console.error("Native HLS videoElement.play() failed:", error);
                        if (error.name === 'NotAllowedError') {
                            displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Paused</strong><span>Click the play button to start.</span>`, false);
                        } else {
                            displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>Native HLS failed (${error.name}).</span>`, true, hlsUrl, parentBoxElement);
                            videoElement.classList.remove('active');
                        }
                        playerAreaElement.querySelector('.loader').classList.remove('visible');
                    });
                }
            };

            videoElement.onerror = () => {
                 // Check if the error corresponds to the URL we tried to load
                 if (videoElement.getAttribute('src') === hlsUrl) {
                     console.error("Native HLS playback error occurred.");
                     const error = videoElement.error; // Get details from the video element's error object
                     const errorMessage = error ? (error.message || `code ${error.code}`) : 'Unknown error';
                     displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>Native HLS failed: ${errorMessage}.</span>`, true, hlsUrl, parentBoxElement);
                     videoElement.classList.remove('active');
                     videoElement.poster = ''; // Clear poster on error
                     playerAreaElement.querySelector('.loader').classList.remove('visible');
                 } else {
                      console.log("Ignoring native HLS error for a different src."); // Error might be from a previous source attempt
                 }
            };

            // --- Set Source and Load ---
            videoElement.src = hlsUrl; // Set the HLS URL as the source
            videoElement.load(); // Explicitly call load() to trigger loading the new source

        // --- HLS Not Supported At All ---
        } else {
            console.error("HLS playback is not supported by this browser (neither HLS.js nor native).");
            displayMessageInPlayerArea(playerAreaElement, `<strong>Unsupported Stream</strong><span>Your browser cannot play HLS (.m3u8) streams.</span>`, false);
            videoElement.classList.remove('active');
            videoElement.poster = '';
            playerAreaElement.querySelector('.loader').classList.remove('visible');
        }
    }

    /**
     * Loads a non-HLS URL into an iframe element.
     * Includes timeout handling for cases where the iframe might be blocked or unresponsive.
     * @param {string} iframeUrl - The URL to load in the iframe.
     * @param {HTMLIFrameElement} iframeElement - The <iframe> element.
     * @param {HTMLDivElement} playerAreaElement - The containing player area element for UI updates.
     */
    function loadUrlIntoIframe(iframeUrl, iframeElement, playerAreaElement) {
        const parentBoxElement = iframeElement.closest('.channel-box'); // For context in messages
        console.log("Loading iframe stream...");
        let iframeLoadTimeoutId = null; // Variable to hold the timeout ID

        // --- Cleanup Function (called on success, error, or timeout) ---
        const cleanupIframeLoad = () => {
            clearTimeout(iframeLoadTimeoutId); // Clear the timeout timer
            // Remove temporary listeners to prevent memory leaks if needed,
            // though 'onload' and 'onerror' on the element itself are usually fine.
        };

        // --- Failure Handler (called on error or timeout) ---
        const handleIframeLoadFailure = (reason) => {
            cleanupIframeLoad(); // Clear timeout
            // Check if the failure is still relevant (i.e., the src wasn't changed again quickly)
             if (iframeElement.getAttribute('src') === iframeUrl || iframeElement.getAttribute('src') === 'about:blank') {
                 console.error(`Iframe failed to load: ${reason}`);
                 displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>${reason}. It might be offline or blocked by browser security.</span>`, true, iframeUrl, parentBoxElement);
                 iframeElement.classList.remove('active'); // Hide iframe
                 iframeElement.src = 'about:blank'; // Ensure src is cleared
                 playerAreaElement.querySelector('.loader').classList.remove('visible'); // Hide loader
             } else {
                 console.log("Ignoring iframe failure for a different src."); // Failure event arrived after src was changed
             }
        };

        // --- Set Timeout ---
        // Start a timer. If the 'onload' event doesn't fire within this time, assume failure.
        iframeLoadTimeoutId = setTimeout(() => {
            // Double-check the src attribute when the timeout fires
             if (iframeElement.getAttribute('src') === iframeUrl) {
                handleIframeLoadFailure("Load timeout");
             } else {
                 console.log("Iframe timeout occurred, but src has changed. Ignoring.");
             }
        }, CONFIG.iframeLoadTimeoutMs); // Use configured timeout value

        // --- Iframe Event Listeners ---
        iframeElement.onload = () => {
            cleanupIframeLoad(); // Success! Clear the timeout.
            // Verify the loaded src matches the intended URL (prevents race conditions)
            if (iframeElement.getAttribute('src') === iframeUrl) {
                 console.log("Iframe onload event fired successfully for:", iframeUrl);
                 playerAreaElement.querySelector('.loader').classList.remove('visible'); // Hide loader
                 iframeElement.classList.add('active'); // Show the iframe
             } else {
                 console.log("Iframe onload fired, but for a different src. Ignoring.");
             }
        };

        iframeElement.onerror = () => {
             // The 'onerror' event often fires for cross-origin restrictions even if content loads,
             // but it's a strong indicator of failure if the content *doesn't* load.
             // Relying on the timeout is often more practical for cross-origin iframes.
             handleIframeLoadFailure("onError event fired");
        };

        // --- Set the iframe source ---
        // This initiates the loading process.
        iframeElement.src = iframeUrl;
    }

    // --- Utility Functions ---

    /**
     * Updates the timestamp display in the footer with the current time.
     */
    function updateTimestampDisplay() {
        try {
            const now = new Date();
            // Use Intl.DateTimeFormat for locale-aware time formatting
            const timeString = new Intl.DateTimeFormat(navigator.language || 'en-US', {
                hour: '2-digit',
                minute: '2-digit',
                // timeZoneName: 'short' // Optional: Add timezone abbreviation
            }).format(now);
            lastUpdatedTimestampElement.textContent = `Updated: ${timeString}`;
        } catch (error) {
             console.error("Failed to update timestamp:", error);
             lastUpdatedTimestampElement.textContent = "Updated: Error";
        }
    }

    /**
     * Shows the main initial loading message overlay.
     * @param {string} [text="Loading..."] - The message text to display.
     */
     function showInitialLoadingMessage(text = "Loading...") {
         initialLoadingMessageElement.textContent = text;
         initialLoadingMessageElement.style.display = 'block';
     }

    /**
     * Hides the main initial loading message overlay.
     */
      function hideInitialLoadingMessage() {
          initialLoadingMessageElement.style.display = 'none';
      }

     /**
      * Shows the main data fetch error message area.
      * @param {string} [text="An error occurred."] - The error message text to display.
      */
       function showDataFetchErrorMessage(text = "An error occurred.") {
           // Use innerHTML to allow simple formatting (like the <strong> and <span> used before)
           dataFetchErrorMessageElement.innerHTML = `<strong>Error</strong><span>${text}</span>`;
           dataFetchErrorMessageElement.style.display = 'block';
       }

    // --- End of Script ---

</script>

</body>
</html>