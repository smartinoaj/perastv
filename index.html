<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- CSS Variables (Theme) --- */
        :root {
            /* True Grayscale/Black Theme */
            --bg-primary: #0a0a0a; /* Near black */
            --bg-secondary: #1a1a1a; /* Very dark gray */
            --bg-tertiary: #2a2a2a; /* Dark gray */
            --accent-color: #e50914; /* Netflix-like red */
            --text-primary: #ffffff; /* White */
            --text-secondary: #a0a0a0; /* Medium gray */
            --border-color: #3a3a3a; /* Gray for borders */
            --border-color-active: #6b7280; /* Lighter border for hover/focus */
            --error-color: #f87171; /* Light red for errors */
            --font-sans: 'Inter', sans-serif;
        }

        /* --- Basic Reset & Body Styling --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html {
            scroll-behavior: smooth;
            height: 100%; /* Ensure html takes full height */
        }
        body {
            background-color: var(--bg-primary); color: var(--text-primary);
            font-family: var(--font-sans); line-height: 1.6;
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh on mobile */
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            padding-bottom: 120px; /* Increased padding for footer content */
            position: relative; /* Needed for footer positioning */
        }
        .container { max-width: 1600px; margin: 0 auto; padding: 0 20px; }

        /* --- Main Layout: Header --- */
        header { text-align: center; padding: 30px 0 20px; }
        header img { max-width: 200px; height: auto; } /* Logo size */

        /* --- Search Bar --- */
        .search-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            padding: 0 15px;
        }
        #search-input {
            padding: 12px 18px;
            font-size: 1em;
            border-radius: 25px; /* Pill shape */
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            width: 100%;
            max-width: 500px; /* Limit search bar width */
            transition: all 0.2s ease;
            text-align: center; /* Center the text and placeholder */
        }
        #search-input:focus {
            outline: none;
            border-color: var(--border-color-active);
            background-color: var(--bg-tertiary);
        }
        #search-input::placeholder { color: var(--text-secondary); text-align: center; }
        /* Cross-browser placeholder centering */
        #search-input::-webkit-input-placeholder { text-align: center; }
        #search-input:-moz-placeholder { text-align: center; }
        #search-input::-moz-placeholder { text-align: center; }
        #search-input:-ms-input-placeholder { text-align: center; }


        /* --- Tabs --- */
        .tabs {
            display: flex; justify-content: center; gap: 12px;
            margin-bottom: 40px; flex-wrap: wrap; /* Allow wrapping on small screens */
            padding: 0 10px;
        }
        .tab-button {
            background: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-color); padding: 10px 25px; cursor: pointer;
            border-radius: 20px; font-size: 0.9em; font-weight: 600;
            transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .tab-button:hover { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--bg-tertiary); }
        .tab-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); }

        /* --- Channel Grid (General) --- */
        .channel-grid {
            display: grid;
            /* Default: Auto-fill columns, min 260px wide */
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px; padding: 0 10px 50px; /* Add bottom padding */
            display: none; /* Hidden by default, shown by JS */
        }
        /* --- Grid Column Adjustments for Non-Match/Non-ALL Tabs --- */
        @media (min-width: 768px) { /* Medium screens (tablets) */
            .channel-grid:not(#Matches):not(#ALL) {
                 grid-template-columns: repeat(2, 1fr); /* 2 columns */
            }
            /* ALL tab also uses 2 columns on medium */
            #ALL.channel-grid {
                 grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (min-width: 1024px) { /* Large screens (desktops) */
             .channel-grid:not(#Matches):not(#ALL) {
                 grid-template-columns: repeat(3, 1fr); /* 3 columns */
            }
             /* ALL tab also uses 3 columns on large */
            #ALL.channel-grid {
                 grid-template-columns: repeat(3, 1fr);
            }
        }

        /* --- Grid Layout for Matches Tab --- */
        #Matches.channel-grid {
             grid-template-columns: 1fr; /* Always single column */
             max-width: 1000px; /* Limit width of the single column */
             margin: 0 auto; /* Center the grid */
        }

        /* Show active grid */
        .channel-grid.active { display: grid; }


        /* --- Channel Box (General Styling) --- */
        .channel-box {
            background: var(--bg-secondary); border-radius: 10px; padding: 15px;
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid var(--bg-secondary); position: relative; overflow: hidden;
            display: block; /* Default state */
        }

        /* --- Styling for MATCH boxes within the MATCHES grid (NOT Expanded) --- */
        #Matches .channel-box[id^="match-"]:not(.expanded) {
            grid-column: 1 / -1; /* Span all columns (of the 1-column grid) */
            width: 95%;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }

        /* --- Styling for MATCH boxes within the ALL grid (NOT Expanded) --- */
        #ALL .channel-box[id^="match-"]:not(.expanded) {
            grid-column: 1 / -1; /* Force span all columns of the multi-column grid */
            width: 95%;          /* Set width relative to the full grid width */
            max-width: 1000px;    /* Apply the same max-width as in #Matches */
            margin-left: auto;   /* Center it */
            margin-right: auto;
        }

        /* --- Styling for CHANNEL boxes within the ALL grid (NOT Expanded) --- */
        #ALL .channel-box:not([id^="match-"]):not(.expanded) {
            grid-column: auto / span 1; /* Explicitly take one cell */
            width: auto; /* Reset any potential overrides */
            max-width: none;
            margin-left: 0;
            margin-right: 0;
        }


        /* Hide filtered-out boxes using JS */
        .channel-box.hidden {
             display: none;
        }

        /* Hover effect for non-expanded boxes */
        .channel-box:not(.expanded):hover {
            transform: translateY(-4px); /* Slight lift effect */
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
            border-color: var(--border-color-active);
        }

        /* --- Channel Header (Inside Box) --- */
        .channel-header {
            display: flex; align-items: center;
            justify-content: center; /* Center channel name by default */
            gap: 10px; text-align: center; min-height: 35px; cursor: pointer;
        }
         /* --- Matches Header Layout (Applies to match boxes everywhere) --- */
        .channel-box[id^="match-"] .channel-header {
             justify-content: center; /* Center team names/logos */
             gap: 0; /* Remove gap, use margins on h3 */
             text-align: center;
        }
        /* Logo styling (used for match logos) */
        .match-logo {
            height: 40px; width: 40px; /* Logo size */
            object-fit: contain; /* Prevent distortion */
            flex-shrink: 0; /* Prevent shrinking */
            border-radius: 4px; /* Slightly rounded corners */
            display: inline-block; /* Align with text */
            vertical-align: middle;
        }
        /* Ensure match logos within header use specific styling if needed */
        .channel-header img.match-logo {
             height: 40px;
             width: auto; /* Allow width to adjust based on height */
             object-fit: contain;
        }
        /* Channel/Match Title */
        .channel-header h3 {
            font-size: 1.1em;
            font-weight: 600; margin: 0;
            word-break: break-word; /* Prevent long names overflowing */
            text-align: center;
            flex-grow: 0; /* Don't grow */
            flex-shrink: 1; /* Allow shrinking if needed */
        }
        /* Add horizontal margin for match titles to create space from logos */
        .channel-box[id^="match-"] .channel-header h3 {
            margin-left: 25px;
            margin-right: 25px;
        }
        /* Reset margins for non-match titles */
         .channel-box:not([id^="match-"]) .channel-header h3 {
             margin-left: 0;
             margin-right: 0;
         }

        /* Channel Info (League/Time for Matches) */
        .channel-info {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: center; /* Center info text */
            margin-top: 8px; /* Space below header */
            margin-left: 0; /* Reset potential inherited margins */
            margin-bottom: 0;
            font-weight: 500; cursor: pointer; /* Make clickable to toggle */
            display: block; /* Default for matches */
        }
        /* Hide info section for non-match boxes */
        .channel-box:not([id^="match-"]) .channel-info {
            display: none;
        }
        .channel-info span { margin: 0 5px; } /* Spacing around separator */

        /* --- Expanded Channel Box Styling (General) --- */
        .channel-box.expanded {
            width: 100%; /* Take full width of its grid cell(s) */
            max-width: 1200px; /* Max width for expanded view */
            margin-left: auto; /* Center if grid column is wider */
            margin-right: auto;
            position: relative; /* Keep in flow for centering */
            grid-column: auto / span 1; /* Default span */
            cursor: default;
            background: var(--bg-tertiary);
            padding-bottom: 20px; z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color);
            overflow: visible;
            display: block !important; /* Override .hidden */
        }
        /* Override column span for expanded boxes in multi-column grids (excluding #Matches) */
        @media (min-width: 768px) {
            .channel-grid.active:not(#Matches) .channel-box.expanded {
                grid-column: auto / span 2;
            }
        }
        @media (min-width: 1024px) {
             .channel-grid.active:not(#Matches) .channel-box.expanded {
                grid-column: auto / span 3;
            }
        }

        /* Specific Styling for EXPANDED MATCH boxes within the ALL grid */
        #ALL .channel-box[id^="match-"].expanded {
             grid-column: 1 / -1; /* Force full span */
             max-width: 1200px; /* Consistent max-width */
             margin-left: auto;
             margin-right: auto;
        }
        /* Ensure expanded matches in the #Matches grid don't try to span multiple columns */
         #Matches .channel-box[id^="match-"].expanded {
             grid-column: 1 / -1; /* Stay in the single column */
             max-width: 1200px; /* Consistent max-width */
             margin-left: auto;
             margin-right: auto;
         }


        /* Make header/info non-clickable when expanded */
        .channel-box.expanded .channel-header,
        .channel-box.expanded .channel-info { cursor: default; }

        /* --- Player Area (Inside Expanded Box) --- */
        .iframe-container { margin-top: 18px; display: none; width: 100%; }
        /* Show container when box is expanded */
        .channel-box.expanded .iframe-container { display: block; }
        .player-area {
            position: relative; width: 100%; aspect-ratio: 16 / 9; /* Maintain 16:9 */
            background-color: #000; border-radius: 8px; overflow: hidden;
            margin-bottom: 18px; min-height: 200px; /* Minimum height on mobile */
            /* Center loader/messages */
            display: flex; justify-content: center; align-items: center;
        }
        /* Player elements (iframe/video) */
        .player-area iframe, .player-area video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: none; display: none; /* Hidden by default */
            object-fit: contain; /* Fit video within player area */
        }
        /* Show active player */
        .player-area iframe.active, .player-area video.active { display: block; }
        /* Message area (for errors, instructions) */
        .player-message {
            color: var(--text-secondary); font-size: 0.9em; padding: 20px;
            text-align: center; display: none; /* Hidden by default */
        }
        .player-message.visible { display: block; }
        .player-message strong { color: var(--text-primary); display: block; margin-bottom: 5px; }
        .player-message button { margin-top: 15px; } /* Spacing for 'Try Next' button */
        /* Loading spinner */
        .loader {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-color); /* Accent color for spinner */
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
        }
        .loader.visible { display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive player height adjustments */
        @media (min-width: 768px) { .channel-box.expanded .player-area { min-height: 400px; max-height: 70vh; } }
        @media (min-width: 1024px) { .channel-box.expanded .player-area { min-height: 480px; } }

        /* --- Stream Buttons (Inside Expanded Box) --- */
        .stream-buttons { text-align: center; margin-top: 15px; }
        /* Language group styling (for matches) */
        .stream-buttons div { margin-bottom: 10px; }
        .stream-buttons strong {
            color: var(--text-secondary); font-size: 0.85em; margin-right: 8px;
            font-weight: 600; text-transform: uppercase;
        }
        /* Individual stream button */
        .stream-button {
            background: var(--bg-secondary); color: var(--text-primary);
            border: 1px solid var(--border-color); padding: 7px 18px;
            border-radius: 20px; cursor: pointer; font-size: 0.85em;
            font-weight: 500; transition: all 0.2s ease;
            display: inline-block; /* Allow multiple buttons per line */
            margin: 4px; /* Spacing between buttons */
        }
        .stream-button:hover { background: #4a4a4a; border-color: #5a5a5a; }
        /* Active stream button */
        .stream-button.active {
            background: var(--accent-color); color: white;
            border-color: var(--accent-color); font-weight: 600;
        }
        /* 'Try Next' button shown on error */
        .try-next-button {
            background: var(--accent-color); color: white;
            border: none; padding: 8px 15px; border-radius: 6px;
            cursor: pointer; font-size: 0.85em; font-weight: 500;
            transition: background-color 0.2s ease;
        }
        .try-next-button:hover { background-color: #b80710; } /* Darker red on hover */

        /* --- Footer --- */
        footer {
            text-align: center; color: var(--text-secondary); font-size: 0.8em;
            padding: 20px 0;
            width: 100%;
            margin-top: 40px; /* Space above footer */
        }
        /* Style for the disclaimer text */
        .disclaimer {
            font-size: 0.75em; /* Slightly smaller */
            margin-top: 15px; /* Space above disclaimer */
            padding: 0 20px; /* Add horizontal padding */
            max-width: 800px; /* Limit width for readability */
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5; /* Adjust line spacing */
            color: #888; /* Lighter gray */
        }

        /* --- Loading/Error States (General Page Load) --- */
        .loading-message, .error-message { text-align: center; padding: 50px 20px; color: var(--text-secondary); font-size: 1em; font-weight: 500; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 767px) { /* Mobile screens */
             .channel-grid { grid-template-columns: 1fr; }
             .channel-grid.active .channel-box.expanded {
                 grid-column: auto / span 1;
             }
             .channel-box { padding: 15px; }
             .stream-button { padding: 6px 15px; font-size: 0.8em; }
             header img { max-width: 160px; }
             .tabs { gap: 10px; margin-bottom: 30px; }
             .tab-button { padding: 8px 20px; font-size: 0.85em; }
             #Matches.channel-grid { max-width: 100%; }
             #Matches .channel-header { gap: 10px; }
             .match-logo, #Matches .channel-header img.match-logo { height: 32px; width: 32px; }
             .channel-info { font-size: 0.75em;}
             .channel-box[id^="match-"] .channel-header h3 { margin: 0 15px; }
        }
        @media (max-width: 480px) { /* Very small screens */
            .container { padding: 0 10px; }
            header img { max-width: 140px; }
            .tabs { gap: 8px; }
            .tab-button { padding: 7px 15px; }
            .channel-box { padding: 12px; }
            .channel-header h3 { font-size: 1em;}
            .channel-box[id^="match-"] .channel-header h3 { margin: 0 10px;}
            .match-logo, #Matches .channel-header img.match-logo { height: 30px; width: 30px; }
            .stream-buttons strong { display: block; margin-bottom: 5px; }
            .player-area { min-height: 200px; }
            #search-input { padding: 10px 15px; font-size: 0.95em; }
             .channel-info { font-size: 0.7em;}
             .disclaimer { font-size: 0.7em; } /* Adjust disclaimer size */
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <img src="ptvlogo.png" alt="PERAS TV Logo">
    </header>

    <div class="search-container">
        <input type="search" id="search-input" placeholder="Search channels or matches...">
    </div>

    <div class="tabs">
        <button class="tab-button" data-tab="ALL">ALL</button>
        <button class="tab-button" data-tab="PT">PT</button>
        <button class="tab-button" data-tab="UK">UK</button>
        <button class="tab-button" data-tab="ES">ES</button>
        <button class="tab-button" data-tab="Matches">Matches</button>
    </div>

    <div id="loadingMessage" class="loading-message">Loading channels...</div>
    <div id="fetchErrorMessage" class="error-message" style="display: none;"></div>

    <div id="ALL" class="channel-grid"></div>
    <div id="PT" class="channel-grid"></div>
    <div id="UK" class="channel-grid"></div>
    <div id="ES" class="channel-grid"></div>
    <div id="Matches" class="channel-grid"></div>

</div> <footer>
    <p id="lastUpdated"></p> <p class="disclaimer">
        PerasTV Official DISCLAIMER : None of the videos are hosted by this
        site. Streams hosted from different sites, where sources available over
        Internet are embedded here. This site is not responsible for the
        legality of the content. For legal issues, please contact appropriate
        media file owners/hosters.
    </p>
</footer>

<script>
    /* --- JavaScript (No changes needed) --- */

    // --- Configuration Constants ---
    const CONFIG = {
        channelsUrl: "channels.json",
        matchesUrl: "matches.json",
        placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%23000000"/></svg>',
        searchDebounceMs: 300,
        lastTabKey: 'perasTvLastTab'
    };

    // --- DOM Element References ---
    const searchInput = document.getElementById('search-input');
    const tabsContainer = document.querySelector('.tabs');
    const channelGrids = document.querySelectorAll('.channel-grid');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const loadingMessage = document.getElementById('loadingMessage');
    const fetchErrorMessage = document.getElementById('fetchErrorMessage');

    // --- Application State ---
    let hlsInstance = null;
    let channelsData = {};
    let matchesData = [];
    let currentlyExpandedBox = null;
    let searchDebounceTimer = null;
    let activeTabId = 'ALL'; // Default active tab ID set to ALL

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        updateTimestamp();
        loadData();
    });

    // --- Event Listener Setup ---
    function setupEventListeners() {
        // Tabs
        tabsContainer.addEventListener('click', (event) => {
            if (event.target.classList.contains('tab-button')) {
                showTab(event.target.dataset.tab);
            }
        });

        // Search Input (Debounced)
        const debouncedFilter = debounce((term) => {
            filterChannels(term);
        }, CONFIG.searchDebounceMs);

        searchInput.addEventListener('input', (event) => {
            debouncedFilter(event.target.value);
        });

        // Close expanded box with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && currentlyExpandedBox) {
                 toggleExpansion(currentlyExpandedBox);
            }
        });
    }

    // --- Data Fetching & Initial Rendering ---
    async function loadData() {
        loadingMessage.style.display = 'block';
        fetchErrorMessage.style.display = 'none';
        try {
            const cacheBuster = `?t=${Date.now()}`;
            const [channelsRes, matchesRes] = await Promise.all([
                fetch(CONFIG.channelsUrl + cacheBuster),
                fetch(CONFIG.matchesUrl + cacheBuster)
            ]);

            if (!channelsRes.ok || !matchesRes.ok) {
                throw new Error(`Failed to load data (Channels: ${channelsRes.status}, Matches: ${matchesRes.status})`);
            }

            channelsData = await channelsRes.json();
            matchesData = await matchesRes.json();

            renderAllChannels(); // Render content into ALL grids
            loadingMessage.style.display = 'none';

            // Restore last tab preference or default to ALL
            const lastTab = localStorage.getItem(CONFIG.lastTabKey) || 'ALL'; // Default to ALL
            showTab(lastTab); // ShowTab handles setting the active classes

        } catch (error) {
            console.error("Failed to load channel or match data:", error);
            loadingMessage.style.display = 'none';
            fetchErrorMessage.textContent = `Error loading data: ${error.message}. Please try refreshing.`;
            fetchErrorMessage.style.display = 'block';
        }
    }

    // --- Rendering Functions ---
    function renderAllChannels() {
        const allGrid = document.getElementById('ALL');
        if (!allGrid) return;

        allGrid.innerHTML = ''; // Clear ALL grid initially

        // 1. Render Matches to ALL grid and Matches grid
        const matches = matchesData || [];
        renderMatchChannels(matches); // Renders only to #Matches grid now

        // Append match boxes to ALL grid
        if (matches.length > 0) {
            matches.forEach((match, index) => {
                const uniqueId = `match-${index}`;
                const box = createMatchBoxElement(match, uniqueId);
                box.dataset.itemType = 'match';
                allGrid.appendChild(box);
            });
        }

        // 2. Render PT Channels to ALL grid and PT grid
        const ptChannels = channelsData.PT || [];
        renderChannels('PT', ptChannels); // Renders to #PT grid
        if (ptChannels.length > 0) {
             ptChannels.forEach((channel, index) => {
                const uniqueId = `PT-channel-${index}`;
                const box = createChannelBoxElement(channel, uniqueId);
                box.dataset.itemType = 'channel';
                allGrid.appendChild(box);
            });
        }

        // 3. Render UK Channels to ALL grid and UK grid
        const ukChannels = channelsData.UK || [];
        renderChannels('UK', ukChannels); // Renders to #UK grid
         if (ukChannels.length > 0) {
             ukChannels.forEach((channel, index) => {
                const uniqueId = `UK-channel-${index}`;
                const box = createChannelBoxElement(channel, uniqueId);
                 box.dataset.itemType = 'channel';
                allGrid.appendChild(box);
            });
        }

        // 4. Render ES Channels to ALL grid and ES grid
        const esChannels = channelsData.ES || [];
        renderChannels('ES', esChannels); // Renders to #ES grid
         if (esChannels.length > 0) {
             esChannels.forEach((channel, index) => {
                const uniqueId = `ES-channel-${index}`;
                const box = createChannelBoxElement(channel, uniqueId);
                box.dataset.itemType = 'channel';
                allGrid.appendChild(box);
            });
        }

        addChannelBoxEventListeners(); // Add listeners after all boxes are in DOM
    }

    // Renders channel boxes for a specific language tab (PT, UK, ES)
    function renderChannels(tabId, channels) {
        const grid = document.getElementById(tabId);
        if (!grid) return;
        grid.innerHTML = '';
        if (!channels || channels.length === 0) {
            grid.innerHTML = '<p class="loading-message">No channels available.</p>';
            return;
        }
        channels.forEach((channel, index) => {
            const uniqueId = `${tabId}-channel-${index}`;
            const box = createChannelBoxElement(channel, uniqueId);
            grid.appendChild(box);
        });
    }

    // Renders match boxes ONLY to the #Matches grid
    function renderMatchChannels(matches) {
        const grid = document.getElementById('Matches');
        if (!grid) return;
        grid.innerHTML = '';
         if (!matches || matches.length === 0) {
            grid.innerHTML = '<p class="loading-message">No matches available.</p>';
            return;
        }
        matches.forEach((match, index) => {
             const uniqueId = `match-${index}`;
            const box = createMatchBoxElement(match, uniqueId);
            grid.appendChild(box);
        });
    }

    // --- Element Creation ---
    function createChannelBoxElement(channel, uniqueId) {
        const { name, srcs = [] } = channel;
        const box = document.createElement('div');
        box.className = 'channel-box';
        box.dataset.channelName = name;
        box.dataset.sources = JSON.stringify(srcs);
        box.id = uniqueId;

        box.innerHTML = `
            <div class="channel-header" id="${uniqueId}-header" aria-expanded="false" aria-controls="${uniqueId}-player-container">
                <h3>${name}</h3>
            </div>
            <div class="channel-info"></div> <div class="iframe-container" id="${uniqueId}-player-container" role="region" aria-labelledby="${uniqueId}-header">
                <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message"></div>
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons"></div>
            </div>
        `;
        return box;
    }
     function createMatchBoxElement(match, uniqueId) {
        const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = match;
        const box = document.createElement('div');
        box.className = 'channel-box';
        const allSources = { pt, uk, es };
        const matchTitle = `${team1} vs ${team2}`;
        box.dataset.channelName = matchTitle;
        box.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase();
        box.dataset.sources = JSON.stringify(allSources);
        box.id = uniqueId;

        box.innerHTML = `
            <div class="channel-header" id="${uniqueId}-header" aria-expanded="false" aria-controls="${uniqueId}-player-container">
                 ${logo1 ? `<img src="${logo1}" alt="${team1} logo" class="match-logo">` : '<span class="match-logo"></span>'}
                 <h3>${matchTitle}</h3>
                 ${logo2 ? `<img src="${logo2}" alt="${team2} logo" class="match-logo">` : '<span class="match-logo"></span>'}
            </div>
            <div class="channel-info"> ${league ? `<span>${league}</span>` : ''}
                ${league && time ? '<span>|</span>' : ''}
                ${time ? `<span>${time}</span>` : ''}
            </div>
             <div class="iframe-container" id="${uniqueId}-player-container" role="region" aria-labelledby="${uniqueId}-header">
                 <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message"></div>
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons"></div>
            </div>
        `;
        box.querySelectorAll('img.match-logo').forEach(img => {
            img.onerror = () => { img.style.display = 'none'; };
        });
        return box;
    }
     function createStreamButtonWrapper(label, url, contextBox) {
        const button = document.createElement('button');
        button.className = 'stream-button';
        button.textContent = label;
        button.dataset.streamUrl = url;
        button.onclick = (e) => {
            e.stopPropagation();
            changeStream(button, url, contextBox);
        };
        return button;
    }


    // --- Event Listener Setup for Channel Boxes ---
    function addChannelBoxEventListeners() {
         document.querySelectorAll('.channel-box').forEach(box => {
            if (box.dataset.listenerAdded === 'true') return;

            const header = box.querySelector('.channel-header');
            const info = box.querySelector('.channel-info');

            const toggleHandler = (event) => {
                 if (!event.target.closest('.stream-button')) {
                    toggleExpansion(box);
                 }
            };

            if (header) header.addEventListener('click', toggleHandler);
            // Add listener only if info is visible (matches)
            if (info && getComputedStyle(info).display !== 'none') {
                 info.addEventListener('click', toggleHandler);
            }

            box.addEventListener('click', (event) => {
                const isExpanded = box.classList.contains('expanded');
                const isClickOnPlayerArea = event.target.closest('.iframe-container');
                const isClickOnHeaderOrInfo = event.target.closest('.channel-header') || event.target.closest('.channel-info');

                if (!isExpanded && !isClickOnPlayerArea && !isClickOnHeaderOrInfo) {
                   // Potentially toggle here if needed
                }
            });
            box.dataset.listenerAdded = 'true';
        });
    }

    // --- Tab Management ---
    function showTab(tabId) {
        activeTabId = tabId;

        tabsContainer.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });

        channelGrids.forEach(grid => {
            grid.classList.toggle('active', grid.id === tabId);
        });

        if (currentlyExpandedBox) {
            collapseBox(currentlyExpandedBox);
        }

        localStorage.setItem(CONFIG.lastTabKey, tabId);
        filterChannels(searchInput.value); // Re-apply filter after tab switch
    }

    // --- Search Filtering ---
    function filterChannels(searchTerm) {
        const term = searchTerm.toLowerCase().trim();

        document.querySelectorAll('.channel-box').forEach(box => {
            const channelName = box.dataset.channelName?.toLowerCase() || '';
            const searchTerms = box.dataset.searchTerms?.toLowerCase() || '';
            const isMatch = channelName.includes(term) || searchTerms.includes(term);

            let isVisible = false;
            if (term === '') {
                // No search: visibility depends on active tab
                const parentGrid = box.closest('.channel-grid');
                isVisible = parentGrid && parentGrid.id === activeTabId;
            } else {
                // Search active: visibility depends on matching term
                isVisible = isMatch;
            }

            // Hide or show box
            if (box.classList.contains('expanded') && term !== '') {
                 box.classList.remove('hidden'); // Keep expanded box visible
            } else {
                 box.classList.toggle('hidden', !isVisible);
            }

            // Collapse box if hidden (only when search is cleared)
            if (!isVisible && box.classList.contains('expanded') && term === '') {
                 collapseBox(box);
            }
        });

         // Show/Hide grids based on visible children during active search
         channelGrids.forEach(grid => {
            if (term !== '') {
                const hasVisibleChildren = Array.from(grid.children).some(child =>
                    child.classList.contains('channel-box') && !child.classList.contains('hidden')
                );
                grid.classList.toggle('active', hasVisibleChildren);
            } else {
                 grid.classList.toggle('active', grid.id === activeTabId); // Standard tab visibility
            }
         });
    }


    // --- Channel Box Expansion ---
    function toggleExpansion(boxToToggle) {
        const isExpanding = !boxToToggle.classList.contains('expanded');
        const header = boxToToggle.querySelector('.channel-header');

        if (isExpanding && currentlyExpandedBox && currentlyExpandedBox !== boxToToggle) {
            collapseBox(currentlyExpandedBox);
        }

        if (isExpanding) {
            expandBox(boxToToggle);
            if(header) header.setAttribute('aria-expanded', 'true');
        } else {
            collapseBox(boxToToggle);
             if(header) header.setAttribute('aria-expanded', 'false');
        }
    }
    function expandBox(box) {
        box.classList.add('expanded');
        box.classList.remove('hidden'); // Ensure visible
        currentlyExpandedBox = box;
        populateAndLoadFirstStream(box);

        // Reset grid-column style (CSS rules will handle spanning)
        box.style.gridColumn = '';

        setTimeout(() => {
             box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
             const firstButton = box.querySelector('.stream-button');
             if (firstButton) {
                 setTimeout(() => firstButton.focus({ preventScroll: true }), 50);
             }
        }, 150);
    }
    function collapseBox(box) {
        box.classList.remove('expanded');
        box.style.gridColumn = ''; // Reset grid span override

        if (currentlyExpandedBox === box) {
            currentlyExpandedBox = null;
        }
        clearPlayerInBox(box);
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) streamButtonsDiv.innerHTML = '';
        const header = box.querySelector('.channel-header');
        if(header) {
            header.setAttribute('aria-expanded', 'false');
        }
        filterChannels(searchInput.value); // Re-apply filter
    }

    function populateAndLoadFirstStream(box) {
        const sourcesData = box.dataset.sources;
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (!sourcesData || !streamButtonsDiv) return;

        streamButtonsDiv.innerHTML = '';
        let firstUrl = null;
        let firstButtonElement = null;

        try {
            const sources = JSON.parse(sourcesData);
            if (Array.isArray(sources)) { // Handle channels
                if (sources.length > 0) {
                    sources.forEach((src, idx) => {
                        const url = typeof src === 'object' && src.url ? src.url : src;
                        const label = typeof src === 'object' && src.label ? src.label : `Source ${idx + 1}`;
                        if (!firstUrl) firstUrl = url;
                        const button = createStreamButtonWrapper(label, url, box);
                        if (!firstButtonElement) firstButtonElement = button;
                        streamButtonsDiv.appendChild(button);
                    });
                } else { noStreamsAvailable(streamButtonsDiv); }
            } else { // Handle matches
                let streamCount = 0;
                Object.entries(sources).forEach(([lang, langSources]) => {
                    if (langSources && langSources.length > 0) {
                        const langDiv = document.createElement('div');
                        const strong = document.createElement('strong');
                        strong.textContent = `${lang.toUpperCase()}:`;
                        langDiv.appendChild(strong);
                        langSources.forEach((src, idx) => {
                            const url = typeof src === 'object' && src.url ? src.url : src;
                            const label = typeof src === 'object' && src.label ? src.label : `${idx + 1}`;
                            if (!firstUrl) firstUrl = url;
                            const button = createStreamButtonWrapper(label, url, box);
                             if (!firstButtonElement) firstButtonElement = button;
                            langDiv.appendChild(button);
                            streamCount++;
                        });
                        streamButtonsDiv.appendChild(langDiv);
                    }
                });
                 if (streamCount === 0) { noStreamsAvailable(streamButtonsDiv); }
            }

            if (firstUrl && firstButtonElement) {
                 changeStream(firstButtonElement, firstUrl, box);
            } else {
                clearPlayerInBox(box);
            }
        } catch (e) {
            console.error("Failed to parse sources data for box:", box.id, e);
            streamButtonsDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">Error loading stream data.</p>';
             clearPlayerInBox(box);
        }
    }
     function noStreamsAvailable(container) {
         container.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">No streams available.</p>';
    }


    // --- Stream Handling ---
    function changeStream(clickedButton, url, contextBox) {
        console.log(`Attempting to load stream in box ${contextBox.id}: ${url}`);
        const playerArea = contextBox.querySelector('.player-area');
        const loader = playerArea.querySelector('.loader');
        const messageDiv = playerArea.querySelector('.player-message');

        clearPlayerInBox(contextBox);
        messageDiv.classList.remove('visible');
        loader.classList.add('visible');

        const streamButtonsDiv = contextBox.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
             streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
        if (clickedButton) {
            clickedButton.classList.add('active');
        }

        const iframe = playerArea.querySelector('iframe');
        const video = playerArea.querySelector('video');

        if (!iframe || !video) {
            console.error("Could not find player elements in context box.");
            loader.classList.remove('visible');
            showPlayerMessage(playerArea, `<strong>Error:</strong> Player elements not found.`, false);
            return;
        }

        if (url && typeof url === 'string') {
             if (url.toLowerCase().endsWith('.m3u8')) {
                loadHlsStream(url, video, playerArea);
            } else {
                loadIframeStream(url, iframe, playerArea);
            }
        } else {
            console.error("Invalid stream URL:", url);
            loader.classList.remove('visible');
            showPlayerMessage(playerArea, `<strong>Error:</strong> Invalid stream URL provided.`, false);
            iframe.src = 'about:blank'; iframe.classList.remove('active');
            video.pause(); video.removeAttribute('src'); video.load(); video.classList.remove('active'); video.poster = '';
        }
    }
     function clearPlayerInBox(box) {
        if (!box) return;
        if (hlsInstance && hlsInstance.media === box.querySelector('video')) {
            console.log("Destroying HLS instance for box:", box.id);
            hlsInstance.destroy();
            hlsInstance = null;
        }
        const playerArea = box.querySelector('.player-area');
        if (!playerArea) return;

        const iframe = playerArea.querySelector('iframe');
        const video = playerArea.querySelector('video');
        const loader = playerArea.querySelector('.loader');
        const messageDiv = playerArea.querySelector('.player-message');

        if (iframe) { iframe.src = 'about:blank'; iframe.classList.remove('active'); }
        if (video) {
             const newVideo = video.cloneNode(true);
             video.parentNode.replaceChild(newVideo, video);
             newVideo.pause(); newVideo.removeAttribute('src'); newVideo.load();
             newVideo.classList.remove('active'); newVideo.poster = '';
        }
        if (loader) loader.classList.remove('visible');
        if (messageDiv) messageDiv.classList.remove('visible');

        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
    }
    function showPlayerMessage(playerArea, messageHtml, showTryNext, failedUrl = null, contextBox = null) {
        const messageDiv = playerArea.querySelector('.player-message');
        const loader = playerArea.querySelector('.loader');
        const video = playerArea.querySelector('video');
        const iframe = playerArea.querySelector('iframe');

        if (!messageDiv || !loader) return;

        if (video) video.classList.remove('active');
        if (iframe) iframe.classList.remove('active');
        loader.classList.remove('visible');

        messageDiv.innerHTML = messageHtml;
        if (showTryNext && failedUrl && contextBox) {
            const nextButton = findNextStreamButton(failedUrl, contextBox);
            if (nextButton) {
                const tryNextBtn = document.createElement('button');
                tryNextBtn.className = 'try-next-button';
                tryNextBtn.textContent = 'Try Next Source';
                tryNextBtn.onclick = (e) => {
                    e.stopPropagation();
                    nextButton.click();
                };
                messageDiv.appendChild(tryNextBtn);
            }
        }
        messageDiv.classList.add('visible');
    }
    function findNextStreamButton(failedUrl, contextBox) {
        const buttons = contextBox.querySelectorAll('.stream-button');
        let foundCurrent = false;
        for (let i = 0; i < buttons.length; i++) {
            if (buttons[i].dataset.streamUrl === failedUrl) {
                foundCurrent = true;
            } else if (foundCurrent) {
                return buttons[i];
            }
        }
        return null;
    }
    function loadHlsStream(url, videoElement, playerArea) {
        const currentBox = videoElement.closest('.channel-box');
        videoElement.poster = CONFIG.placeholderImage;

        if (Hls.isSupported()) {
            console.log("HLS.js supported. Initializing...");
             if (hlsInstance && hlsInstance.media === videoElement) {
                 console.log("Destroying previous HLS instance attached to this video element.");
                 hlsInstance.destroy();
                 hlsInstance = null;
             } else if (hlsInstance && hlsInstance.media !== videoElement) {
                 console.log("Keeping existing HLS instance attached to a different video element.");
             }

            hlsInstance = new Hls({
                 manifestLoadingTimeOut: 10000,
                 levelLoadingTimeOut: 10000,
                 fragLoadingTimeOut: 15000,
                 fragLoadingMaxRetry: 4,
                 levelLoadingMaxRetry: 4,
                 manifestLoadingMaxRetry: 2,
            });

            hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                console.error('HLS.js Error:', event, data);
                 if (data.fatal && hlsInstance && videoElement === hlsInstance.media) {
                     console.log(`Fatal HLS error occurred in box ${currentBox.id}`);
                     let userMessage = `<strong>Stream Error</strong> (${data.details}).`;
                     if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                         userMessage = `<strong>Network Error</strong> loading stream (${data.details}). Check connection or try another source.`;
                     } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                         userMessage = `<strong>Media Playback Error</strong> (${data.details}). The stream might be corrupted or incompatible.`;
                     } else {
                         userMessage = `<strong>Stream Error</strong> (${data.type} - ${data.details}). The stream could not be loaded.`;
                     }
                     showPlayerMessage(playerArea, userMessage, true, url, currentBox);
                     hlsInstance.destroy();
                     hlsInstance = null;
                     videoElement.classList.remove('active');
                     videoElement.poster = '';
                 } else if (!data.fatal) {
                     console.warn("Non-fatal HLS error:", data.details);
                 }
            });

            hlsInstance.loadSource(url);
            hlsInstance.attachMedia(videoElement);

            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                 if (hlsInstance && videoElement === hlsInstance.media) {
                    console.log("HLS Manifest parsed, attempting to play...");
                    playerArea.querySelector('.loader').classList.remove('visible');
                    videoElement.classList.add('active');
                    videoElement.muted = true;
                    videoElement.play().then(() => {
                        console.log("Playback started successfully via HLS.js.");
                    }).catch(e => {
                         console.error("HLS.js video play failed:", e);
                         if (e.name === 'NotAllowedError') {
                             showPlayerMessage(playerArea, `<strong>Playback Paused</strong><br>Browser requires interaction. Click the play button on the video.`, false);
                         } else {
                              showPlayerMessage(playerArea, `<strong>Playback Error</strong><br>${e.message}`, true, url, currentBox);
                         }
                         videoElement.classList.remove('active');
                         playerArea.querySelector('.loader').classList.remove('visible');
                    });
                 }
            });

        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            console.log("Using native HLS support.");
            const newVideo = videoElement.cloneNode(true);
            videoElement.parentNode.replaceChild(newVideo, videoElement);
            videoElement = newVideo;

            videoElement.src = url;

            videoElement.oncanplay = () => {
                 if (videoElement.getAttribute('src') === url) {
                    playerArea.querySelector('.loader').classList.remove('visible');
                    videoElement.classList.add('active');
                    videoElement.muted = true;
                    videoElement.play().catch(e => {
                        console.error("Native HLS play failed:", e);
                        if (e.name === 'NotAllowedError') {
                            showPlayerMessage(playerArea, `<strong>Playback Paused</strong><br>Browser requires interaction. Click play.`, false);
                        } else {
                           showPlayerMessage(playerArea, `<strong>Native HLS Playback Error</strong><br>${e.message}`, true, url, currentBox);
                        }
                         videoElement.classList.remove('active');
                         playerArea.querySelector('.loader').classList.remove('visible');
                    });
                 }
            };
            videoElement.onerror = () => {
                 if (videoElement.getAttribute('src') === url) {
                     console.error("Native HLS playback error.");
                     showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>Could not load native HLS stream. It might be invalid or blocked.`, true, url, currentBox);
                     videoElement.classList.remove('active');
                     videoElement.poster = '';
                     playerArea.querySelector('.loader').classList.remove('visible');
                 } else {
                     console.log("Ignoring native HLS error for a different src.");
                 }
            };
             videoElement.load();


        } else {
            console.error("HLS is not supported by this browser.");
            showPlayerMessage(playerArea, `<strong>Error:</strong> HLS playback is not supported in your browser.`, false);
            videoElement.classList.remove('active'); videoElement.poster = '';
            playerArea.querySelector('.loader').classList.remove('visible');
        }
    }
    function loadIframeStream(url, iframeElement, playerArea) {
        const currentBox = iframeElement.closest('.channel-box');
        console.log("Loading iframe stream...");

        let iframeLoadTimeout = setTimeout(() => {
             console.warn("Iframe load timeout reached for:", url);
             try {
                  if (!iframeElement.contentDocument || iframeElement.contentDocument.URL === 'about:blank' || iframeElement.getAttribute('src') !== url ) {
                        throw new Error("Iframe content not accessible or didn't load.");
                  }
                  console.log("Iframe seems loaded despite timeout (likely cross-origin).");
                   playerArea.querySelector('.loader').classList.remove('visible');
                   iframeElement.classList.add('active');

             } catch (e) {
                  console.error("Iframe failed to load within timeout.");
                  showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>The source took too long to load or might be blocked.`, true, url, currentBox);
                  iframeElement.classList.remove('active');
                  iframeElement.src = 'about:blank';
                  playerArea.querySelector('.loader').classList.remove('visible');
             }
        }, 15000);


        iframeElement.onload = () => {
            clearTimeout(iframeLoadTimeout);
            if (iframeElement.getAttribute('src') === url) {
                 console.log("Iframe onload event fired for:", url);
                 playerArea.querySelector('.loader').classList.remove('visible');
                 iframeElement.classList.add('active');
             } else {
                 console.log("Iframe onload fired for a different src, ignoring:", iframeElement.getAttribute('src'));
             }
        };

        iframeElement.onerror = () => {
             clearTimeout(iframeLoadTimeout);
             if (iframeElement.getAttribute('src') === url) {
                 console.error("Iframe onerror event fired for:", url);
                 showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>Failed to load iframe source. It might be blocked or unavailable.`, true, url, currentBox);
                 iframeElement.classList.remove('active');
                 iframeElement.src = 'about:blank';
                 playerArea.querySelector('.loader').classList.remove('visible');
             } else {
                 console.log("Iframe onerror fired for a different src, ignoring.");
             }
        };

        iframeElement.src = url;
    }


    // --- Utility Functions ---
    function updateTimestamp() {
        const now = new Date();
        lastUpdatedEl.textContent = `Updated: ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
    }
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

</script>

</body>
</html>
