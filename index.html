<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- CSS Variables (Theme) --- */
        :root {
            /* Theme Colors */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --accent-color: #e50914;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --border-color: #3a3a3a;
            --border-color-active: #6b7280;
            --error-color: #f87171;
            --favorite-color: #facc15; /* Gold/Yellow for favorite star */
            --font-sans: 'Inter', sans-serif;
        }

        /* --- Basic Reset & Body Styling --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; height: 100%; }
        body {
            background-color: var(--bg-primary); color: var(--text-primary);
            font-family: var(--font-sans); line-height: 1.6;
            overscroll-behavior-y: contain;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
            padding-bottom: 120px;
            position: relative;
        }
        .container { max-width: 1600px; margin: 0 auto; padding: 0 20px; }

        /* --- Header --- */
        header { text-align: center; padding: 30px 0 20px; }
        header img { max-width: 200px; height: auto; }

        /* --- Search Bar --- */
        .search-container { display: flex; justify-content: center; margin-bottom: 30px; padding: 0 15px; }
        #search-input {
            padding: 12px 18px; font-size: 1em; border-radius: 25px;
            border: 1px solid var(--border-color); background-color: var(--bg-secondary);
            color: var(--text-primary); width: 100%; max-width: 500px;
            transition: all 0.2s ease; text-align: center;
        }
        #search-input:focus { outline: none; border-color: var(--border-color-active); background-color: var(--bg-tertiary); }
        #search-input::placeholder { color: var(--text-secondary); text-align: center; }
        #search-input::-webkit-input-placeholder { text-align: center; }
        #search-input:-moz-placeholder { text-align: center; }
        #search-input::-moz-placeholder { text-align: center; }
        #search-input:-ms-input-placeholder { text-align: center; }

        /* --- Tabs --- */
        .tabs { display: flex; justify-content: center; gap: 12px; margin-bottom: 40px; flex-wrap: wrap; padding: 0 10px; }
        .tab-button {
            background: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-color); padding: 10px 25px; cursor: pointer;
            border-radius: 20px; font-size: 0.9em; font-weight: 600;
            transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 6px; /* Space between icon and text */
        }
        .tab-button .tab-icon { /* Style for icons in tab buttons */
            width: 1em;
            height: 1em;
            fill: currentColor; /* Use button's text color */
        }
        .tab-button:hover { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--bg-tertiary); }
        .tab-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); }
        .tab-button.active .tab-icon { fill: white; } /* Ensure icon is white when active */

        /* --- MODIFIED: Style for Favorites Tab Button --- */
        .tab-button[data-tab="Favorites"] {
            color: var(--favorite-color); /* Default color is gold */
            border-color: var(--favorite-color); /* Gold border */
            padding: 10px 15px; /* Adjust padding if only icon is shown */
        }
        .tab-button[data-tab="Favorites"] .tab-icon {
             fill: var(--favorite-color); /* Ensure icon is gold */
        }
        /* Hover state for Favorites tab */
        .tab-button[data-tab="Favorites"]:hover {
            background: var(--favorite-color); /* Gold background on hover */
            color: var(--bg-secondary); /* Dark text on hover */
            border-color: var(--favorite-color);
        }
        .tab-button[data-tab="Favorites"]:hover .tab-icon {
            fill: var(--bg-secondary); /* Dark icon on hover */
        }
        /* Active state for Favorites tab */
        .tab-button[data-tab="Favorites"].active {
            background: var(--favorite-color); /* Gold background when active */
            color: var(--bg-secondary); /* Dark text when active */
            border-color: var(--favorite-color);
        }
         .tab-button[data-tab="Favorites"].active .tab-icon {
            fill: var(--bg-secondary); /* Dark icon when active */
        }


        /* --- Channel Grid (General) --- */
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px; padding: 0 10px 50px;
            display: none; /* Hidden by default */
        }
        /* Grid Columns for specific tabs */
        @media (min-width: 768px) {
            .channel-grid:not(#Matches):not(#Favorites) { grid-template-columns: repeat(2, 1fr); }
            #Favorites.channel-grid { grid-template-columns: repeat(2, 1fr); } /* Favorites uses multi-col */
        }
        @media (min-width: 1024px) {
             .channel-grid:not(#Matches):not(#Favorites) { grid-template-columns: repeat(3, 1fr); }
             #Favorites.channel-grid { grid-template-columns: repeat(3, 1fr); } /* Favorites uses multi-col */
        }
        /* Grid Layout for Matches Tab */
        #Matches.channel-grid {
             grid-template-columns: 1fr; max-width: 1000px; margin: 0 auto;
        }
        /* Show active grid */
        .channel-grid.active { display: grid; }

        /* --- Channel Box (General Styling) --- */
        .channel-box {
            background: var(--bg-secondary); border-radius: 10px; padding: 15px;
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid var(--bg-secondary); position: relative; overflow: hidden;
            display: block;
        }
        /* Styling for MATCH boxes within the MATCHES grid (NOT Expanded) */
        #Matches .channel-box[id^="match-"]:not(.expanded) {
            grid-column: 1 / -1; width: 95%; max-width: 1000px; margin: auto;
        }
        /* Match boxes within ALL grid */
        #ALL .channel-box[id^="match-"]:not(.expanded) {
            grid-column: 1 / -1; width: 95%; max-width: 1000px; margin: auto;
        }
        /* Channel boxes within ALL grid */
        #ALL .channel-box:not([id^="match-"]):not(.expanded) {
            grid-column: auto / span 1; width: auto; max-width: none; margin: 0;
        }
        /* Boxes within Favorites grid */
        #Favorites .channel-box:not(.expanded) {
            grid-column: auto / span 1; width: auto; max-width: none; margin: 0;
        }
        /* Match boxes within Favorites grid (ensure they behave like channels there) */
        #Favorites .channel-box[id^="match-"]:not(.expanded) {
             grid-column: auto / span 1; width: auto; max-width: none; margin: 0;
        }


        /* Hide filtered-out boxes */
        .channel-box.hidden { display: none; }
        /* Hover effect */
        .channel-box:not(.expanded):hover { transform: translateY(-4px); box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4); border-color: var(--border-color-active); }

        /* --- Favorite Button (Star Icon) --- */
        .favorite-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
            z-index: 5; /* Above header content */
            color: var(--text-secondary); /* Default color (outline) */
            transition: color 0.2s ease;
        }
        .favorite-button svg {
            width: 20px;
            height: 20px;
            fill: none; /* Outline */
            stroke: currentColor; /* Use button color for stroke */
            stroke-width: 1.5;
        }
        .favorite-button:hover {
            color: var(--text-primary); /* Lighter on hover */
        }
        .favorite-button.is-favorite {
            color: var(--favorite-color); /* Gold/Yellow when favorite */
        }
        .favorite-button.is-favorite svg {
            fill: currentColor; /* Fill with button color when favorite */
            stroke-width: 0; /* No stroke when filled */
        }


        /* --- Channel Header --- */
        .channel-header { display: flex; align-items: center; justify-content: center; gap: 10px; text-align: center; min-height: 35px; cursor: pointer; }
        /* Matches Header Layout */
        .channel-box[id^="match-"] .channel-header { justify-content: center; gap: 0; text-align: center; }
        /* Logo styling */
        .match-logo { height: 40px; width: 40px; object-fit: contain; flex-shrink: 0; border-radius: 4px; display: inline-block; vertical-align: middle; }
        .channel-header img.match-logo { height: 40px; width: auto; object-fit: contain; }
        /* Title */
        .channel-header h3 { font-size: 1.1em; font-weight: 600; margin: 0; word-break: break-word; text-align: center; flex-grow: 0; flex-shrink: 1; }
        .channel-box[id^="match-"] .channel-header h3 { margin-left: 25px; margin-right: 25px; }
         .channel-box:not([id^="match-"]) .channel-header h3 { margin-left: 0; margin-right: 0; }

        /* Channel Info */
        .channel-info { font-size: 0.8em; color: var(--text-secondary); text-align: center; margin-top: 8px; margin-left: 0; margin-bottom: 0; font-weight: 500; cursor: pointer; display: block; }
        .channel-box:not([id^="match-"]) .channel-info { display: none; }
        .channel-info span { margin: 0 5px; }

        /* --- Expanded Channel Box --- */
        .channel-box.expanded {
            width: 100%; max-width: 1200px; margin: auto;
            position: relative; grid-column: auto / span 1; /* Default span */
            cursor: default; background: var(--bg-tertiary);
            padding-bottom: 20px; z-index: 10; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--accent-color); overflow: visible; display: block !important;
        }
        /* Column spanning for expanded boxes */
        @media (min-width: 768px) {
            .channel-grid.active:not(#Matches) .channel-box.expanded { grid-column: auto / span 2; }
        }
        @media (min-width: 1024px) {
             .channel-grid.active:not(#Matches) .channel-box.expanded { grid-column: auto / span 3; }
        }
        /* Expanded matches span full width */
        #ALL .channel-box[id^="match-"].expanded,
        #Matches .channel-box[id^="match-"].expanded {
             grid-column: 1 / -1; max-width: 1200px; margin: auto;
        }
        /* Non-clickable header/info when expanded */
        .channel-box.expanded .channel-header,
        .channel-box.expanded .channel-info { cursor: default; }

        /* --- Player Area --- */
        .iframe-container { margin-top: 18px; display: none; width: 100%; }
        .channel-box.expanded .iframe-container { display: block; }
        .player-area { position: relative; width: 100%; aspect-ratio: 16 / 9; background-color: #000; border-radius: 8px; overflow: hidden; margin-bottom: 18px; min-height: 200px; display: flex; justify-content: center; align-items: center; }
        .player-area iframe, .player-area video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; display: none; object-fit: contain; }
        .player-area iframe.active, .player-area video.active { display: block; }
        .player-message { color: var(--text-secondary); font-size: 0.9em; padding: 20px; text-align: center; display: none; }
        .player-message.visible { display: block; }
        .player-message strong { color: var(--text-primary); display: block; margin-bottom: 5px; }
        .player-message button { margin-top: 15px; }
        .loader { width: 40px; height: 40px; border-radius: 50%; border: 4px solid var(--border-color); border-top-color: var(--accent-color); animation: spin 1s linear infinite; display: none; }
        .loader.visible { display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @media (min-width: 768px) { .channel-box.expanded .player-area { min-height: 400px; max-height: 70vh; } }
        @media (min-width: 1024px) { .channel-box.expanded .player-area { min-height: 480px; } }

        /* --- Stream Buttons --- */
        .stream-buttons { text-align: center; margin-top: 15px; margin-bottom: 15px; }
        .stream-buttons div { margin-bottom: 10px; }
        .stream-buttons strong { color: var(--text-secondary); font-size: 0.85em; margin-right: 8px; font-weight: 600; text-transform: uppercase; }
        .stream-button { background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 7px 18px; border-radius: 20px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: all 0.2s ease; display: inline-block; margin: 4px; }
        .stream-button:hover { background: #4a4a4a; border-color: #5a5a5a; }
        .stream-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); font-weight: 600; }
        .try-next-button { background: var(--accent-color); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: background-color 0.2s ease; }
        .try-next-button:hover { background-color: #b80710; }

        /* --- Disclaimer inside Box --- */
        .box-disclaimer { font-size: 0.7em; color: #888; text-align: center; padding: 0 15px; margin-top: 10px; line-height: 1.4; display: none; }
        .channel-box.expanded .box-disclaimer { display: block; }

        /* --- Footer --- */
        footer { text-align: center; color: var(--text-secondary); font-size: 0.8em; padding: 20px 0; width: 100%; margin-top: 40px; }
        .footer-disclaimer { font-size: 0.75em; margin-top: 15px; padding: 0 20px; max-width: 800px; margin-left: auto; margin-right: auto; line-height: 1.5; color: #888; }

        /* --- Loading/Error States --- */
        .loading-message, .error-message { text-align: center; padding: 50px 20px; color: var(--text-secondary); font-size: 1em; font-weight: 500; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 767px) {
             .channel-grid { grid-template-columns: 1fr; }
             .channel-grid.active .channel-box.expanded { grid-column: auto / span 1; }
             .channel-box { padding: 15px; }
             .stream-button { padding: 6px 15px; font-size: 0.8em; }
             header img { max-width: 160px; }
             .tabs { gap: 10px; margin-bottom: 30px; }
             .tab-button { padding: 8px 15px; font-size: 0.85em; } /* Adjusted padding for icon */
             #Matches.channel-grid { max-width: 100%; }
             #Matches .channel-header { gap: 10px; }
             .match-logo, #Matches .channel-header img.match-logo { height: 32px; width: 32px; }
             .channel-info { font-size: 0.75em;}
             .channel-box[id^="match-"] .channel-header h3 { margin: 0 15px; }
             .favorite-button { top: 8px; right: 8px; } /* Adjust favorite button position */
             .favorite-button svg { width: 18px; height: 18px; }
        }
        @media (max-width: 480px) {
            .container { padding: 0 10px; }
            header img { max-width: 140px; }
            .tabs { gap: 8px; }
            .tab-button { padding: 7px 12px; } /* Adjusted padding */
            .channel-box { padding: 12px; }
            .channel-header h3 { font-size: 1em;}
            .channel-box[id^="match-"] .channel-header h3 { margin: 0 10px;}
            .match-logo, #Matches .channel-header img.match-logo { height: 30px; width: 30px; }
            .stream-buttons strong { display: block; margin-bottom: 5px; }
            .player-area { min-height: 200px; }
            #search-input { padding: 10px 15px; font-size: 0.95em; }
             .channel-info { font-size: 0.7em;}
             .footer-disclaimer { font-size: 0.7em; }
             .box-disclaimer { font-size: 0.65em; }
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <img src="ptvlogo.png" alt="PERAS TV Logo">
    </header>

    <div class="search-container">
        <input type="search" id="search-input" placeholder="Search channels or matches...">
    </div>

    <div class="tabs">
        <button class="tab-button" data-tab="Favorites">
             <svg class="tab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                 <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
             </svg>
        </button>
        <button class="tab-button" data-tab="ALL">ALL</button>
        <button class="tab-button" data-tab="PT">PT</button>
        <button class="tab-button" data-tab="UK">UK</button>
        <button class="tab-button" data-tab="ES">ES</button>
        <button class="tab-button" data-tab="Matches">Matches</button>
    </div>

    <div id="loadingMessage" class="loading-message">Loading channels...</div>
    <div id="fetchErrorMessage" class="error-message" style="display: none;"></div>

    <div id="Favorites" class="channel-grid"></div>
    <div id="ALL" class="channel-grid"></div>
    <div id="PT" class="channel-grid"></div>
    <div id="UK" class="channel-grid"></div>
    <div id="ES" class="channel-grid"></div>
    <div id="Matches" class="channel-grid"></div>

</div> <footer>
    <p id="lastUpdated"></p>
    <p class="footer-disclaimer">
        PerasTV Official DISCLAIMER : None of the videos are hosted by this
        site. Streams hosted from different sites, where sources available over
        Internet are embedded here. This site is not responsible for the
        legality of the content. For legal issues, please contact appropriate
        media file owners/hosters.
    </p>
</footer>

<script>
    /* --- JavaScript (No changes needed) --- */

    // --- Configuration Constants ---
    const CONFIG = {
        channelsUrl: "channels.json",
        matchesUrl: "matches.json",
        placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%23000000"/></svg>',
        searchDebounceMs: 300,
        lastTabKey: 'perasTvLastTab',
        favoritesKey: 'perasTvFavorites' // LocalStorage key for favorites
    };

    // --- DOM Element References ---
    const searchInput = document.getElementById('search-input');
    const tabsContainer = document.querySelector('.tabs');
    const channelGrids = document.querySelectorAll('.channel-grid');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const loadingMessage = document.getElementById('loadingMessage');
    const fetchErrorMessage = document.getElementById('fetchErrorMessage');

    // --- Application State ---
    let hlsInstance = null;
    let channelsData = {};
    let matchesData = [];
    let currentlyExpandedBox = null;
    let searchDebounceTimer = null;
    let activeTabId = 'ALL'; // Default active tab ID
    let favorites = []; // Array to hold favorite IDs

    // --- Disclaimer Text ---
    const DISCLAIMER_TEXT = `
        PerasTV Official DISCLAIMER : None of the videos are hosted by this
        site. Streams hosted from different sites, where sources available over
        Internet are embedded here. This site is not responsible for the
        legality of the content. For legal issues, please contact appropriate
        media file owners/hosters.
    `;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadFavorites(); // Load favorites from localStorage first
        setupEventListeners();
        updateTimestamp();
        loadData();
    });

    // --- Load Favorites from LocalStorage ---
    function loadFavorites() {
        const storedFavorites = localStorage.getItem(CONFIG.favoritesKey);
        if (storedFavorites) {
            try {
                favorites = JSON.parse(storedFavorites);
                if (!Array.isArray(favorites)) { // Basic validation
                    favorites = [];
                }
            } catch (e) {
                console.error("Error parsing favorites from localStorage:", e);
                favorites = [];
            }
        } else {
            favorites = [];
        }
        console.log("Loaded favorites:", favorites);
    }

    // --- Save Favorites to LocalStorage ---
    function saveFavorites() {
        try {
            localStorage.setItem(CONFIG.favoritesKey, JSON.stringify(favorites));
            console.log("Saved favorites:", favorites);
        } catch (e) {
            console.error("Error saving favorites to localStorage:", e);
        }
    }

    // --- Toggle Favorite Status ---
    function toggleFavorite(itemId, starButton) {
        const index = favorites.indexOf(itemId);
        if (index > -1) {
            // Item is favorite, remove it
            favorites.splice(index, 1);
            starButton.classList.remove('is-favorite');
            starButton.setAttribute('aria-pressed', 'false'); // Accessibility
        } else {
            // Item is not favorite, add it
            favorites.push(itemId);
            starButton.classList.add('is-favorite');
            starButton.setAttribute('aria-pressed', 'true'); // Accessibility
        }
        saveFavorites(); // Save updated list to localStorage

        // Re-render the favorites tab if it's currently active
        if (activeTabId === 'Favorites') {
            renderFavoritesTab();
        } else {
             // If another tab is active, ensure the star state is updated on the corresponding
             // box in the main tabs if it exists (e.g., toggling fav from ALL tab)
             const otherBoxStar = document.querySelector(`.channel-box#${itemId} .favorite-button`);
             if (otherBoxStar && otherBoxStar !== starButton) {
                 otherBoxStar.classList.toggle('is-favorite', index === -1); // Add if newly favorited, remove if unfavorited
                 otherBoxStar.setAttribute('aria-pressed', index === -1 ? 'true' : 'false');
             }
        }
    }


    // --- Event Listener Setup ---
    function setupEventListeners() {
        // Tabs
        tabsContainer.addEventListener('click', (event) => {
            const button = event.target.closest('.tab-button');
            if (button) {
                showTab(button.dataset.tab);
            }
        });

        // Search Input (Debounced)
        const debouncedFilter = debounce((term) => {
            filterChannels(term);
        }, CONFIG.searchDebounceMs);

        searchInput.addEventListener('input', (event) => {
            debouncedFilter(event.target.value);
        });

        // Close expanded box with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && currentlyExpandedBox) {
                 toggleExpansion(currentlyExpandedBox);
            }
        });
        // Note: Favorite button listeners are added in addChannelBoxEventListeners
    }

    // --- Data Fetching & Initial Rendering ---
    async function loadData() {
        loadingMessage.style.display = 'block';
        fetchErrorMessage.style.display = 'none';
        try {
            const cacheBuster = `?t=${Date.now()}`;
            const [channelsRes, matchesRes] = await Promise.all([
                fetch(CONFIG.channelsUrl + cacheBuster),
                fetch(CONFIG.matchesUrl + cacheBuster)
            ]);

            if (!channelsRes.ok || !matchesRes.ok) {
                throw new Error(`Failed to load data (Channels: ${channelsRes.status}, Matches: ${matchesRes.status})`);
            }

            channelsData = await channelsRes.json();
            matchesData = await matchesRes.json();

            renderAllGrids(); // Render content into ALL grids (including Favorites)
            loadingMessage.style.display = 'none';

            // Restore last tab preference or default to ALL
            const lastTab = localStorage.getItem(CONFIG.lastTabKey) || 'ALL';
            showTab(lastTab);

        } catch (error) {
            console.error("Failed to load channel or match data:", error);
            loadingMessage.style.display = 'none';
            fetchErrorMessage.textContent = `Error loading data: ${error.message}. Please try refreshing.`;
            fetchErrorMessage.style.display = 'block';
        }
    }

    // --- Rendering Functions ---
    // Renamed and updated to render all grids including Favorites
    function renderAllGrids() {
        renderSpecificGrid('PT', channelsData.PT || []);
        renderSpecificGrid('UK', channelsData.UK || []);
        renderSpecificGrid('ES', channelsData.ES || []);
        renderSpecificGrid('Matches', matchesData || []);
        renderAllTab(); // Populate the ALL tab
        renderFavoritesTab(); // Populate the Favorites tab
        addChannelBoxEventListeners(); // Add listeners AFTER all grids are populated
    }

    // Renders items for a specific grid (PT, UK, ES, Matches)
    function renderSpecificGrid(gridId, items) {
        const grid = document.getElementById(gridId);
        if (!grid) return;
        grid.innerHTML = ''; // Clear grid

        if (!items || items.length === 0) {
            grid.innerHTML = `<p class="loading-message">No ${gridId === 'Matches' ? 'matches' : 'channels'} available.</p>`;
            return;
        }

        items.forEach((item, index) => {
            let uniqueId, box;
            if (gridId === 'Matches') {
                uniqueId = `match-${index}`;
                box = createMatchBoxElement(item, uniqueId);
            } else {
                uniqueId = `${gridId}-channel-${index}`;
                box = createChannelBoxElement(item, uniqueId);
            }
            grid.appendChild(box);
        });
    }

    // Populates the ALL tab
    function renderAllTab() {
        const allGrid = document.getElementById('ALL');
        if (!allGrid) return;
        allGrid.innerHTML = ''; // Clear grid

        // 1. Matches
        const matches = matchesData || [];
        if (matches.length > 0) {
            matches.forEach((match, index) => {
                const uniqueId = `match-${index}`;
                const box = createMatchBoxElement(match, uniqueId);
                allGrid.appendChild(box);
            });
        }

        // 2. PT Channels
        const ptChannels = channelsData.PT || [];
        if (ptChannels.length > 0) {
             ptChannels.forEach((channel, index) => {
                const uniqueId = `PT-channel-${index}`;
                const box = createChannelBoxElement(channel, uniqueId);
                allGrid.appendChild(box);
            });
        }

        // 3. UK Channels
        const ukChannels = channelsData.UK || [];
         if (ukChannels.length > 0) {
             ukChannels.forEach((channel, index) => {
                const uniqueId = `UK-channel-${index}`;
                const box = createChannelBoxElement(channel, uniqueId);
                allGrid.appendChild(box);
            });
        }

        // 4. ES Channels
        const esChannels = channelsData.ES || [];
         if (esChannels.length > 0) {
             esChannels.forEach((channel, index) => {
                const uniqueId = `ES-channel-${index}`;
                const box = createChannelBoxElement(channel, uniqueId);
                allGrid.appendChild(box);
            });
        }
         // If ALL tab is empty after trying all sections
         if (allGrid.children.length === 0) {
             allGrid.innerHTML = '<p class="loading-message">No content available.</p>';
         }
    }

    // Renders the Favorites tab based on the 'favorites' array
    function renderFavoritesTab() {
        const favGrid = document.getElementById('Favorites');
        if (!favGrid) return;
        favGrid.innerHTML = ''; // Clear previous favorites

        if (favorites.length === 0) {
            favGrid.innerHTML = '<p class="loading-message">No favorites added yet. Click the star icon on any channel or match.</p>';
            return;
        }

        // Create boxes for favorites in the original order they appear in the data
        const favoriteBoxes = [];

        // Check matches
        matchesData.forEach((match, index) => {
            const uniqueId = `match-${index}`;
            if (favorites.includes(uniqueId)) {
                favoriteBoxes.push(createMatchBoxElement(match, uniqueId));
            }
        });

        // Check channels (PT, UK, ES)
        ['PT', 'UK', 'ES'].forEach(prefix => {
            (channelsData[prefix] || []).forEach((channel, index) => {
                const uniqueId = `${prefix}-channel-${index}`;
                if (favorites.includes(uniqueId)) {
                    favoriteBoxes.push(createChannelBoxElement(channel, uniqueId));
                }
            });
        });

        // Append all found favorite boxes to the grid
        favoriteBoxes.forEach(box => favGrid.appendChild(box));

        // Re-add listeners to the newly created boxes in the Favorites tab
        addChannelBoxEventListeners();
    }


    // --- Element Creation ---
    function createChannelBoxElement(channel, uniqueId) {
        const { name, srcs = [] } = channel;
        const box = document.createElement('div');
        box.className = 'channel-box';
        box.dataset.channelName = name;
        box.dataset.sources = JSON.stringify(srcs);
        box.id = uniqueId;

        const isFavorite = favorites.includes(uniqueId); // Check if it's a favorite

        box.innerHTML = `
            <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="Toggle Favorite" aria-pressed="${isFavorite}">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                </svg>
            </button>
            <div class="channel-header" id="${uniqueId}-header" aria-expanded="false" aria-controls="${uniqueId}-player-container">
                <h3>${name}</h3>
            </div>
            <div class="channel-info"></div>
            <div class="iframe-container" id="${uniqueId}-player-container" role="region" aria-labelledby="${uniqueId}-header">
                <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message"></div>
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons"></div>
                <p class="box-disclaimer">${DISCLAIMER_TEXT}</p>
            </div>
        `;
        return box;
    }
     function createMatchBoxElement(match, uniqueId) {
        const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = match;
        const box = document.createElement('div');
        box.className = 'channel-box';
        const allSources = { pt, uk, es };
        const matchTitle = `${team1} vs ${team2}`;
        box.dataset.channelName = matchTitle;
        box.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase();
        box.dataset.sources = JSON.stringify(allSources);
        box.id = uniqueId;

        const isFavorite = favorites.includes(uniqueId); // Check if it's a favorite

        box.innerHTML = `
             <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="Toggle Favorite" aria-pressed="${isFavorite}">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                     <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                 </svg>
             </button>
            <div class="channel-header" id="${uniqueId}-header" aria-expanded="false" aria-controls="${uniqueId}-player-container">
                 ${logo1 ? `<img src="${logo1}" alt="${team1} logo" class="match-logo">` : '<span class="match-logo"></span>'}
                 <h3>${matchTitle}</h3>
                 ${logo2 ? `<img src="${logo2}" alt="${team2} logo" class="match-logo">` : '<span class="match-logo"></span>'}
            </div>
            <div class="channel-info">
                ${league ? `<span>${league}</span>` : ''}
                ${league && time ? '<span>|</span>' : ''}
                ${time ? `<span>${time}</span>` : ''}
            </div>
             <div class="iframe-container" id="${uniqueId}-player-container" role="region" aria-labelledby="${uniqueId}-header">
                 <div class="player-area">
                    <div class="loader"></div>
                    <div class="player-message"></div>
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons"></div>
                <p class="box-disclaimer">${DISCLAIMER_TEXT}</p>
            </div>
        `;
        box.querySelectorAll('img.match-logo').forEach(img => {
            img.onerror = () => { img.style.display = 'none'; };
        });
        return box;
    }
     function createStreamButtonWrapper(label, url, contextBox) {
        const button = document.createElement('button');
        button.className = 'stream-button';
        button.textContent = label;
        button.dataset.streamUrl = url;
        button.onclick = (e) => {
            e.stopPropagation();
            changeStream(button, url, contextBox);
        };
        return button;
    }


    // --- Event Listener Setup for Channel Boxes ---
    function addChannelBoxEventListeners() {
         document.querySelectorAll('.channel-box').forEach(box => {
            // Prevent adding listeners multiple times
            if (box.dataset.listenerAdded === 'true') return;

            const header = box.querySelector('.channel-header');
            const info = box.querySelector('.channel-info');
            const favButton = box.querySelector('.favorite-button');

            // Toggle Expansion Listener
            const toggleHandler = (event) => {
                 // Ensure click is not on the favorite button or stream button
                 if (!event.target.closest('.favorite-button') && !event.target.closest('.stream-button')) {
                    toggleExpansion(box);
                 }
            };
            if (header) header.addEventListener('click', toggleHandler);
            if (info && getComputedStyle(info).display !== 'none') {
                 info.addEventListener('click', toggleHandler);
            }

            // Favorite Button Listener
            if (favButton) {
                favButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent triggering expansion
                    toggleFavorite(box.id, favButton);
                });
            }

            // Click listener on the box itself (less likely needed now)
            box.addEventListener('click', (event) => {
                const isExpanded = box.classList.contains('expanded');
                const isClickOnPlayerArea = event.target.closest('.iframe-container');
                const isClickOnHeaderOrInfo = event.target.closest('.channel-header') || event.target.closest('.channel-info');
                const isClickOnFavButton = event.target.closest('.favorite-button');

                if (!isExpanded && !isClickOnPlayerArea && !isClickOnHeaderOrInfo && !isClickOnFavButton) {
                   // Potentially toggle here if needed
                }
            });
            box.dataset.listenerAdded = 'true'; // Mark listeners as added
        });
    }

    // --- Tab Management ---
    function showTab(tabId) {
        activeTabId = tabId;

        tabsContainer.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });

        channelGrids.forEach(grid => {
            grid.classList.toggle('active', grid.id === tabId);
        });

        if (currentlyExpandedBox) {
            collapseBox(currentlyExpandedBox);
        }

        localStorage.setItem(CONFIG.lastTabKey, tabId);

        // If switching to Favorites tab, ensure it's up-to-date
        if (tabId === 'Favorites') {
            renderFavoritesTab();
        }

        filterChannels(searchInput.value); // Re-apply filter after tab switch
    }

    // --- Search Filtering ---
    function filterChannels(searchTerm) {
        const term = searchTerm.toLowerCase().trim();
        const isSearching = term !== '';

        // Determine which boxes to iterate over based on active tab and search state
        let boxesToFilterSelector;
        if (isSearching) {
            // Global search: check all boxes
            boxesToFilterSelector = '.channel-box';
        } else {
            // No search: only check boxes within the active tab's grid
            boxesToFilterSelector = `#${activeTabId} .channel-box`;
        }
        const boxesToFilter = document.querySelectorAll(boxesToFilterSelector);


        boxesToFilter.forEach(box => {
            const channelName = box.dataset.channelName?.toLowerCase() || '';
            const searchTerms = box.dataset.searchTerms?.toLowerCase() || '';
            const isMatch = channelName.includes(term) || searchTerms.includes(term);

            let isVisible = false;
            if (!isSearching) {
                // If not searching, the box is visible by default (already filtered by tab selector)
                isVisible = true;
            } else {
                // If searching, visibility depends on matching the term
                isVisible = isMatch;
            }

            // Hide or show box
            if (box.classList.contains('expanded') && isSearching) {
                 box.classList.remove('hidden'); // Keep expanded box visible during search
            } else {
                 box.classList.toggle('hidden', !isVisible);
            }

            // Collapse box if hidden (only when search is cleared)
            if (!isVisible && box.classList.contains('expanded') && !isSearching) {
                 collapseBox(box);
            }
        });

         // Show/Hide grids based on visible children during active search
         channelGrids.forEach(grid => {
            if (isSearching) {
                // Check if *any* box within this grid matches the search
                const hasVisibleChildren = Array.from(grid.querySelectorAll('.channel-box')).some(box => {
                     const channelName = box.dataset.channelName?.toLowerCase() || '';
                     const searchTerms = box.dataset.searchTerms?.toLowerCase() || '';
                     return channelName.includes(term) || searchTerms.includes(term);
                 });
                grid.classList.toggle('active', hasVisibleChildren); // Show if it has results
            } else {
                 grid.classList.toggle('active', grid.id === activeTabId); // Standard tab visibility
            }
         });
    }


    // --- Channel Box Expansion ---
    function toggleExpansion(boxToToggle) {
        const isExpanding = !boxToToggle.classList.contains('expanded');
        const header = boxToToggle.querySelector('.channel-header');

        if (isExpanding && currentlyExpandedBox && currentlyExpandedBox !== boxToToggle) {
            collapseBox(currentlyExpandedBox);
        }

        if (isExpanding) {
            expandBox(boxToToggle);
            if(header) header.setAttribute('aria-expanded', 'true');
        } else {
            collapseBox(boxToToggle);
             if(header) header.setAttribute('aria-expanded', 'false');
        }
    }
    function expandBox(box) {
        box.classList.add('expanded');
        box.classList.remove('hidden'); // Ensure visible
        currentlyExpandedBox = box;
        populateAndLoadFirstStream(box);
        box.style.gridColumn = ''; // Reset inline style (CSS rules handle span)

        setTimeout(() => {
             box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
             const firstButton = box.querySelector('.stream-button');
             if (firstButton) {
                 setTimeout(() => firstButton.focus({ preventScroll: true }), 50);
             }
        }, 150);
    }
    function collapseBox(box) {
        box.classList.remove('expanded');
        box.style.gridColumn = ''; // Reset grid span override

        if (currentlyExpandedBox === box) {
            currentlyExpandedBox = null;
        }
        clearPlayerInBox(box);
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) streamButtonsDiv.innerHTML = '';
        const header = box.querySelector('.channel-header');
        if(header) {
            header.setAttribute('aria-expanded', 'false');
        }
        // Re-apply filter only if search is currently empty
        if(searchInput.value === '') {
            filterChannels('');
        }
    }

    function populateAndLoadFirstStream(box) {
        const sourcesData = box.dataset.sources;
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (!sourcesData || !streamButtonsDiv) return;

        streamButtonsDiv.innerHTML = '';
        let firstUrl = null;
        let firstButtonElement = null;

        try {
            const sources = JSON.parse(sourcesData);
            if (Array.isArray(sources)) { // Handle channels
                if (sources.length > 0) {
                    sources.forEach((src, idx) => {
                        const url = typeof src === 'object' && src.url ? src.url : src;
                        const label = typeof src === 'object' && src.label ? src.label : `Source ${idx + 1}`;
                        if (!firstUrl) firstUrl = url;
                        const button = createStreamButtonWrapper(label, url, box);
                        if (!firstButtonElement) firstButtonElement = button;
                        streamButtonsDiv.appendChild(button);
                    });
                } else { noStreamsAvailable(streamButtonsDiv); }
            } else { // Handle matches
                let streamCount = 0;
                Object.entries(sources).forEach(([lang, langSources]) => {
                    if (langSources && langSources.length > 0) {
                        const langDiv = document.createElement('div');
                        const strong = document.createElement('strong');
                        strong.textContent = `${lang.toUpperCase()}:`;
                        langDiv.appendChild(strong);
                        langSources.forEach((src, idx) => {
                            const url = typeof src === 'object' && src.url ? src.url : src;
                            const label = typeof src === 'object' && src.label ? src.label : `${idx + 1}`;
                            if (!firstUrl) firstUrl = url;
                            const button = createStreamButtonWrapper(label, url, box);
                             if (!firstButtonElement) firstButtonElement = button;
                            langDiv.appendChild(button);
                            streamCount++;
                        });
                        streamButtonsDiv.appendChild(langDiv);
                    }
                });
                 if (streamCount === 0) { noStreamsAvailable(streamButtonsDiv); }
            }

            if (firstUrl && firstButtonElement) {
                 changeStream(firstButtonElement, firstUrl, box);
            } else {
                clearPlayerInBox(box);
            }
        } catch (e) {
            console.error("Failed to parse sources data for box:", box.id, e);
            streamButtonsDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">Error loading stream data.</p>';
             clearPlayerInBox(box);
        }
    }
     function noStreamsAvailable(container) {
         container.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">No streams available.</p>';
    }


    // --- Stream Handling ---
    function changeStream(clickedButton, url, contextBox) {
        console.log(`Attempting to load stream in box ${contextBox.id}: ${url}`);
        const playerArea = contextBox.querySelector('.player-area');
        const loader = playerArea.querySelector('.loader');
        const messageDiv = playerArea.querySelector('.player-message');

        clearPlayerInBox(contextBox);
        messageDiv.classList.remove('visible');
        loader.classList.add('visible');

        const streamButtonsDiv = contextBox.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
             streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
        if (clickedButton) {
            clickedButton.classList.add('active');
        }

        const iframe = playerArea.querySelector('iframe');
        const video = playerArea.querySelector('video');

        if (!iframe || !video) {
            console.error("Could not find player elements in context box.");
            loader.classList.remove('visible');
            showPlayerMessage(playerArea, `<strong>Error:</strong> Player elements not found.`, false);
            return;
        }

        if (url && typeof url === 'string') {
             if (url.toLowerCase().endsWith('.m3u8')) {
                loadHlsStream(url, video, playerArea);
            } else {
                loadIframeStream(url, iframe, playerArea);
            }
        } else {
            console.error("Invalid stream URL:", url);
            loader.classList.remove('visible');
            showPlayerMessage(playerArea, `<strong>Error:</strong> Invalid stream URL provided.`, false);
            iframe.src = 'about:blank'; iframe.classList.remove('active');
            video.pause(); video.removeAttribute('src'); video.load(); video.classList.remove('active'); video.poster = '';
        }
    }
     function clearPlayerInBox(box) {
        if (!box) return;
        if (hlsInstance && hlsInstance.media === box.querySelector('video')) {
            console.log("Destroying HLS instance for box:", box.id);
            hlsInstance.destroy();
            hlsInstance = null;
        }
        const playerArea = box.querySelector('.player-area');
        if (!playerArea) return;

        const iframe = playerArea.querySelector('iframe');
        const video = playerArea.querySelector('video');
        const loader = playerArea.querySelector('.loader');
        const messageDiv = playerArea.querySelector('.player-message');

        if (iframe) { iframe.src = 'about:blank'; iframe.classList.remove('active'); }
        if (video) {
             const newVideo = video.cloneNode(true);
             video.parentNode.replaceChild(newVideo, video);
             newVideo.pause(); newVideo.removeAttribute('src'); newVideo.load();
             newVideo.classList.remove('active'); newVideo.poster = '';
        }
        if (loader) loader.classList.remove('visible');
        if (messageDiv) messageDiv.classList.remove('visible');

        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
    }
    function showPlayerMessage(playerArea, messageHtml, showTryNext, failedUrl = null, contextBox = null) {
        const messageDiv = playerArea.querySelector('.player-message');
        const loader = playerArea.querySelector('.loader');
        const video = playerArea.querySelector('video');
        const iframe = playerArea.querySelector('iframe');

        if (!messageDiv || !loader) return;

        if (video) video.classList.remove('active');
        if (iframe) iframe.classList.remove('active');
        loader.classList.remove('visible');

        messageDiv.innerHTML = messageHtml;
        if (showTryNext && failedUrl && contextBox) {
            const nextButton = findNextStreamButton(failedUrl, contextBox);
            if (nextButton) {
                const tryNextBtn = document.createElement('button');
                tryNextBtn.className = 'try-next-button';
                tryNextBtn.textContent = 'Try Next Source';
                tryNextBtn.onclick = (e) => {
                    e.stopPropagation();
                    nextButton.click();
                };
                messageDiv.appendChild(tryNextBtn);
            }
        }
        messageDiv.classList.add('visible');
    }
    function findNextStreamButton(failedUrl, contextBox) {
        const buttons = contextBox.querySelectorAll('.stream-button');
        let foundCurrent = false;
        for (let i = 0; i < buttons.length; i++) {
            if (buttons[i].dataset.streamUrl === failedUrl) {
                foundCurrent = true;
            } else if (foundCurrent) {
                return buttons[i];
            }
        }
        return null;
    }
    function loadHlsStream(url, videoElement, playerArea) {
        const currentBox = videoElement.closest('.channel-box');
        videoElement.poster = CONFIG.placeholderImage;

        if (Hls.isSupported()) {
            console.log("HLS.js supported. Initializing...");
             if (hlsInstance && hlsInstance.media === videoElement) {
                 hlsInstance.destroy();
                 hlsInstance = null;
             } else if (hlsInstance && hlsInstance.media !== videoElement) {
                 // Keep instance for other box
             }

            hlsInstance = new Hls({ /* Config */ });

            hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                console.error('HLS.js Error:', event, data);
                 if (data.fatal && hlsInstance && videoElement === hlsInstance.media) {
                     let userMessage = `<strong>Stream Error</strong> (${data.details}).`;
                     if (data.type === Hls.ErrorTypes.NETWORK_ERROR) userMessage = `<strong>Network Error</strong> loading stream (${data.details}). Check connection or try another source.`;
                     else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) userMessage = `<strong>Media Playback Error</strong> (${data.details}).`;
                     else userMessage = `<strong>Stream Error</strong> (${data.type} - ${data.details}).`;
                     showPlayerMessage(playerArea, userMessage, true, url, currentBox);
                     hlsInstance.destroy(); hlsInstance = null;
                     videoElement.classList.remove('active'); videoElement.poster = '';
                 } else if (!data.fatal) { console.warn("Non-fatal HLS error:", data.details); }
            });

            hlsInstance.loadSource(url);
            hlsInstance.attachMedia(videoElement);

            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                 if (hlsInstance && videoElement === hlsInstance.media) {
                    console.log("HLS Manifest parsed...");
                    playerArea.querySelector('.loader').classList.remove('visible');
                    videoElement.classList.add('active');
                    videoElement.muted = true;
                    videoElement.play().catch(e => {
                         console.error("HLS.js play failed:", e);
                         if (e.name === 'NotAllowedError') showPlayerMessage(playerArea, `<strong>Playback Paused</strong><br>Browser requires interaction. Click the play button.`, false);
                         else showPlayerMessage(playerArea, `<strong>Playback Error</strong><br>${e.message}`, true, url, currentBox);
                         videoElement.classList.remove('active'); playerArea.querySelector('.loader').classList.remove('visible');
                    });
                 }
            });

        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            console.log("Using native HLS support.");
            const newVideo = videoElement.cloneNode(true);
            videoElement.parentNode.replaceChild(newVideo, videoElement);
            videoElement = newVideo;
            videoElement.src = url;
            videoElement.oncanplay = () => {
                 if (videoElement.getAttribute('src') === url) {
                    playerArea.querySelector('.loader').classList.remove('visible');
                    videoElement.classList.add('active');
                    videoElement.muted = true;
                    videoElement.play().catch(e => {
                        console.error("Native HLS play failed:", e);
                        if (e.name === 'NotAllowedError') showPlayerMessage(playerArea, `<strong>Playback Paused</strong><br>Browser requires interaction. Click play.`, false);
                        else showPlayerMessage(playerArea, `<strong>Native HLS Playback Error</strong><br>${e.message}`, true, url, currentBox);
                         videoElement.classList.remove('active'); playerArea.querySelector('.loader').classList.remove('visible');
                    });
                 }
            };
            videoElement.onerror = () => {
                 if (videoElement.getAttribute('src') === url) {
                     console.error("Native HLS playback error.");
                     showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>Could not load native HLS stream.`, true, url, currentBox);
                     videoElement.classList.remove('active'); videoElement.poster = ''; playerArea.querySelector('.loader').classList.remove('visible');
                 } else { console.log("Ignoring native HLS error for a different src."); }
            };
             videoElement.load();
        } else {
            console.error("HLS is not supported by this browser.");
            showPlayerMessage(playerArea, `<strong>Error:</strong> HLS playback is not supported.`, false);
            videoElement.classList.remove('active'); videoElement.poster = ''; playerArea.querySelector('.loader').classList.remove('visible');
        }
    }
    function loadIframeStream(url, iframeElement, playerArea) {
        const currentBox = iframeElement.closest('.channel-box');
        console.log("Loading iframe stream...");
        let iframeLoadTimeout = setTimeout(() => {
             console.warn("Iframe load timeout reached for:", url);
             try {
                  if (!iframeElement.contentDocument || iframeElement.contentDocument.URL === 'about:blank' || iframeElement.getAttribute('src') !== url ) throw new Error("Iframe content not accessible or didn't load.");
                  console.log("Iframe seems loaded despite timeout (likely cross-origin).");
                   playerArea.querySelector('.loader').classList.remove('visible'); iframeElement.classList.add('active');
             } catch (e) {
                  console.error("Iframe failed to load within timeout.");
                  showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>The source took too long to load or might be blocked.`, true, url, currentBox);
                  iframeElement.classList.remove('active'); iframeElement.src = 'about:blank'; playerArea.querySelector('.loader').classList.remove('visible');
             }
        }, 15000);
        iframeElement.onload = () => {
            clearTimeout(iframeLoadTimeout);
            if (iframeElement.getAttribute('src') === url) {
                 console.log("Iframe onload event fired for:", url);
                 playerArea.querySelector('.loader').classList.remove('visible'); iframeElement.classList.add('active');
             } else { console.log("Iframe onload fired for a different src, ignoring."); }
        };
        iframeElement.onerror = () => {
             clearTimeout(iframeLoadTimeout);
             if (iframeElement.getAttribute('src') === url) {
                 console.error("Iframe onerror event fired for:", url);
                 showPlayerMessage(playerArea, `<strong>Stream Error</strong><br>Failed to load iframe source.`, true, url, currentBox);
                 iframeElement.classList.remove('active'); iframeElement.src = 'about:blank'; playerArea.querySelector('.loader').classList.remove('visible');
             } else { console.log("Iframe onerror fired for a different src, ignoring."); }
        };
        iframeElement.src = url;
    }

    // --- Utility Functions ---
    function updateTimestamp() {
        const now = new Date();
        lastUpdatedEl.textContent = `Updated: ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
    }
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => { clearTimeout(timeout); func(...args); };
            clearTimeout(timeout); timeout = setTimeout(later, wait);
        };
    }

</script>

</body>
</html>
