<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">

    <link rel="preconnect" href="https://playmatch.live">
    <link rel="preconnect" href="https://thedaddy.to">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- Password Protection Styles --- */
        #password-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-primary); z-index: 1000; display: flex;
            justify-content: center; align-items: center; flex-direction: column; padding: 20px;
        }
        #password-form {
            background-color: var(--bg-secondary); padding: 30px 40px; border-radius: 10px;
            box-shadow: 0 5px 15px var(--shadow-color); text-align: center;
        }
        #password-form label { display: block; margin-bottom: 10px; color: var(--text-primary); font-weight: 500; }
        #password-input {
            padding: 10px 15px; font-size: 1em; border-radius: 5px; border: 1px solid var(--border-color);
            background-color: var(--bg-tertiary); color: var(--text-primary); margin-bottom: 20px;
            width: 100%; max-width: 250px;
        }
         #password-input:focus { outline: none; border-color: var(--border-color-active); }
        #password-submit {
            padding: 10px 25px; font-size: 1em; border-radius: 5px; border: none;
            background-color: var(--accent-color); color: white; cursor: pointer; transition: background-color 0.2s ease;
        }
        #password-submit:hover { background-color: #c40812; } /* Consider variable */
        #password-error { color: var(--error-color); margin-top: 15px; font-size: 0.9em; min-height: 1.2em; }
        /* Hide main content initially */
        .main-container { display: none; }
        /* Initially hide the password overlay */
        #password-overlay.hidden { display: none; }
        /* Fallback message div */
        #devtools-detected-message { display: none; }
        /* Style for the clickable logo link */
        #logo-link { display: inline-block; line-height: 0; text-decoration: none; }
        #logo-link:focus-visible { outline: 2px solid var(--accent-color); outline-offset: 3px; border-radius: 4px; }

        /* Ensure body transition applies */
        body { transition: background-color 0.3s ease, color 0.3s ease; }

        /* Ensure grids have content visibility */
        .channel-grid { contain: content; }
    </style>
    </head>
<body data-theme="dark"> <div id="devtools-detected-message"></div>

<div id="password-overlay" class="hidden">
    <form id="password-form">
        <label for="password-input">Enter Access Key</label>
        <input type="password" id="password-input" required>
        <button type="submit" id="password-submit">Enter</button>
        <p id="password-error"></p>
    </form>
</div>

<div class="main-container">
    <div class="container">
        <header>
            <button id="theme-toggle-button" aria-label="Switch to Light Theme" title="Switch to Light Theme">
                </button>

            <a href="index.html" id="logo-link" aria-label="Go to ALL tab / Home" role="button" tabindex="0">
                <img src="ptvlogo.png" alt="PERAS TV Logo">
            </a>

            <div class="settings-container">
                <button id="settings-button" aria-label="Open Settings Menu" aria-haspopup="true" aria-expanded="false" title="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" fill="none">
                        <line x1="4" y1="6" x2="20" y2="6"></line>
                        <line x1="4" y1="12" x2="20" y2="12"></line>
                        <line x1="4" y1="18" x2="20" y2="18"></line>
                    </svg>
                </button>
                <div id="settings-panel" role="menu">
                    <div class="settings-panel-item" role="menuitemcheckbox" aria-checked="false">
                        <label for="open-in-new-tab-toggle">Open source in new tab</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="open-in-new-tab-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="settings-panel-item" role="menuitemcheckbox" aria-checked="false">
                        <label for="open-in-player-page-toggle">Open player page in new tab</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="open-in-player-page-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </header>

        <div class="search-container">
            <input type="search" id="search-input" placeholder="Search channels or matches..." aria-label="Search channels or matches">
        </div>

        <div class="tabs" role="tablist" aria-label="Content Categories">
            <button class="tab-button" data-tab="Favorites" role="tab" aria-controls="Favorites" aria-selected="false" aria-label="Favorites">
                 <svg class="tab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                     <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                 </svg>
                 </button>
            <button class="tab-button" data-tab="ALL" role="tab" aria-controls="ALL" aria-selected="false">ALL</button>
            <button class="tab-button" data-tab="PT" role="tab" aria-controls="PT" aria-selected="false">PT</button>
            <button class="tab-button" data-tab="UK" role="tab" aria-controls="UK" aria-selected="false">UK</button>
            <button class="tab-button" data-tab="ES" role="tab" aria-controls="ES" aria-selected="false">ES</button>
            <button class="tab-button" data-tab="Matches" role="tab" aria-controls="Matches" aria-selected="false">Matches</button>
        </div>

        <div id="loadingMessage" class="status-message loading" role="status" style="display: none;">Loading channels...</div>
        <div id="fetchErrorMessage" class="status-message error" role="alert" style="display: none;"></div>

        <div id="Favorites" class="channel-grid" role="tabpanel" aria-labelledby="tab-Favorites" tabindex="-1"></div>
        <div id="ALL" class="channel-grid active" role="tabpanel" aria-labelledby="tab-ALL" tabindex="0"></div>
        <div id="PT" class="channel-grid" role="tabpanel" aria-labelledby="tab-PT" tabindex="-1"></div>
        <div id="UK" class="channel-grid" role="tabpanel" aria-labelledby="tab-UK" tabindex="-1"></div>
        <div id="ES" class="channel-grid" role="tabpanel" aria-labelledby="tab-ES" tabindex="-1"></div>
        <div id="Matches" class="channel-grid" role="tabpanel" aria-labelledby="tab-Matches" tabindex="-1"></div>

    </div>

    <footer>
        <p id="lastUpdated">Updated: Fetching time...</p>
        <p class="footer-disclaimer">
            <strong>Disclaimer:</strong> PerasTV does not host any video content. All streams are embedded from external, publicly available sources found on the internet. We are not responsible for the legality, accuracy, or quality of the content provided by these third-party sites. Users are advised to respect copyright laws and use this service responsibly. Stream availability is not guaranteed.
        </p>
    </footer>

    <button id="scroll-to-top-btn" title="Go to top" aria-label="Scroll to top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 4l-8 8h5v8h6v-8h5z"/>
        </svg>
    </button>

</div>
<script>
    // --- Console Access Deterrents (Run Immediately) ---
    function setupConsoleDeterrents() {
        document.addEventListener('contextmenu', (event) => event.preventDefault());
        document.addEventListener('keydown', (event) => {
            if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) || (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                event.preventDefault();
            }
        });
        console.log("Basic console access deterrents initialized.");
    }
    setupConsoleDeterrents();

    // --- Authentication ---
    const PERSONAL_USE_B64 = "cHR2";
    const AUTH_KEY = 'perasTvAuthenticated';

    const passwordOverlay = document.getElementById('password-overlay');
    const passwordForm = document.getElementById('password-form');
    const passwordInput = document.getElementById('password-input');
    const passwordError = document.getElementById('password-error');
    const mainContainer = document.querySelector('.main-container');

    // Authentication Check
    if (sessionStorage.getItem(AUTH_KEY) === 'true') {
        passwordOverlay.classList.add('hidden');
        mainContainer.style.display = 'block';
        initializeApp();
    } else {
        if (typeof PERSONAL_USE_B64 === 'undefined' || PERSONAL_USE_B64 === "PASTE_YOUR_BASE64_PASSWORD_HERE" || PERSONAL_USE_B64 === "") {
             console.error("ERROR: PERSONAL_USE_B64 is not set correctly.");
             passwordOverlay.innerHTML = '<p style="color:var(--error-color); text-align:center;">Configuration Error: Access key not set.</p>';
             passwordOverlay.classList.remove('hidden');
        } else {
            passwordOverlay.classList.remove('hidden');
            passwordInput.focus();
            passwordForm.addEventListener('submit', (event) => {
                event.preventDefault();
                const enteredValue = passwordInput.value;
                let correctKey = "";
                try { correctKey = atob(PERSONAL_USE_B64); } catch (e) {
                    console.error("Error decoding Base64 key:", e); passwordError.textContent = 'Configuration Error'; return;
                }
                if (enteredValue === correctKey) {
                    sessionStorage.setItem(AUTH_KEY, 'true');
                    passwordOverlay.classList.add('hidden');
                    mainContainer.style.display = 'block';
                    initializeApp();
                } else {
                    passwordError.textContent = 'Incorrect Access Key'; passwordInput.value = ''; passwordInput.focus();
                }
            });
        }
    }

    /* --- PerasTV Main Application Logic --- */
    function initializeApp() {
        if (window.appInitialized) return;
        window.appInitialized = true;
        console.log("Initializing PerasTV App...");

        // --- Configuration Constants ---
        const CONFIG = {
            channelsUrl: "channels.json",
            matchesUrl: "matches.json",
            placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%231a1a1a"/></svg>',
            searchDebounceMs: 300,
            lastTabKey: 'perasTvLastTab',
            favoritesKey: 'perasTvFavorites',
            iframeLoadTimeoutMs: 35000,
            openInNewTabKey: 'perasTvOpenInNewTab',
            openInPlayerPageKey: 'perasTvOpenPlayerPage',
            themeKey: 'perasTvTheme',
            skeletonCount: 12, // Number of skeletons to show initially
            scrollTopThreshold: 200 // Pixels to scroll before showing scroll-to-top button
        };

        // --- DOM Element References ---
        const bodyElement = document.body;
        const searchInputElement = document.getElementById('search-input');
        const tabsContainerElement = document.querySelector('.tabs');
        const channelGridElements = document.querySelectorAll('.channel-grid');
        const lastUpdatedTimestampElement = document.getElementById('lastUpdated');
        const initialLoadingMessageElement = document.getElementById('loadingMessage');
        const dataFetchErrorMessageElement = document.getElementById('fetchErrorMessage');
        const logoLinkElement = document.getElementById('logo-link');
        // Header Buttons & Panel
        const themeToggleButtonElement = document.getElementById('theme-toggle-button'); // NEW
        const settingsButtonElement = document.getElementById('settings-button');
        const settingsPanelElement = document.getElementById('settings-panel');
        // Toggles inside Settings Panel
        const openInNewTabToggleElement = document.getElementById('open-in-new-tab-toggle');
        const openInPlayerPageToggleElement = document.getElementById('open-in-player-page-toggle');
        // Scroll to Top Button
        const scrollToTopButtonElement = document.getElementById('scroll-to-top-btn'); // NEW

        // --- Application State ---
        let currentHlsInstance = null;
        let allChannelsData = {};
        let allMatchesData = [];
        let currentlyExpandedBoxElement = null;
        let searchDebounceTimerId = null;
        let activeTabId = 'ALL';
        let favoriteItemIds = [];
        let openInNewTabEnabled = false;
        let openInPlayerPageEnabled = false;
        let currentTheme = 'dark'; // Default theme

        // --- SVG Icons ---
        const SVG_SUN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24px" height="24px"><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5Zm0 8a3 3 0 1 1 3-3 3 3 0 0 1-3 3ZM12 2a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0V3a1 1 0 0 0-1-1Zm0 18a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1a1 1 0 0 0-1-1ZM20.66 4.34a1 1 0 0 0-1.41 0l-.71.71a1 1 0 1 0 1.41 1.41l.71-.71a1 1 0 0 0 0-1.41ZM5.76 18.24a1 1 0 0 0-1.41 0l-.71.71a1 1 0 0 0 1.41 1.41l.71-.71a1 1 0 0 0 0-1.41ZM22 12a1 1 0 0 0-1-1h-1a1 1 0 0 0 0 2h1a1 1 0 0 0 1-1ZM5 11H4a1 1 0 0 0 0 2h1a1 1 0 0 0 0-2ZM18.24 18.24a1 1 0 0 0 0-1.41l-.71-.71a1 1 0 0 0-1.41 1.41l.71.71a1 1 0 0 0 1.41 0ZM4.34 5.76l.71.71a1 1 0 0 0 1.41-1.41l-.71-.71a1 1 0 0 0-1.41 1.41Z"/></svg>`;
        const SVG_MOON = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24px" height="24px"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69a.75.75 0 0 1 .981.981A10.503 10.503 0 0 1 12 22.5a10.5 10.5 0 0 1-10.5-10.5c0-4.306 2.56-8.007 6.372-9.782a.75.75 0 0 1 .819.162Z" clip-rule="evenodd" /></svg>`;
        const SVG_ENTER_FULLSCREEN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"> <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> </svg>`;
        const SVG_EXIT_FULLSCREEN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"> <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/> </svg>`;

        // --- Disclaimer Text ---
        const BOX_DISCLAIMER_TEXT = `Disclaimer: This site embeds content from external sources. We do not host streams. Availability and quality not guaranteed. Use responsibly.`;

        // --- Initial Setup ---
        loadFavoritesFromStorage();
        loadSettingsFromStorage(); // Load theme and other toggles
        applyTheme(); // Apply loaded theme
        updateThemeButtonIcon(); // Set initial theme button icon
        setupGlobalEventListeners(); // Includes scroll listener now
        updateTimestampDisplay();
        setInterval(updateTimestampDisplay, 60000);
        fetchAndRenderData(); // Will show skeletons first

        // --- Settings Loading & Applying ---
        function loadSettingsFromStorage() {
            // Load Theme
            const storedTheme = localStorage.getItem(CONFIG.themeKey);
            currentTheme = (storedTheme === 'light') ? 'light' : 'dark'; // Default to dark
            console.log(`Loaded theme: ${currentTheme}`);

            // Load Toggles
            const storedNewTabState = localStorage.getItem(CONFIG.openInNewTabKey);
            const storedPlayerPageState = localStorage.getItem(CONFIG.openInPlayerPageKey);
            openInNewTabEnabled = (storedNewTabState === 'true');
            openInPlayerPageEnabled = (storedPlayerPageState === 'true');
            if (openInNewTabEnabled && openInPlayerPageEnabled) {
                openInNewTabEnabled = false; // Player page takes precedence
            }

            // Update toggle checkbox states inside the panel
            if (openInNewTabToggleElement) {
                openInNewTabToggleElement.checked = openInNewTabEnabled;
                updateAriaChecked(openInNewTabToggleElement, openInNewTabEnabled);
            }
            if (openInPlayerPageToggleElement) {
                openInPlayerPageToggleElement.checked = openInPlayerPageEnabled;
                updateAriaChecked(openInPlayerPageToggleElement, openInPlayerPageEnabled);
            }
            console.log(`Loaded toggles: NewTab=${openInNewTabEnabled}, PlayerPage=${openInPlayerPageEnabled}`);
        }

        function applyTheme() {
            bodyElement.setAttribute('data-theme', currentTheme);
            console.log(`Applied theme: ${currentTheme}`);
        }

        /** Updates the theme toggle button icon and labels */
        function updateThemeButtonIcon() {
            if (!themeToggleButtonElement) return;
            if (currentTheme === 'light') {
                themeToggleButtonElement.innerHTML = SVG_MOON;
                themeToggleButtonElement.setAttribute('aria-label', 'Switch to Dark Theme');
                themeToggleButtonElement.setAttribute('title', 'Switch to Dark Theme');
            } else {
                themeToggleButtonElement.innerHTML = SVG_SUN;
                themeToggleButtonElement.setAttribute('aria-label', 'Switch to Light Theme');
                themeToggleButtonElement.setAttribute('title', 'Switch to Light Theme');
            }
        }

        function saveSettingsToStorage() {
            try {
                localStorage.setItem(CONFIG.themeKey, currentTheme);
                localStorage.setItem(CONFIG.openInNewTabKey, openInNewTabEnabled);
                localStorage.setItem(CONFIG.openInPlayerPageKey, openInPlayerPageEnabled);
                console.log(`Saved settings: Theme=${currentTheme}, NewTab=${openInNewTabEnabled}, PlayerPage=${openInPlayerPageEnabled}`);
            } catch (error) {
                console.error("Error saving settings to localStorage:", error);
            }
        }

        // --- Favorite Management ---
        function loadFavoritesFromStorage() {
            const storedFavoritesJson = localStorage.getItem(CONFIG.favoritesKey);
            if (storedFavoritesJson) {
                try {
                    const parsedFavorites = JSON.parse(storedFavoritesJson);
                    if (Array.isArray(parsedFavorites) && parsedFavorites.every(item => typeof item === 'string')) { favoriteItemIds = parsedFavorites; }
                    else { favoriteItemIds = []; localStorage.removeItem(CONFIG.favoritesKey); }
                } catch (error) { console.error("Error parsing favorites:", error); favoriteItemIds = []; }
            } else { favoriteItemIds = []; }
            console.log("Loaded favorites:", favoriteItemIds);
        }

        function saveFavoritesToStorage() {
            try { localStorage.setItem(CONFIG.favoritesKey, JSON.stringify(favoriteItemIds)); }
            catch (error) { console.error("Error saving favorites:", error); }
        }

        function toggleFavoriteStatus(itemId, starButtonElement) {
            if (!itemId || !starButtonElement) return;
            const itemIndex = favoriteItemIds.indexOf(itemId);
            const isCurrentlyFavorite = itemIndex > -1;
            if (isCurrentlyFavorite) { favoriteItemIds.splice(itemIndex, 1); starButtonElement.classList.remove('is-favorite'); starButtonElement.setAttribute('aria-pressed', 'false'); starButtonElement.setAttribute('aria-label', 'Add to Favorites'); }
            else { favoriteItemIds.push(itemId); starButtonElement.classList.add('is-favorite'); starButtonElement.setAttribute('aria-pressed', 'true'); starButtonElement.setAttribute('aria-label', 'Remove from Favorites'); }
            saveFavoritesToStorage();
            document.querySelectorAll(`.channel-box#${CSS.escape(itemId)} .favorite-button`).forEach(otherStar => { if (otherStar !== starButtonElement) { otherStar.classList.toggle('is-favorite', !isCurrentlyFavorite); otherStar.setAttribute('aria-pressed', !isCurrentlyFavorite ? 'true' : 'false'); otherStar.setAttribute('aria-label', !isCurrentlyFavorite ? 'Remove from Favorites' : 'Add to Favorites'); } });
            if (activeTabId === 'Favorites') { renderFavoritesTabContent(); addChannelBoxEventListeners(document.getElementById('Favorites')); }
        }

        // --- Event Listener Setup ---
        function setupGlobalEventListeners() {
            // Tab clicks
            tabsContainerElement.addEventListener('click', (event) => { const tabButton = event.target.closest('.tab-button[data-tab]'); if (tabButton) activateTab(tabButton.dataset.tab); });
            // Search input
            searchInputElement.addEventListener('input', (event) => { clearTimeout(searchDebounceTimerId); searchDebounceTimerId = setTimeout(() => filterVisibleContent(event.target.value), CONFIG.searchDebounceMs); });
            // Theme Toggle Button
            if (themeToggleButtonElement) { themeToggleButtonElement.addEventListener('click', () => { currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); updateThemeButtonIcon(); saveSettingsToStorage(); console.log(`Theme toggled to: ${currentTheme}`); }); }
            // Settings Menu
            if (settingsButtonElement && settingsPanelElement) {
                settingsButtonElement.addEventListener('click', (event) => { event.stopPropagation(); const isVisible = settingsPanelElement.classList.toggle('visible'); settingsButtonElement.setAttribute('aria-expanded', isVisible ? 'true' : 'false'); });
                document.addEventListener('click', (event) => { if (!settingsPanelElement.contains(event.target) && !settingsButtonElement.contains(event.target)) { if (settingsPanelElement.classList.contains('visible')) { settingsPanelElement.classList.remove('visible'); settingsButtonElement.setAttribute('aria-expanded', 'false'); } } });
                document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && settingsPanelElement.classList.contains('visible')) { settingsPanelElement.classList.remove('visible'); settingsButtonElement.setAttribute('aria-expanded', 'false'); settingsButtonElement.focus(); } });
            }
            // Toggles Inside Settings Panel
            if (openInNewTabToggleElement) { openInNewTabToggleElement.addEventListener('change', (event) => { openInNewTabEnabled = event.target.checked; if (openInNewTabEnabled && openInPlayerPageToggleElement) { openInPlayerPageToggleElement.checked = false; openInPlayerPageEnabled = false; updateAriaChecked(openInPlayerPageToggleElement, false); } saveSettingsToStorage(); updateAriaChecked(openInNewTabToggleElement, openInNewTabEnabled); console.log(`'Open source in new tab' toggled: ${openInNewTabEnabled}`); }); }
            if (openInPlayerPageToggleElement) { openInPlayerPageToggleElement.addEventListener('change', (event) => { openInPlayerPageEnabled = event.target.checked; if (openInPlayerPageEnabled && openInNewTabToggleElement) { openInNewTabToggleElement.checked = false; openInNewTabEnabled = false; updateAriaChecked(openInNewTabToggleElement, false); } saveSettingsToStorage(); updateAriaChecked(openInPlayerPageToggleElement, openInPlayerPageEnabled); console.log(`'Open player page in new tab' toggled: ${openInPlayerPageEnabled}`); }); }
            // Keyboard navigation
            document.addEventListener('keydown', (event) => {
                 if (event.key === 'Escape' && currentlyExpandedBoxElement && !settingsPanelElement.classList.contains('visible')) { collapseItemBox(currentlyExpandedBoxElement); }
                 if (event.key === 'Escape' && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) { updateFullscreenButtonState(); }
                 const focusableElements = getFocusableElementsInActiveGrid(); const currentIndex = focusableElements.indexOf(document.activeElement);
                 if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) { if (document.activeElement && document.activeElement.closest('.channel-box') && !currentlyExpandedBoxElement && !settingsPanelElement.classList.contains('visible')) { event.preventDefault(); let nextIndex = -1; const activeGrid = document.getElementById(activeTabId); const numCols = activeGrid ? getComputedStyle(activeGrid).gridTemplateColumns.split(' ').length : 1; switch (event.key) { case 'ArrowDown': nextIndex = currentIndex + numCols; break; case 'ArrowUp': nextIndex = currentIndex - numCols; break; case 'ArrowRight': nextIndex = (currentIndex + 1) % numCols === 0 && numCols > 1 ? -1 : currentIndex + 1; break; case 'ArrowLeft': nextIndex = currentIndex % numCols === 0 && numCols > 1 ? -1 : currentIndex - 1; break; } if (nextIndex >= 0 && nextIndex < focusableElements.length) { focusableElements[nextIndex].focus(); } } else if (!document.activeElement || document.activeElement === bodyElement || document.activeElement === searchInputElement || document.activeElement.closest('.tabs')) { focusableElements[0]?.focus(); } }
                 if (event.key === 'Enter' || event.key === 'Ok') { if (document.activeElement?.classList.contains('stream-button')) { event.preventDefault(); document.activeElement.click(); } else if (document.activeElement?.classList.contains('tab-button')) { event.preventDefault(); document.activeElement.click(); } else if (document.activeElement?.classList.contains('favorite-button')) { event.preventDefault(); document.activeElement.click(); } else if (document.activeElement === logoLinkElement) { event.preventDefault(); activateTab('ALL'); window.scrollTo({ top: 0, behavior: 'smooth' }); } else if (document.activeElement === settingsButtonElement) { event.preventDefault(); settingsButtonElement.click(); } else if (document.activeElement === themeToggleButtonElement) { event.preventDefault(); themeToggleButtonElement.click(); } }
            });
            // Fullscreen change listeners
            document.addEventListener('fullscreenchange', updateFullscreenButtonState); document.addEventListener('webkitfullscreenchange', updateFullscreenButtonState); document.addEventListener('mozfullscreenchange', updateFullscreenButtonState); document.addEventListener('MSFullscreenChange', updateFullscreenButtonState);
            // Logo Click Listener
            if (logoLinkElement) { logoLinkElement.addEventListener('click', (event) => { if (event.button === 1 || event.ctrlKey || event.metaKey) { return; } event.preventDefault(); activateTab('ALL'); window.scrollTo({ top: 0, behavior: 'smooth' }); }); logoLinkElement.addEventListener('auxclick', (event) => { if (event.button === 1) { /* Allow default */ } }); }
            // Scroll to Top Listener
            if (scrollToTopButtonElement) { window.addEventListener('scroll', () => { if (window.scrollY > CONFIG.scrollTopThreshold) { scrollToTopButtonElement.classList.add('visible'); } else { scrollToTopButtonElement.classList.remove('visible'); } }); scrollToTopButtonElement.addEventListener('click', () => { window.scrollTo({ top: 0, behavior: 'smooth' }); }); }
        }

        // Helper to update aria-checked attribute
        function updateAriaChecked(toggleInputElement, isChecked) { const container = toggleInputElement?.closest('[role="menuitemcheckbox"]'); if (container) { container.setAttribute('aria-checked', isChecked ? 'true' : 'false'); } }
        // Helper to get focusable channel boxes
        function getFocusableElementsInActiveGrid() { const activeGrid = document.getElementById(activeTabId); if (!activeGrid) return []; return Array.from(activeGrid.querySelectorAll(':scope > .channel-box:not(.hidden):not(.expanded)')); }

        // --- Data Fetching & Rendering ---
        async function fetchAndRenderData() {
             showSkeletons(); // Show skeleton loaders instead
             dataFetchErrorMessageElement.style.display = 'none';
             try {
                 const cacheBuster = `?t=${Date.now()}`; const channelsUrl = CONFIG.channelsUrl + cacheBuster; const matchesUrl = CONFIG.matchesUrl + cacheBuster;
                 const [channelsResponse, matchesResponse] = await Promise.all([ fetch(channelsUrl), fetch(matchesUrl) ]);
                 if (!channelsResponse.ok) throw new Error(`Failed to load channels: ${channelsResponse.status} ${channelsResponse.statusText}`);
                 if (!matchesResponse.ok) throw new Error(`Failed to load matches: ${matchesResponse.status} ${matchesResponse.statusText}`);
                 allChannelsData = await channelsResponse.json(); allMatchesData = await matchesResponse.json();
                 if (typeof allChannelsData !== 'object' || allChannelsData === null) throw new Error("Invalid channels data format.");
                 if (!Array.isArray(allMatchesData)) throw new Error("Invalid matches data format.");
                 console.log("Data fetched successfully:", { channels: allChannelsData, matches: allMatchesData });
                 renderAllContentGrids(); // Will replace skeletons
                 const lastSavedTabId = localStorage.getItem(CONFIG.lastTabKey); const validTabIds = Array.from(tabsContainerElement.querySelectorAll('.tab-button')).map(btn => btn.dataset.tab);
                 activateTab(validTabIds.includes(lastSavedTabId) ? lastSavedTabId : 'ALL');
             } catch (error) {
                 console.error("Data loading failed:", error);
                 clearSkeletons(); // Clear skeletons on error too
                 showDataFetchErrorMessage(`Error loading data: ${error.message}. Please try refreshing.`);
             }
        }

        // --- Skeleton Loading ---
        function renderSkeletons(gridElement, count) { /* ... keep existing ... */ if (!gridElement) return; gridElement.innerHTML = ''; const fragment = document.createDocumentFragment(); const isMatchGrid = gridElement.id === 'Matches'; for (let i = 0; i < count; i++) { const skeleton = document.createElement('div'); skeleton.className = 'skeleton-box'; if (isMatchGrid) { skeleton.dataset.type = 'match'; } else if (gridElement.id === 'ALL' && i < (allMatchesData?.length || 0)) { skeleton.dataset.type = 'match'; } else { skeleton.dataset.type = 'channel'; } fragment.appendChild(skeleton); } gridElement.appendChild(fragment); gridElement.style.display = 'grid'; }
        function showSkeletons() { /* ... keep existing ... */ channelGridElements.forEach(grid => { if (grid.id === activeTabId || grid.id === 'ALL') { renderSkeletons(grid, CONFIG.skeletonCount); grid.classList.add('active'); } else { grid.innerHTML = ''; grid.classList.remove('active'); } }); }
        function clearSkeletons() { /* ... keep existing ... */ document.querySelectorAll('.skeleton-box').forEach(el => el.remove()); }


        // Renders content for all grids (Clears skeletons first)
        function renderAllContentGrids() { /* ... keep existing ... */ console.log("Rendering all content grids..."); clearSkeletons(); renderSpecificGridContent('PT', allChannelsData.PT || [], 'channel'); renderSpecificGridContent('UK', allChannelsData.UK || [], 'channel'); renderSpecificGridContent('ES', allChannelsData.ES || [], 'channel'); renderSpecificGridContent('Matches', allMatchesData || [], 'match'); renderAllTabContent(); renderFavoritesTabContent(); addChannelBoxEventListeners(); }
        // Renders content for a specific grid (Clears skeletons first)
        function renderSpecificGridContent(gridId, items, itemType) { /* ... keep existing ... */ const gridElement = document.getElementById(gridId); if (!gridElement) return; gridElement.innerHTML = ''; if (!items || items.length === 0) { let emptyMessage = `No ${itemType === 'match' ? 'matches' : 'channels'} listed.`; if (gridId === 'Favorites') emptyMessage = 'Favorites list is empty. Click ☆ to add.'; gridElement.innerHTML = `<p class="status-message info">${emptyMessage}</p>`; return; } const fragment = document.createDocumentFragment(); items.forEach((itemData) => { let itemElement = null; let uniqueItemId = null; if (itemType === 'match') { const globalMatchIndex = allMatchesData.findIndex(m => m === itemData); if (globalMatchIndex !== -1) { uniqueItemId = `match-${globalMatchIndex}`; itemElement = createMatchBoxElement(itemData, uniqueItemId); } } else { let category = ''; let categoryIndex = -1; for (const key in allChannelsData) { const index = allChannelsData[key]?.indexOf(itemData); if (index !== -1 && index !== undefined) { category = key; categoryIndex = index; break; } } if (category && categoryIndex !== -1) { uniqueItemId = `${category}-channel-${categoryIndex}`; itemElement = createChannelBoxElement(itemData, uniqueItemId); } } if (itemElement) fragment.appendChild(itemElement); else console.warn(`Failed to create element for item in grid ${gridId}`); }); gridElement.appendChild(fragment); }
        // Renders the content for the 'ALL' tab (Clears skeletons first)
        function renderAllTabContent() { /* ... keep existing ... */ const allGridElement = document.getElementById('ALL'); if (!allGridElement) return; allGridElement.innerHTML = ''; const fragment = document.createDocumentFragment(); let contentAdded = false; if (allMatchesData && allMatchesData.length > 0) { allMatchesData.forEach((match, index) => { const uniqueId = `match-${index}`; const box = createMatchBoxElement(match, uniqueId); if(box) { fragment.appendChild(box); contentAdded = true; } }); } ['PT', 'UK', 'ES'].forEach(category => { const channelsInCategory = allChannelsData[category] || []; if (channelsInCategory.length > 0) { channelsInCategory.forEach((channel, index) => { const uniqueId = `${category}-channel-${index}`; const box = createChannelBoxElement(channel, uniqueId); if(box) { fragment.appendChild(box); contentAdded = true; } }); } }); allGridElement.appendChild(fragment); if (!contentAdded) allGridElement.innerHTML = '<p class="status-message info">No channels or matches available.</p>'; }
        // Renders the content for the 'Favorites' tab (Clears skeletons first)
        function renderFavoritesTabContent() { /* ... keep existing ... */ const favoritesGridElement = document.getElementById('Favorites'); if (!favoritesGridElement) return; favoritesGridElement.innerHTML = ''; if (favoriteItemIds.length === 0) { favoritesGridElement.innerHTML = '<p class="status-message info">Favorites list is empty.<br>Click ☆ to add.</p>'; return; } const fragment = document.createDocumentFragment(); let validFavoritesFound = 0; favoriteItemIds.forEach(itemId => { let itemElement = null; if (itemId.startsWith('match-')) { const matchIndex = parseInt(itemId.split('-')[1], 10); if (!isNaN(matchIndex) && matchIndex >= 0 && matchIndex < allMatchesData.length) { itemElement = createMatchBoxElement(allMatchesData[matchIndex], itemId); } } else if (itemId.includes('-channel-')) { const parts = itemId.split('-'); const category = parts[0]; const channelIndex = parseInt(parts[parts.length - 1], 10); if (allChannelsData[category] && !isNaN(channelIndex) && channelIndex >= 0 && channelIndex < allChannelsData[category].length) { itemElement = createChannelBoxElement(allChannelsData[category][channelIndex], itemId); } } if (itemElement) { fragment.appendChild(itemElement); validFavoritesFound++; } else { console.warn(`Could not find data for favorite item ID: ${itemId}.`); } }); favoritesGridElement.appendChild(fragment); if (validFavoritesFound === 0 && favoriteItemIds.length > 0) { favoritesGridElement.innerHTML = '<p class="status-message info">Previously favorited items could not be found.</p>'; } }

        // --- Element Creation ---
        function createChannelBoxElement(channelData, uniqueItemId) { /* ... keep existing ... */ if (!channelData || !uniqueItemId || !channelData.name || !Array.isArray(channelData.srcs)) return null; const { name, srcs } = channelData; const boxElement = document.createElement('div'); boxElement.className = 'channel-box'; boxElement.id = uniqueItemId; boxElement.tabIndex = 0; boxElement.dataset.itemName = name; boxElement.dataset.itemType = 'channel'; boxElement.dataset.sources = JSON.stringify(srcs); boxElement.dataset.itemId = uniqueItemId; const isFavorite = favoriteItemIds.includes(uniqueItemId); boxElement.innerHTML = `<button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites" aria-pressed="${isFavorite}" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></button><div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content"><h3>${name}</h3></div><div class="channel-info"></div><div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header"><div class="player-area"><div class="loader"></div> <div class="player-message" role="alert"></div><iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe><video controls autoplay muted playsinline title="Stream Player" poster="${CONFIG.placeholderImage}"></video><button class="custom-fullscreen-btn" aria-label="Enter Fullscreen" title="Enter Fullscreen">${SVG_ENTER_FULLSCREEN}</button></div><div class="stream-buttons"></div> <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p></div>`; return boxElement; }
        function createMatchBoxElement(matchData, uniqueItemId) { /* ... keep existing ... */ if (!matchData || !uniqueItemId || !matchData.team1 || !matchData.team2) return null; const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = matchData; const boxElement = document.createElement('div'); boxElement.className = 'channel-box'; boxElement.id = uniqueItemId; boxElement.tabIndex = 0; const matchTitle = `${team1} vs ${team2}`; boxElement.dataset.itemName = matchTitle; boxElement.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase(); boxElement.dataset.itemType = 'match'; const allSources = { pt: pt || [], uk: uk || [], es: es || [] }; boxElement.dataset.sources = JSON.stringify(allSources); boxElement.dataset.itemId = uniqueItemId; const isFavorite = favoriteItemIds.includes(uniqueItemId); const createLogoHtml = (logoUrl, altText) => logoUrl ? `<img src="${logoUrl}" alt="${altText} logo" class="match-logo" loading="lazy" onerror="this.style.display='none'; this.onerror=null;">` : '<span class="match-logo" aria-label="No logo available" style="display: inline-block; width: 40px;"></span>'; boxElement.innerHTML = `<button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites" aria-pressed="${isFavorite}" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg></button><div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content">${createLogoHtml(logo1, team1)} <h3>${matchTitle}</h3> ${createLogoHtml(logo2, team2)}</div><div class="channel-info"> ${league ? `<span>${league}</span>` : ''} ${league && time ? '<span aria-hidden="true"> | </span>' : ''} ${time ? `<span>${time}</span>` : ''} </div><div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header"><div class="player-area"><div class="loader"></div> <div class="player-message" role="alert"></div><iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe><video controls autoplay muted playsinline title="Stream Player" poster="${CONFIG.placeholderImage}"></video><button class="custom-fullscreen-btn" aria-label="Enter Fullscreen" title="Enter Fullscreen">${SVG_ENTER_FULLSCREEN}</button></div><div class="stream-buttons"></div> <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p></div>`; return boxElement; }
        function createStreamSourceButton(label, url, parentBoxElement) { /* ... keep existing ... */ const buttonElement = document.createElement('button'); buttonElement.className = 'stream-button'; buttonElement.textContent = label || 'Source'; buttonElement.dataset.streamUrl = url; buttonElement.onclick = (event) => { event.stopPropagation(); const itemId = parentBoxElement.dataset.itemId; if (openInPlayerPageEnabled && itemId) { const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`; window.open(playerPageUrl, '_blank'); buttonElement.classList.add('active'); setTimeout(() => buttonElement.classList.remove('active'), 500); } else if (openInNewTabEnabled) { window.open(url, '_blank'); buttonElement.classList.add('active'); setTimeout(() => buttonElement.classList.remove('active'), 500); } else { loadStreamIntoPlayer(buttonElement, url, parentBoxElement); } }; return buttonElement; }

        // --- Event Listener Setup for Channel Boxes ---
        function addChannelBoxEventListeners(scopeElement = document) { /* ... keep existing ... */ if (!scopeElement) return; scopeElement.querySelectorAll('.channel-box:not([data-listener-added="true"])').forEach(boxElement => { const headerElement = boxElement.querySelector('.channel-header'); const infoElement = boxElement.querySelector('.channel-info'); const favoriteButtonElement = boxElement.querySelector('.favorite-button'); const boxId = boxElement.id; const itemId = boxElement.dataset.itemId; const handleBoxClick = (event) => { if (event.target.closest('.favorite-button') || event.target.closest('.custom-fullscreen-btn')) return; if (openInPlayerPageEnabled && itemId) { const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`; window.open(playerPageUrl, '_blank'); } else { toggleItemBoxExpansion(boxElement); } }; if (headerElement) headerElement.addEventListener('click', handleBoxClick); if (infoElement && getComputedStyle(infoElement).display !== 'none') { infoElement.addEventListener('click', handleBoxClick); } if (favoriteButtonElement && boxId) { favoriteButtonElement.addEventListener('click', (event) => { event.stopPropagation(); toggleFavoriteStatus(boxId, favoriteButtonElement); }); } else if (!boxId) { console.warn("Could not attach favorite listener: Box ID missing.", boxElement); } boxElement.addEventListener('keydown', (event) => { if ((event.key === 'Enter' || event.key === 'Ok') && !boxElement.classList.contains('expanded')) { event.preventDefault(); if (openInPlayerPageEnabled && itemId) { const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`; window.open(playerPageUrl, '_blank'); } else { toggleItemBoxExpansion(boxElement); } } }); boxElement.dataset.listenerAdded = 'true'; }); }

        // --- Tab Management ---
        function activateTab(tabIdToShow) { /* ... keep existing ... */ if (tabIdToShow === activeTabId && document.getElementById(tabIdToShow)?.classList.contains('active')) return; console.log(`Activating tab: ${tabIdToShow}`); activeTabId = tabIdToShow; tabsContainerElement.querySelectorAll('.tab-button').forEach(btn => { const isActive = btn.dataset.tab === tabIdToShow; btn.classList.toggle('active', isActive); btn.setAttribute('aria-selected', isActive ? 'true' : 'false'); }); channelGridElements.forEach(grid => { const isGridActive = grid.id === tabIdToShow; grid.classList.toggle('active', isGridActive); grid.setAttribute('tabindex', isGridActive ? '0' : '-1'); }); if (currentlyExpandedBoxElement) { collapseItemBox(currentlyExpandedBoxElement); } localStorage.setItem(CONFIG.lastTabKey, tabIdToShow); if (tabIdToShow === 'Favorites') { renderFavoritesTabContent(); addChannelBoxEventListeners(document.getElementById('Favorites')); } filterVisibleContent(searchInputElement.value); setTimeout(() => document.getElementById(tabIdToShow)?.focus({ preventScroll: true }), 50); }

        // --- Search Filtering (Improved) ---
        function filterVisibleContent(searchTerm) { /* ... keep existing ... */ const normalizedSearchTerm = searchTerm.toLowerCase().trim(); const searchWords = normalizedSearchTerm.split(/\s+/).filter(word => word.length > 0); const isSearching = searchWords.length > 0; let resultsFoundInActiveTab = false; const activeGridElement = document.getElementById(activeTabId); const allBoxes = document.querySelectorAll('.channel-box'); allBoxes.forEach(boxElement => { const parentGridId = boxElement.closest('.channel-grid')?.id; if (!parentGridId) return; const itemName = boxElement.dataset.itemName?.toLowerCase() || ''; const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || ''; const textToSearch = `${itemName} ${additionalSearchTerms}`; const matchesSearch = isSearching ? searchWords.every(word => textToSearch.includes(word)) : true; let shouldBeVisible = false; if (!isSearching) { shouldBeVisible = (parentGridId === activeTabId); } else { if (parentGridId === activeTabId) { shouldBeVisible = matchesSearch; } else if (activeTabId === 'ALL') { shouldBeVisible = matchesSearch; } else if (activeTabId === 'Favorites') { shouldBeVisible = matchesSearch && favoriteItemIds.includes(boxElement.id); } } if (!boxElement.classList.contains('expanded')) { boxElement.classList.toggle('hidden', !shouldBeVisible); boxElement.tabIndex = shouldBeVisible ? 0 : -1; } else { boxElement.classList.remove('hidden'); boxElement.tabIndex = -1; } if (shouldBeVisible && parentGridId === activeTabId && !boxElement.classList.contains('expanded')) { resultsFoundInActiveTab = true; } }); if (activeGridElement) { let noResultsMsgEl = activeGridElement.querySelector('.status-message.info.no-results'); if (!noResultsMsgEl) { noResultsMsgEl = document.createElement('p'); noResultsMsgEl.className = 'status-message info no-results'; noResultsMsgEl.style.display = 'none'; activeGridElement.prepend(noResultsMsgEl); } if (isSearching && !resultsFoundInActiveTab) { noResultsMsgEl.innerHTML = `No results found for "<strong>${searchTerm}</strong>" in this section.`; noResultsMsgEl.style.display = 'block'; } else { noResultsMsgEl.style.display = 'none'; } } }

        // --- Channel Box Expansion ---
        function toggleItemBoxExpansion(boxElement) { /* ... keep existing ... */ if (!boxElement) return; const isCurrentlyExpanded = boxElement.classList.contains('expanded'); const headerElement = boxElement.querySelector('.channel-header'); if (!isCurrentlyExpanded && currentlyExpandedBoxElement && currentlyExpandedBoxElement !== boxElement) { collapseItemBox(currentlyExpandedBoxElement); } if (!isCurrentlyExpanded) { expandItemBox(boxElement); if (headerElement) headerElement.setAttribute('aria-expanded', 'true'); } else { collapseItemBox(boxElement); if (headerElement) headerElement.setAttribute('aria-expanded', 'false'); } }
        function expandItemBox(boxElement) { /* ... keep existing ... */ if (!boxElement) return; const playerAreaElement = boxElement.querySelector('.player-area'); if (playerAreaElement) { if (openInNewTabEnabled || openInPlayerPageEnabled) { playerAreaElement.style.display = 'none'; } else { playerAreaElement.style.display = 'flex'; } } boxElement.classList.add('expanded'); boxElement.classList.remove('hidden'); boxElement.tabIndex = -1; currentlyExpandedBoxElement = boxElement; populateStreamsAndLoadFirst(boxElement); setupCustomFullscreen(boxElement); setTimeout(() => { boxElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); const firstStreamButton = boxElement.querySelector('.stream-button'); if (firstStreamButton) { setTimeout(() => firstStreamButton.focus({ preventScroll: true }), 150); } else { boxElement.querySelector('.iframe-container')?.focus(); } }, 100); }
        function collapseItemBox(boxElement) { /* ... keep existing ... */ if (!boxElement) return; const wasCurrentlyExpanded = (currentlyExpandedBoxElement === boxElement); const playerAreaElement = boxElement.querySelector('.player-area'); boxElement.classList.remove('expanded'); if (wasCurrentlyExpanded) { currentlyExpandedBoxElement = null; } clearPlayerStateInBox(boxElement); const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) streamButtonsContainer.innerHTML = ''; if (playerAreaElement) { playerAreaElement.style.display = ''; } const headerElement = boxElement.querySelector('.channel-header'); if(headerElement) headerElement.setAttribute('aria-expanded', 'false'); const normalizedSearchTerm = searchInputElement.value.toLowerCase().trim(); const searchWords = normalizedSearchTerm.split(/\s+/).filter(word => word.length > 0); const isSearching = searchWords.length > 0; const parentGridId = boxElement.closest('.channel-grid')?.id; const itemName = boxElement.dataset.itemName?.toLowerCase() || ''; const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || ''; const textToSearch = `${itemName} ${additionalSearchTerms}`; const matchesSearch = isSearching ? searchWords.every(word => textToSearch.includes(word)) : true; let shouldBeVisibleAfterCollapse = false; if (!isSearching) { shouldBeVisibleAfterCollapse = (parentGridId === activeTabId); } else { if (parentGridId === activeTabId) { shouldBeVisibleAfterCollapse = matchesSearch; } else if (activeTabId === 'ALL') { shouldBeVisibleAfterCollapse = matchesSearch; } else if (activeTabId === 'Favorites') { shouldBeVisibleAfterCollapse = matchesSearch && favoriteItemIds.includes(boxElement.id); } } boxElement.classList.toggle('hidden', !shouldBeVisibleAfterCollapse); boxElement.tabIndex = shouldBeVisibleAfterCollapse ? 0 : -1; if (wasCurrentlyExpanded && shouldBeVisibleAfterCollapse) { setTimeout(() => boxElement.focus({ preventScroll: true }), 50); } else if (wasCurrentlyExpanded) { setTimeout(() => document.getElementById(activeTabId)?.focus({ preventScroll: true }), 50); } }
        function populateStreamsAndLoadFirst(boxElement) { /* ... keep existing ... */ const sourcesJson = boxElement.dataset.sources; const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); const playerAreaElement = boxElement.querySelector('.player-area'); if (!sourcesJson || !streamButtonsContainer || !playerAreaElement) { displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); return; } streamButtonsContainer.innerHTML = ''; let firstStreamUrl = null; let firstStreamButtonElement = null; let streamCount = 0; const fragment = document.createDocumentFragment(); try { const sourcesData = JSON.parse(sourcesJson); if (Array.isArray(sourcesData)) { sourcesData.forEach((src) => { const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null); const label = typeof src === 'object' && src.label ? src.label : `Source ${streamCount + 1}`; if (url) { if (!firstStreamUrl) firstStreamUrl = url; const button = createStreamSourceButton(label, url, boxElement); if (!firstStreamButtonElement) firstStreamButtonElement = button; fragment.appendChild(button); streamCount++; } }); } else if (typeof sourcesData === 'object' && sourcesData !== null) { Object.entries(sourcesData).forEach(([langKey, sourcesInLang]) => { if (sourcesInLang && Array.isArray(sourcesInLang) && sourcesInLang.length > 0) { const langGroupDiv = document.createElement('div'); const langLabel = document.createElement('strong'); langLabel.textContent = `${langKey.toUpperCase()}:`; langGroupDiv.appendChild(langLabel); sourcesInLang.forEach((src) => { const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null); const label = typeof src === 'object' && src.label ? src.label : `Src ${streamCount + 1}`; if (url) { if (!firstStreamUrl) firstStreamUrl = url; const button = createStreamSourceButton(label, url, boxElement); if (!firstStreamButtonElement) firstStreamButtonElement = button; langGroupDiv.appendChild(button); streamCount++; } }); fragment.appendChild(langGroupDiv); } }); } streamButtonsContainer.appendChild(fragment); if (streamCount === 0) { displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerStateInBox(boxElement); } else if (openInPlayerPageEnabled) { if (playerAreaElement.style.display !== 'none') displayMessageInPlayerArea(playerAreaElement, `<strong>Select a source</strong><span>'Open player page' active. Click to open.</span>`, false); clearPlayerStateInBox(boxElement); } else if (openInNewTabEnabled) { if (playerAreaElement.style.display !== 'none') displayMessageInPlayerArea(playerAreaElement, `<strong>Select a source</strong><span>'Open source' active. Click to open.</span>`, false); clearPlayerStateInBox(boxElement); } else if (firstStreamUrl && firstStreamButtonElement) { const videoEl = boxElement.querySelector('video'); const iframeEl = boxElement.querySelector('iframe'); if (!videoEl.classList.contains('active') && !iframeEl.classList.contains('active')) { loadStreamIntoPlayer(firstStreamButtonElement, firstStreamUrl, boxElement); } else { const activeSrc = videoEl.src || iframeEl.src; if (activeSrc) { streamButtonsContainer.querySelectorAll('.stream-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.streamUrl === activeSrc); }); } } } else { console.error("Inconsistency: Streams counted, no first URL/Button.", boxElement.id); displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerStateInBox(boxElement); } } catch (error) { console.error("Failed to parse sources/create buttons:", boxElement.id, error); streamButtonsContainer.innerHTML = '<p class="status-message error">Error loading sources.</p>'; clearPlayerStateInBox(boxElement); } }
        function displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer) { /* ... keep existing ... */ const message = 'No stream sources listed for this item.'; if (streamButtonsContainer) { streamButtonsContainer.innerHTML = `<p style="color: var(--text-secondary); font-size: 0.9em; padding: 10px 0;">${message}</p>`; } if (playerAreaElement && playerAreaElement.style.display !== 'none') { displayMessageInPlayerArea(playerAreaElement, `<strong>No Streams Available</strong><span>${message}</span>`, false); } }

        // --- Stream Handling ---
        function loadStreamIntoPlayer(clickedButtonElement, streamUrl, parentBoxElement) { /* ... keep existing ... */ if (!parentBoxElement || !streamUrl || typeof streamUrl !== 'string') return; if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadStreamIntoPlayer called, but toggle enabled. Aborting."); clearPlayerStateInBox(parentBoxElement); return; } const playerAreaElement = parentBoxElement.querySelector('.player-area'); const loaderElement = playerAreaElement?.querySelector('.loader'); const messageContainerElement = playerAreaElement?.querySelector('.player-message'); const iframeElement = playerAreaElement?.querySelector('iframe'); const videoElement = playerAreaElement?.querySelector('video'); if (!playerAreaElement || !loaderElement || !messageContainerElement || !iframeElement || !videoElement) return; clearPlayerStateInBox(parentBoxElement); messageContainerElement.classList.remove('visible'); loaderElement.classList.add('visible'); const streamButtonsContainer = parentBoxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) { streamButtonsContainer.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active')); } if (clickedButtonElement) { clickedButtonElement.classList.add('active'); } if (!streamUrl.startsWith('http://') && !streamUrl.startsWith('https://')) { loaderElement.classList.remove('visible'); displayMessageInPlayerArea(playerAreaElement, `<strong>Invalid URL</strong><span>Link must start with http/https.</span>`, true, streamUrl, parentBoxElement); return; } setTimeout(() => { try { const urlObject = new URL(streamUrl); if (urlObject.pathname.toLowerCase().endsWith('.m3u8')) { loadHlsStreamIntoVideo(streamUrl, videoElement, playerAreaElement); } else { loadUrlIntoIframe(streamUrl, iframeElement, playerAreaElement); } } catch (error) { loaderElement.classList.remove('visible'); displayMessageInPlayerArea(playerAreaElement, `<strong>URL Error</strong><span>Could not process link.</span>`, true, streamUrl, parentBoxElement); } }, 50); }
        function clearPlayerStateInBox(boxElement) { /* ... keep existing ... */ if (!boxElement) return; const playerAreaElement = boxElement.querySelector('.player-area'); if (!playerAreaElement) return; const videoElement = playerAreaElement.querySelector('video'); const iframeElement = playerAreaElement.querySelector('iframe'); const loaderElement = playerAreaElement.querySelector('.loader'); const messageContainerElement = playerAreaElement.querySelector('.player-message'); if (currentHlsInstance && videoElement && currentHlsInstance.media === videoElement) { try { currentHlsInstance.destroy(); } catch (e) { console.warn("Error destroying HLS instance:", e); } currentHlsInstance = null; } if (iframeElement) { if (iframeElement.getAttribute('src') && iframeElement.getAttribute('src') !== 'about:blank') { iframeElement.src = 'about:blank'; } iframeElement.classList.remove('active'); } if (videoElement) { videoElement.pause(); if (videoElement.hasAttribute('src')) videoElement.removeAttribute('src'); if (videoElement.currentSrc) videoElement.load(); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; } if (loaderElement) loaderElement.classList.remove('visible'); if (messageContainerElement) messageContainerElement.classList.remove('visible'); const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) { streamButtonsContainer.querySelectorAll('.stream-button.active').forEach(b => b.classList.remove('active')); } const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn'); if (fsBtn) fsBtn.style.display = 'none'; updateFullscreenButtonState(); }
        function displayMessageInPlayerArea(playerAreaElement, messageHtml, showTryNextButton, failedUrl = null, parentBoxElement = null) { /* ... keep existing ... */ const messageContainerElement = playerAreaElement?.querySelector('.player-message'); const loaderElement = playerAreaElement?.querySelector('.loader'); const videoElement = playerAreaElement?.querySelector('video'); const iframeElement = playerAreaElement?.querySelector('iframe'); if (!messageContainerElement || !loaderElement || !playerAreaElement) return; if (videoElement) videoElement.classList.remove('active'); if (iframeElement) iframeElement.classList.remove('active'); loaderElement.classList.remove('visible'); messageContainerElement.innerHTML = messageHtml; if (showTryNextButton && failedUrl && parentBoxElement && !openInNewTabEnabled && !openInPlayerPageEnabled) { const nextButtonElement = findNextAvailableStreamButton(failedUrl, parentBoxElement); if (nextButtonElement) { const tryNextBtn = document.createElement('button'); tryNextBtn.className = 'try-next-button'; tryNextBtn.textContent = 'Try Next Source'; tryNextBtn.onclick = (event) => { event.stopPropagation(); nextButtonElement.click(); }; messageContainerElement.appendChild(document.createElement('br')); messageContainerElement.appendChild(tryNextBtn); } else { const noMoreSpan = document.createElement('span'); noMoreSpan.style.cssText = 'font-size:0.8em;margin-top:10px;display:block;'; noMoreSpan.textContent = '(No more sources available)'; messageContainerElement.appendChild(noMoreSpan); } } else if (showTryNextButton && (openInNewTabEnabled || openInPlayerPageEnabled)) { console.log("   'Try Next Source' button skipped (toggle enabled)."); } messageContainerElement.classList.add('visible'); const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn'); if (fsBtn) fsBtn.style.display = 'none'; updateFullscreenButtonState(); }
        function findNextAvailableStreamButton(failedUrl, parentBoxElement) { /* ... keep existing ... */ if (!failedUrl || !parentBoxElement) return null; const allButtonsInBox = parentBoxElement.querySelectorAll('.stream-button'); let foundFailedButton = false; for (let i = 0; i < allButtonsInBox.length; i++) { const currentButton = allButtonsInBox[i]; if (currentButton.dataset.streamUrl === failedUrl) { foundFailedButton = true; } else if (foundFailedButton) { return currentButton; } } return null; }
        function loadHlsStreamIntoVideo(hlsUrl, videoElement, playerAreaElement) { /* ... keep existing ... */ if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadHlsStreamIntoVideo called, but toggle enabled. Aborting."); return; } const parentBoxElement = videoElement.closest('.channel-box'); videoElement.poster = CONFIG.placeholderImage; if (Hls.isSupported()) { if (currentHlsInstance && currentHlsInstance.media === videoElement) { currentHlsInstance.destroy(); currentHlsInstance = null; } else if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; } currentHlsInstance = new Hls({ liveSyncDurationCount: 2, manifestLoadingTimeOut: 15000, levelLoadingTimeOut: 15000, fragLoadingTimeOut: 20000, manifestLoadErrorMaxRetry: 3, levelLoadErrorMaxRetry: 4, fragLoadErrorMaxRetry: 5 }); const hlsErrorListener = (event, data) => { if (!currentHlsInstance || currentHlsInstance.media !== videoElement) return; console.error('HLS.js Error:', data.type, data.details, data.fatal); let userMessage = `Stream Error (${data.details || 'Unknown'}).`; if (data.type === Hls.ErrorTypes.NETWORK_ERROR) { userMessage = `Network Error (${data.details}).`; } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR && data.details !== 'bufferStalledError') { userMessage = `Media Error (${data.details}).`; } if (data.fatal) { displayMessageInPlayerArea(playerAreaElement, `<strong>${userMessage}</strong>`, true, hlsUrl, parentBoxElement); if (currentHlsInstance && currentHlsInstance.media === videoElement) { currentHlsInstance.destroy(); currentHlsInstance = null; } videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; } }; const hlsManifestParsedListener = () => { if (!currentHlsInstance || currentHlsInstance.media !== videoElement) return; playerAreaElement.querySelector('.loader').classList.remove('visible'); videoElement.classList.add('active'); videoElement.muted = true; videoElement.play().catch(error => { if (currentHlsInstance && currentHlsInstance.media === videoElement) { const message = error.name === 'NotAllowedError' ? 'Click play to start.' : error.message; const showNext = error.name !== 'NotAllowedError'; displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>${message}</span>`, showNext, hlsUrl, parentBoxElement); if(showNext) videoElement.classList.remove('active'); playerAreaElement.querySelector('.loader').classList.remove('visible'); } }); }; currentHlsInstance.on(Hls.Events.ERROR, hlsErrorListener); currentHlsInstance.on(Hls.Events.MANIFEST_PARSED, hlsManifestParsedListener); currentHlsInstance.attachMedia(videoElement); currentHlsInstance.loadSource(hlsUrl); } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) { if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; } const handleNativeLoadedMetadata = () => { if (videoElement.getAttribute('src') !== hlsUrl) return; playerAreaElement.querySelector('.loader').classList.remove('visible'); videoElement.classList.add('active'); videoElement.muted = true; videoElement.play().catch(error => { if(videoElement.getAttribute('src') === hlsUrl){ const message = error.name==='NotAllowedError'?'Click play.':error.message; const showNext = error.name !== 'NotAllowedError'; displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>${message}</span>`, showNext, hlsUrl, parentBoxElement); if(showNext) videoElement.classList.remove('active'); playerAreaElement.querySelector('.loader').classList.remove('visible'); } }); }; const handleNativeError = () => { if (videoElement.getAttribute('src') !== hlsUrl) return; const err = videoElement.error; const msg = err ? (err.message || `code ${err.code}`) : 'Unknown'; displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>Native HLS failed: ${msg}.</span>`, true, hlsUrl, parentBoxElement); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; playerAreaElement.querySelector('.loader').classList.remove('visible'); }; videoElement.removeEventListener('loadedmetadata', handleNativeLoadedMetadata); videoElement.removeEventListener('error', handleNativeError); videoElement.addEventListener('loadedmetadata', handleNativeLoadedMetadata); videoElement.addEventListener('error', handleNativeError); videoElement.src = hlsUrl; videoElement.load(); } else { displayMessageInPlayerArea(playerAreaElement, `<strong>Unsupported Stream</strong><span>Browser cannot play HLS (.m3u8).</span>`, false); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; playerAreaElement.querySelector('.loader').classList.remove('visible'); } const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn'); if (fsBtn) fsBtn.style.display = 'block'; updateFullscreenButtonState(); }
        function loadUrlIntoIframe(iframeUrl, iframeElement, playerAreaElement) { /* ... keep existing ... */ if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadUrlIntoIframe called, but toggle enabled. Aborting."); return; } const parentBoxElement = iframeElement.closest('.channel-box'); let iframeLoadTimeoutId = null; let isLoadSuccessful = false; if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; } const cleanupIframeLoad = () => { clearTimeout(iframeLoadTimeoutId); iframeElement.onload = null; iframeElement.onerror = null; }; const handleIframeLoadFailure = (reason) => { cleanupIframeLoad(); if (iframeElement.getAttribute('src') === iframeUrl) { displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>${reason}. Might be offline/blocked.</span>`, true, iframeUrl, parentBoxElement); iframeElement.classList.remove('active'); iframeElement.src = 'about:blank'; playerAreaElement.querySelector('.loader').classList.remove('visible'); } }; iframeLoadTimeoutId = setTimeout(() => { if (!isLoadSuccessful && iframeElement.getAttribute('src') === iframeUrl) { handleIframeLoadFailure(`Load timeout (${CONFIG.iframeLoadTimeoutMs / 1000}s)`); } }, CONFIG.iframeLoadTimeoutMs); iframeElement.onload = () => { if (iframeElement.getAttribute('src') === iframeUrl) { isLoadSuccessful = true; cleanupIframeLoad(); playerAreaElement.querySelector('.loader').classList.remove('visible'); iframeElement.classList.add('active'); } else if (iframeElement.getAttribute('src') !== 'about:blank') { /* Ignore */ } }; iframeElement.onerror = () => { if (iframeElement.getAttribute('src') === iframeUrl) { handleIframeLoadFailure("onError event fired"); } }; iframeElement.src = iframeUrl; const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn'); if (fsBtn) fsBtn.style.display = 'block'; updateFullscreenButtonState(); }

        // --- Custom Fullscreen Logic ---
        function setupCustomFullscreen(boxElement) { /* ... keep existing ... */ const btn = boxElement.querySelector('.custom-fullscreen-btn'); const playerArea = boxElement.querySelector('.player-area'); if (btn && playerArea) { btn.onclick = (event) => { event.stopPropagation(); const iframe = playerArea.querySelector('iframe'); const video = playerArea.querySelector('video'); const isActive = iframe?.classList.contains('active') || video?.classList.contains('active'); if (!isActive) { console.warn("Fullscreen button clicked, but no active player found in box:", boxElement.id); return; } toggleBrowserFullscreen(playerArea); }; } else { console.warn("Could not find fullscreen button or player area in box:", boxElement.id); } }
        function toggleBrowserFullscreen(element) { /* ... keep existing ... */ if (!element) return; if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) { if (element.requestFullscreen) { element.requestFullscreen().catch(err => console.error(`FS Error: ${err.message} (${err.name})`)); } else if (element.webkitRequestFullscreen) { element.webkitRequestFullscreen(); } else if (element.mozRequestFullScreen) { element.mozRequestFullScreen(); } else if (element.msRequestFullscreen) { element.msRequestFullscreen(); } } else { if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } } }
        function updateFullscreenButtonState() { /* ... keep existing ... */ const isFullscreenActive = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); const buttons = document.querySelectorAll('.custom-fullscreen-btn'); buttons.forEach(btn => { const playerArea = btn.closest('.player-area'); const isThisPlayerAreaFullscreen = isFullscreenActive && (document.fullscreenElement === playerArea || document.webkitFullscreenElement === playerArea || document.mozFullScreenElement === playerArea || document.msFullscreenElement === playerArea); if (isThisPlayerAreaFullscreen) { btn.innerHTML = SVG_EXIT_FULLSCREEN; btn.setAttribute('aria-label', 'Exit Fullscreen'); btn.setAttribute('title', 'Exit Fullscreen'); } else { btn.innerHTML = SVG_ENTER_FULLSCREEN; btn.setAttribute('aria-label', 'Enter Fullscreen'); btn.setAttribute('title', 'Enter Fullscreen'); } }); }

        // --- Utility Functions ---
        function updateTimestampDisplay() { /* ... keep existing ... */ try { const now = new Date(); const timeString = new Intl.DateTimeFormat(navigator.language || 'en-US', { hour: '2-digit', minute: '2-digit' }).format(now); lastUpdatedTimestampElement.textContent = `Updated: ${timeString}`; } catch (error) { lastUpdatedTimestampElement.textContent = "Updated: Error"; } }
        function showInitialLoadingMessage(text = "Loading...") { /* ... keep existing ... */ initialLoadingMessageElement.textContent = text; initialLoadingMessageElement.style.display = 'block'; }
        function hideInitialLoadingMessage() { /* ... keep existing ... */ initialLoadingMessageElement.style.display = 'none'; }
        function showDataFetchErrorMessage(text = "An error occurred.") { /* ... keep existing ... */ dataFetchErrorMessageElement.innerHTML = `<strong>Error</strong><span>${text}</span>`; dataFetchErrorMessageElement.style.display = 'block'; }

    } // End of initializeApp() function
</script>

</body>
</html>

