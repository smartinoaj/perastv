<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        :root {
            /* True Grayscale/Black Theme */
            --bg-primary: #0a0a0a; /* Near black */
            --bg-secondary: #1a1a1a; /* Very dark gray */
            --bg-tertiary: #2a2a2a; /* Dark gray */
            --accent-color: #e50914; /* Netflix-like red */
            --text-primary: #ffffff; /* White */
            --text-secondary: #a0a0a0; /* Medium gray */
            --border-color: #3a3a3a; /* Gray for borders */
            --font-sans: 'Inter', sans-serif;
        }

        /* Basic Reset & Body Styling */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }
        body {
            background-color: var(--bg-primary); color: var(--text-primary);
            font-family: var(--font-sans); line-height: 1.6;
            overscroll-behavior-y: contain;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }

        /* Password Screen */
        #passwordScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-primary); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10000; padding: 20px;
        }
        #passwordScreen h2 { color: var(--text-primary); margin-bottom: 20px; font-weight: 600; font-size: 1.4em; }
        #passwordInput {
            padding: 14px 18px; font-size: 1em; border-radius: 8px;
            border: 1px solid var(--border-color); background-color: var(--bg-secondary);
            color: var(--text-primary); margin: 10px 0; width: 100%;
            max-width: 320px; text-align: center; transition: border-color 0.2s ease;
        }
        #passwordInput:focus { outline: none; border-color: var(--accent-color); }
        #passwordScreen button {
            padding: 14px 35px; font-size: 1em; border: none;
            background-color: var(--accent-color); color: white; border-radius: 8px;
            cursor: pointer; font-weight: 600; transition: background-color 0.2s ease;
            margin-top: 10px;
        }
        #passwordScreen button:hover { background-color: #b80710; }
        #errorMessage { color: #f87171; margin-top: 15px; display: none; font-weight: 500; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); } 25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); } 75% { transform: translateX(-6px); }
        }
        .shake { animation: shake 0.4s ease-in-out; }

        /* Main Container & Header */
        .container { max-width: 1500px; margin: 0 auto; padding: 0 20px; }
        header { text-align: center; padding: 30px 0 20px; }
        header img { max-width: 200px; height: auto; }

        /* Tabs */
        .tabs {
            display: flex; justify-content: center; gap: 12px;
            margin-bottom: 40px; flex-wrap: wrap; padding: 0 10px;
        }
        .tab-button {
            background: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-color); padding: 10px 25px; cursor: pointer;
            border-radius: 20px; /* Pill shape */
            font-size: 0.9em; font-weight: 600;
            transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .tab-button:hover { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--bg-tertiary); }
        .tab-button.active { background: var(--accent-color); color: white; border-color: var(--accent-color); }

        /* Channel Grid */
        .channel-grid {
            display: grid;
            /* Default: Auto-fill for smaller screens */
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px; padding: 0 10px 50px; display: none;
        }
        /* --- Grid Column Change --- */
        /* 2 columns for medium screens */
        @media (min-width: 768px) {
            .channel-grid:not(#Matches) { /* Exclude Matches grid */
                 grid-template-columns: repeat(2, 1fr);
            }
        }
        /* 3 columns for large screens */
         @media (min-width: 1024px) {
             .channel-grid:not(#Matches) { /* Exclude Matches grid */
                 grid-template-columns: repeat(3, 1fr);
            }
        }
        /* --- End Grid Column Change --- */

        .channel-grid.active { display: grid; }
        #Matches.channel-grid { /* Matches always stay single column */
             grid-template-columns: 1fr; max-width: 950px; margin: 0 auto;
        }
        #Matches.channel-grid.active { display: grid; }


        /* Channel Box */
        .channel-box {
            background: var(--bg-secondary); border-radius: 10px; padding: 18px;
            cursor: pointer; transition: all 0.3s ease;
            border: 1px solid var(--bg-secondary); position: relative; overflow: hidden;
        }
        .channel-box:not(.expanded):hover {
            transform: translateY(-4px); box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
            border-color: var(--border-color);
        }
        .channel-header { /* Clickable header */
            display: flex; align-items: center; justify-content: space-between;
            gap: 12px; text-align: left; min-height: 40px; cursor: pointer; /* Ensure header is clickable */
        }
        .channel-header .logos { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
        .channel-header img { height: 30px; width: auto; object-fit: contain; }
        .channel-header h3 {
            font-size: 1.05em; font-weight: 600; margin: 0; flex-grow: 1;
            word-break: break-word; text-align: center;
        }
        #Matches .channel-header h3 { text-align: center; }
        .match-time {
            font-size: 0.8em; color: var(--text-secondary); text-align: center;
            margin-top: 10px; margin-bottom: 0; font-weight: 500; cursor: pointer; /* Also clickable */
        }

        /* Expanded Channel Box Styling */
        .channel-box.expanded {
            grid-column: 1 / -1; /* Span full width */
            cursor: default;
            background: var(--bg-tertiary); /* Slightly lighter when expanded */
            padding-bottom: 25px; /* More space */
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-color: var(--accent-color);
            overflow: visible; /* Allow content to show */
        }
        /* Make header non-clickable when expanded */
        .channel-box.expanded .channel-header,
        .channel-box.expanded .match-time {
            cursor: default;
        }

        /* Iframe/Video Container inside the box */
        .iframe-container {
            margin-top: 20px; /* Space between header and player */
            display: none; /* Hidden by default */
            width: 100%;
        }
        .channel-box.expanded .iframe-container {
            display: block; /* Show when box is expanded */
        }

        .player-area {
            position: relative; width: 100%; aspect-ratio: 16 / 9;
            background-color: #000; border-radius: 8px; overflow: hidden;
            margin-bottom: 20px; min-height: 220px; /* Base min height */
        }
        .player-area iframe, .player-area video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: none; display: none; object-fit: contain;
        }
        .player-area iframe.active, .player-area video.active { display: block; }

        /* Responsive player height */
        @media (min-width: 768px) {
            .channel-box.expanded .player-area { min-height: 450px; max-height: 75vh; }
        }
         @media (min-width: 1024px) {
            .channel-box.expanded .player-area { min-height: 550px; }
        }

        /* Stream Buttons inside the box */
        .stream-buttons {
            text-align: center; margin-top: 15px; /* Space below player */
        }
        .stream-buttons div { margin-bottom: 10px; }
        .stream-buttons strong {
            color: var(--text-secondary); font-size: 0.85em; margin-right: 8px;
            font-weight: 600; text-transform: uppercase;
        }
        .stream-button {
            background: var(--bg-secondary); /* Use darker bg for buttons inside */
            color: var(--text-primary); border: 1px solid var(--border-color);
            padding: 7px 18px; /* Adjusted padding for rounded look */
            margin: 4px;
            /* --- Button Shape Change --- */
            border-radius: 20px; /* Pill shape like tabs */
            /* --- End Button Shape Change --- */
            cursor: pointer; font-size: 0.85em; font-weight: 500;
            transition: all 0.2s ease; display: inline-block;
        }
        .stream-button:hover { background: #4a4a4a; border-color: #5a5a5a; }
        .stream-button.active {
            background: var(--accent-color); color: white;
            border-color: var(--accent-color); font-weight: 600;
        }

        /* Footer */
        footer { text-align: center; color: var(--text-secondary); font-size: 0.8em; margin-top: 40px; padding-bottom: 25px; }

        /* Loading/Error States */
        .loading-message, .error-message { text-align: center; padding: 50px 20px; color: var(--text-secondary); font-size: 1em; font-weight: 500; }

        /* Responsive Adjustments */
        @media (max-width: 767px) { /* Adjusted breakpoint for 1 column */
             .channel-grid:not(#Matches) {
                 grid-template-columns: 1fr; /* Single column on small screens */
            }
            .channel-box { padding: 15px; }
            .stream-button { padding: 6px 15px; font-size: 0.8em; }
             header img { max-width: 160px; }
            .tabs { gap: 10px; margin-bottom: 30px; }
            .tab-button { padding: 8px 20px; font-size: 0.85em; }
            #Matches.channel-grid { max-width: 100%; }
        }
        @media (max-width: 480px) {
            .container { padding: 0 10px; }
            header img { max-width: 140px; }
            .tabs { gap: 8px; }
            .tab-button { padding: 7px 15px; }
            .channel-box { padding: 12px; }
            .channel-header h3 { font-size: 1em; }
            .channel-header img { height: 26px; }
            .stream-buttons strong { display: block; margin-bottom: 5px; }
            .player-area { min-height: 200px; }
        }

    </style>
</head>
<body>

<div id="passwordScreen">
    <h2>Enter Password</h2>
    <input type="password" id="passwordInput" placeholder="******">
    <button id="passwordButton">Enter</button>
    <p id="errorMessage">Incorrect Password!</p>
</div>

<div class="container">
    <header>
        <img src="ptvlogo.png" alt="PERAS TV Logo">
    </header>

    <div class="tabs">
        <button class="tab-button active" data-tab="PT">PT</button>
        <button class="tab-button" data-tab="UK">UK</button>
        <button class="tab-button" data-tab="ES">ES</button>
        <button class="tab-button" data-tab="Matches">Matches</button>
    </div>

    <div id="loadingMessage" class="loading-message">Loading channels...</div>
    <div id="fetchErrorMessage" class="error-message" style="display: none;"></div>

    <div id="PT" class="channel-grid active"></div>
    <div id="UK" class="channel-grid"></div>
    <div id="ES" class="channel-grid"></div>
    <div id="Matches" class="channel-grid"></div>

    <footer>
        <p id="lastUpdated"></p>
    </footer>
</div>

<script>
    // --- Configuration ---
    const CONFIG = {
        password: "ptv123",
        channelsUrl: "channels.json",
        matchesUrl: "matches.json",
        placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%23000000"/></svg>'
    };

    // --- DOM Elements ---
    const passwordScreen = document.getElementById('passwordScreen');
    const passwordInput = document.getElementById('passwordInput');
    const passwordButton = document.getElementById('passwordButton');
    const passwordErrorMessage = document.getElementById('errorMessage');
    const tabsContainer = document.querySelector('.tabs');
    const channelGrids = document.querySelectorAll('.channel-grid');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const loadingMessage = document.getElementById('loadingMessage');
    const fetchErrorMessage = document.getElementById('fetchErrorMessage');

    // --- State ---
    let hlsInstance = null;
    let channelsData = {};
    let matchesData = [];
    let currentlyExpandedBox = null; // Track the currently expanded box

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        setupPasswordProtection();
        setupEventListeners();
        updateTimestamp();
        loadData();
    });

    // --- Password Protection ---
    function setupPasswordProtection() {
        if (sessionStorage.getItem('authenticated') === 'true') {
            hidePasswordScreen();
        } else {
            document.body.style.overflow = 'hidden';
            passwordScreen.style.display = 'flex';
            passwordInput.focus();
        }
    }

    function verifyPassword() {
        if (passwordInput.value === CONFIG.password) {
            sessionStorage.setItem('authenticated', 'true');
            hidePasswordScreen();
        } else {
            passwordErrorMessage.style.display = 'block';
            passwordInput.classList.add('shake');
            passwordInput.value = '';
            passwordInput.focus();
            setTimeout(() => passwordInput.classList.remove('shake'), 500);
        }
    }

    function hidePasswordScreen() {
        passwordScreen.style.display = 'none';
        document.body.style.overflow = '';
    }

    // --- Event Listeners ---
    function setupEventListeners() {
        // Password
        passwordButton.addEventListener('click', verifyPassword);
        passwordInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') verifyPassword();
            passwordErrorMessage.style.display = 'none';
        });

        // Tabs
        tabsContainer.addEventListener('click', (event) => {
            if (event.target.classList.contains('tab-button')) {
                showTab(event.target.dataset.tab);
            }
        });

        // Close expanded box with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && currentlyExpandedBox) {
                 toggleExpansion(currentlyExpandedBox); // Collapse the current box
            }
        });
    }

    // --- Data Fetching & Rendering ---
    async function loadData() {
        loadingMessage.style.display = 'block';
        fetchErrorMessage.style.display = 'none';
        try {
            const cacheBuster = `?t=${Date.now()}`;
            const [channelsRes, matchesRes] = await Promise.all([
                fetch(CONFIG.channelsUrl + cacheBuster),
                fetch(CONFIG.matchesUrl + cacheBuster)
            ]);

            if (!channelsRes.ok || !matchesRes.ok) {
                throw new Error(`Failed to load data (Channels: ${channelsRes.status}, Matches: ${matchesRes.status})`);
            }

            channelsData = await channelsRes.json();
            matchesData = await matchesRes.json();

            renderAllChannels();
            loadingMessage.style.display = 'none';

        } catch (error) {
            console.error("Failed to load channel or match data:", error);
            loadingMessage.style.display = 'none';
            fetchErrorMessage.textContent = `Error loading data: ${error.message}. Please try refreshing.`;
            fetchErrorMessage.style.display = 'block';
        }
    }

    function renderAllChannels() {
        renderChannels('PT', channelsData.PT || []);
        renderChannels('UK', channelsData.UK || []);
        renderChannels('ES', channelsData.ES || []);
        renderMatchChannels(matchesData || []);
        addChannelBoxEventListeners(); // Add listeners *after* elements are in the DOM
    }

    function renderChannels(tabId, channels) {
        const grid = document.getElementById(tabId);
        if (!grid) return;
        grid.innerHTML = '';
        if (!channels || channels.length === 0) {
            grid.innerHTML = '<p class="loading-message">No channels available.</p>';
            return;
        }
        channels.forEach((channel) => {
            const box = createChannelBoxElement(channel);
            grid.appendChild(box);
        });
    }

    function renderMatchChannels(matches) {
        const grid = document.getElementById('Matches');
        if (!grid) return;
        grid.innerHTML = '';
         if (!matches || matches.length === 0) {
            grid.innerHTML = '<p class="loading-message">No matches available.</p>';
            return;
        }
        matches.forEach((match) => {
            const box = createMatchBoxElement(match);
            grid.appendChild(box);
        });
    }

    // --- Element Creation ---
    function createChannelBoxElement(channel) {
        const { name, srcs = [] } = channel;
        const box = document.createElement('div');
        box.className = 'channel-box';
        box.dataset.channelName = name;
        box.dataset.sources = JSON.stringify(srcs);

        box.innerHTML = `
            <div class="channel-header">
                <h3>${name}</h3>
            </div>
            <div class="iframe-container">
                <div class="player-area">
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons">
                    </div>
            </div>
        `;
        return box;
    }

     function createMatchBoxElement(match) {
        const { team1, team2, logo1 = '', logo2 = '', time = '', pt = [], uk = [], es = [] } = match;
        const box = document.createElement('div');
        box.className = 'channel-box';
        const allSources = { pt, uk, es };
        box.dataset.channelName = `${team1} vs ${team2}`;
        box.dataset.sources = JSON.stringify(allSources);

        box.innerHTML = `
            <div class="channel-header">
                 <div class="logos">
                    ${logo1 ? `<img src="${logo1}" alt="${team1} logo">` : '<span style="width:30px;"></span>'}
                </div>
                <h3>${team1} vs ${team2}</h3>
                 <div class="logos">
                    ${logo2 ? `<img src="${logo2}" alt="${team2} logo">` : '<span style="width:30px;"></span>'}
                 </div>
            </div>
            ${time ? `<p class="match-time">${time}</p>` : ''}
             <div class="iframe-container">
                 <div class="player-area">
                    <iframe allow="autoplay; fullscreen" allowfullscreen title="Stream Player"></iframe>
                    <video controls autoplay muted playsinline title="Stream Player"></video>
                </div>
                <div class="stream-buttons">
                    </div>
            </div>
        `;
        return box;
    }

    // --- Event Listener Setup for Channel Boxes ---
    function addChannelBoxEventListeners() {
         document.querySelectorAll('.channel-box').forEach(box => {
             // Click listener for the non-player part of the box
            box.addEventListener('click', (event) => {
                // Only toggle if the click is directly on the box or its header/time elements,
                // and the box is NOT already expanded.
                const isExpanded = box.classList.contains('expanded');
                const isClickOnPlayerArea = event.target.closest('.iframe-container');

                if (!isExpanded && !isClickOnPlayerArea) {
                    toggleExpansion(box);
                } else if (isExpanded && !isClickOnPlayerArea) {
                    // If it IS expanded, clicking outside the player area collapses it
                    toggleExpansion(box);
                }
                // Clicks inside the player area are ignored here (no propagation needed)
            });
        });
    }

    // --- Tab Management ---
    function showTab(tabId) {
        tabsContainer.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });
        channelGrids.forEach(grid => {
            grid.classList.toggle('active', grid.id === tabId);
        });
        // Collapse any open channel when switching tabs
        if (currentlyExpandedBox) {
            collapseBox(currentlyExpandedBox);
        }
    }

    // --- Channel Box Expansion ---
    function toggleExpansion(boxToToggle) {
        const isExpanding = !boxToToggle.classList.contains('expanded');

        // If another box is already expanded, collapse it first
        if (isExpanding && currentlyExpandedBox && currentlyExpandedBox !== boxToToggle) {
            collapseBox(currentlyExpandedBox);
        }

        // Toggle the target box
        if (isExpanding) {
            expandBox(boxToToggle);
        } else {
            collapseBox(boxToToggle);
        }
    }

    function expandBox(box) {
        box.classList.add('expanded');
        currentlyExpandedBox = box;

        // Populate buttons and load first stream
        populateAndLoadFirstStream(box);

        // Scroll the box into view smoothly after a short delay to allow rendering
        setTimeout(() => {
             box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100); // Adjust delay if needed
    }

    function collapseBox(box) {
        box.classList.remove('expanded');
        if (currentlyExpandedBox === box) {
            currentlyExpandedBox = null;
        }
        // Clear player when collapsing
        clearPlayerInBox(box);
        // Clear buttons
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.innerHTML = '';
        }
    }

    function populateAndLoadFirstStream(box) {
        const sourcesData = box.dataset.sources;
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (!sourcesData || !streamButtonsDiv) return;

        streamButtonsDiv.innerHTML = ''; // Clear previous buttons
        let firstUrl = null;

        try {
            const sources = JSON.parse(sourcesData);

            if (Array.isArray(sources)) { // Regular channels
                if (sources.length > 0) {
                    sources.forEach((src, idx) => {
                        const url = typeof src === 'object' ? src.url : src;
                        const label = typeof src === 'object' ? src.label : `Source ${idx + 1}`;
                        if (!firstUrl) firstUrl = url;
                        const button = createStreamButton(label, url, box); // Pass box context
                        streamButtonsDiv.appendChild(button);
                    });
                } else {
                     streamButtonsDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">No streams available.</p>';
                }
            } else { // Match sources (object)
                let streamCount = 0;
                Object.entries(sources).forEach(([lang, langSources]) => {
                    if (langSources && langSources.length > 0) {
                        const langDiv = document.createElement('div');
                        const strong = document.createElement('strong');
                        strong.textContent = `${lang.toUpperCase()}:`;
                        langDiv.appendChild(strong);
                        langSources.forEach((src, idx) => {
                            const url = typeof src === 'object' ? src.url : src;
                            const label = typeof src === 'object' ? src.label : `${idx + 1}`;
                            if (!firstUrl) firstUrl = url;
                            const button = createStreamButton(label, url, box); // Pass box context
                            langDiv.appendChild(button);
                            streamCount++;
                        });
                        streamButtonsDiv.appendChild(langDiv);
                    }
                });
                 if (streamCount === 0) {
                     streamButtonsDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">No streams available.</p>';
                }
            }

            // Load the first stream if found
            if (firstUrl) {
                 const firstButton = streamButtonsDiv.querySelector('.stream-button');
                 if (firstButton) {
                     changeStream(firstButton, firstUrl, box);
                 }
            } else {
                clearPlayerInBox(box); // No streams, ensure player is cleared
            }

        } catch (e) {
            console.error("Failed to parse sources data for box:", e);
            streamButtonsDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">Error loading stream data.</p>';
        }
    }

    function createStreamButton(label, url, contextBox) {
        const button = document.createElement('button');
        button.className = 'stream-button';
        button.textContent = label;
        button.onclick = (event) => {
            // No stopPropagation needed here as the parent listener handles it
            changeStream(button, url, contextBox);
        };
        return button;
    }

    // --- Stream Handling (within a specific box) ---
    function changeStream(clickedButton, url, contextBox) {
        console.log(`Attempting to load stream in box: ${url}`);
        clearPlayerInBox(contextBox); // Clear previous stream in this box

        // Activate the clicked button within this box
        const streamButtonsDiv = contextBox.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
             streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
        clickedButton.classList.add('active');

        // Get player elements specific to this box
        const iframe = contextBox.querySelector('.player-area iframe');
        const video = contextBox.querySelector('.player-area video');

        if (!iframe || !video) {
            console.error("Could not find player elements in context box.");
            return;
        }

        // Determine stream type and load
        if (url && typeof url === 'string') {
             if (url.toLowerCase().endsWith('.m3u8')) {
                loadHlsStream(url, video); // Pass the specific video element
            } else {
                loadIframeStream(url, iframe); // Pass the specific iframe element
            }
        } else {
            console.error("Invalid stream URL:", url);
            alert("Invalid stream URL provided.");
            clearPlayerInBox(contextBox); // Clear player if URL is bad
        }
    }

     function clearPlayerInBox(box) {
         // Stop HLS playback if it belongs to this box
        if (hlsInstance && currentlyExpandedBox === box) {
            hlsInstance.destroy();
            hlsInstance = null;
        }
        // Clear iframe src
        const iframe = box.querySelector('.player-area iframe');
        if (iframe) {
             iframe.src = 'about:blank';
             iframe.classList.remove('active');
        }
        // Clear video src and stop
        const video = box.querySelector('.player-area video');
        if (video) {
             video.pause();
             video.removeAttribute('src');
             video.load();
             video.classList.remove('active');
             video.poster = ''; // Remove placeholder
        }
        // Deactivate buttons in this box
        const streamButtonsDiv = box.querySelector('.stream-buttons');
        if (streamButtonsDiv) {
            streamButtonsDiv.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active'));
        }
    }

    function loadHlsStream(url, videoElement) {
        videoElement.poster = CONFIG.placeholderImage;
        videoElement.classList.add('active');

        if (Hls.isSupported()) {
            console.log("HLS.js is supported. Initializing...");
            // Ensure previous instance related to this box context is destroyed
            if (hlsInstance && currentlyExpandedBox === videoElement.closest('.channel-box')) {
                 hlsInstance.destroy();
            }

            hlsInstance = new Hls({ /* Optional config */ });

            hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                console.error('HLS.js Error:', event, data);
                 if (data.fatal) {
                    let userMessage = `Stream Error (${data.details}). Try another source.`;
                    if (data.type === Hls.ErrorTypes.NETWORK_ERROR) userMessage = `Network Error loading stream (${data.details}). Check connection or try another source.`;
                    else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) userMessage = `Media Playback Error (${data.details}). Try another source.`;
                    alert(userMessage);
                    if(hlsInstance) hlsInstance.destroy(); hlsInstance = null;
                    videoElement.classList.remove('active'); videoElement.poster = '';
                 }
            });

            hlsInstance.loadSource(url);
            hlsInstance.attachMedia(videoElement);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                console.log("HLS Manifest parsed, attempting to play...");
                videoElement.play().catch(e => console.error("Video play failed:", e));
            });

        } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
            console.log("Using native HLS support.");
            videoElement.src = url;
            videoElement.play().catch(e => console.error("Video play failed:", e));
        } else {
            console.error("HLS is not supported by this browser.");
            alert("HLS playback is not supported in your browser.");
            videoElement.classList.remove('active'); videoElement.poster = '';
        }
    }

    function loadIframeStream(url, iframeElement) {
        console.log("Loading iframe stream...");
        iframeElement.src = url;
        iframeElement.classList.add('active');
        iframeElement.onload = () => console.log("Iframe onload event fired.");
        iframeElement.onerror = () => {
             console.error("Iframe onerror event fired.");
             alert("Failed to load the iframe source. It might be blocked or unavailable.");
             iframeElement.classList.remove('active');
        };
    }

    // --- Utility ---
    function updateTimestamp() {
        const now = new Date();
        lastUpdatedEl.textContent = `Updated: ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
    }

</script>

</body>
</html>
