<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peras TV</title>
    <link rel="icon" type="image/png" href="ptv.png">

    <link rel="preconnect" href="https://playmatch.live">
    <link rel="preconnect" href="https://thedaddy.to">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css"> <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- Password Protection Styles --- */
        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary); /* Match body background */
            z-index: 1000; /* Ensure it's on top */
            display: flex; /* Hidden by default, shown via JS if needed */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
        }
        #password-form {
            background-color: var(--bg-secondary);
            padding: 30px 40px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #password-form label {
            display: block;
            margin-bottom: 10px;
            color: var(--text-primary);
            font-weight: 500;
        }
        #password-input {
            padding: 10px 15px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            margin-bottom: 20px;
            width: 100%;
            max-width: 250px; /* Limit width */
        }
         #password-input:focus {
            outline: none;
            border-color: var(--border-color-active);
         }
        #password-submit {
            padding: 10px 25px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #password-submit:hover {
            background-color: #c40812; /* Darker accent */
        }
        #password-error {
            color: var(--error-color);
            margin-top: 15px;
            font-size: 0.9em;
            min-height: 1.2em; /* Prevent layout shift */
        }
        /* Hide main content initially */
        .main-container {
            display: none; /* Hidden by default, shown via JS */
        }
        /* Initially hide the password overlay, JS will show if needed */
        #password-overlay.hidden {
             display: none;
        }
        /* Fallback message div - not actively used but kept for structure */
        #devtools-detected-message {
            display: none;
        }

        /* --- Toggle Switch Styles (Shared) --- */
        /* Styles moved to style.css */

        /* Reminder: Optimize images (logos) for faster loading */
        /* Consider using tools like TinyPNG or Squoosh */
    </style>
    </head>
<body>

<div id="devtools-detected-message"></div>

<div id="password-overlay" class="hidden">
    <form id="password-form">
        <label for="password-input">Enter Access Key</label>
        <input type="password" id="password-input" required>
        <button type="submit" id="password-submit">Enter</button>
        <p id="password-error"></p>
    </form>
</div>

<div class="main-container">
    <div class="container">
        <header>
            <img src="ptvlogo.png" alt="PERAS TV Logo">
        </header>

        <div class="search-container">
            <input type="search" id="search-input" placeholder="Search channels or matches..." aria-label="Search channels or matches">
        </div>

        <div class="tabs" role="tablist" aria-label="Content Categories">
            <button class="tab-button" data-tab="Favorites" role="tab" aria-controls="Favorites" aria-selected="false" aria-label="Favorites">
                 <svg class="tab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                     <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                 </svg>
                 </button>
            <button class="tab-button" data-tab="ALL" role="tab" aria-controls="ALL" aria-selected="false">ALL</button> <button class="tab-button" data-tab="PT" role="tab" aria-controls="PT" aria-selected="false">PT</button>
            <button class="tab-button" data-tab="UK" role="tab" aria-controls="UK" aria-selected="false">UK</button>
            <button class="tab-button" data-tab="ES" role="tab" aria-controls="ES" aria-selected="false">ES</button>
            <button class="tab-button" data-tab="Matches" role="tab" aria-controls="Matches" aria-selected="false">Matches</button>
        </div>

        <div class="toggles-container">
            <div class="toggle-switch-container" id="toggle-new-tab-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="open-in-new-tab-toggle">
                    <span class="slider"></span>
                </label>
                <label for="open-in-new-tab-toggle">Open source in new tab</label>
            </div>

            <div class="toggle-switch-container" id="toggle-player-page-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="open-in-player-page-toggle">
                    <span class="slider"></span>
                </label>
                <label for="open-in-player-page-toggle">Open player page in new tab</label>
            </div>
        </div>
        <div id="loadingMessage" class="status-message loading" role="status">Loading channels...</div>
        <div id="fetchErrorMessage" class="status-message error" role="alert" style="display: none;"></div>

        <div id="Favorites" class="channel-grid" role="tabpanel" aria-labelledby="tab-Favorites" tabindex="-1"></div>
        <div id="ALL" class="channel-grid active" role="tabpanel" aria-labelledby="tab-ALL" tabindex="0"></div>
        <div id="PT" class="channel-grid" role="tabpanel" aria-labelledby="tab-PT" tabindex="-1"></div>
        <div id="UK" class="channel-grid" role="tabpanel" aria-labelledby="tab-UK" tabindex="-1"></div>
        <div id="ES" class="channel-grid" role="tabpanel" aria-labelledby="tab-ES" tabindex="-1"></div>
        <div id="Matches" class="channel-grid" role="tabpanel" aria-labelledby="tab-Matches" tabindex="-1"></div>

    </div>

    <footer>
        <p id="lastUpdated">Updated: Fetching time...</p>
        <p class="footer-disclaimer">
            <strong>Disclaimer:</strong> PerasTV does not host any video content. All streams are embedded from external, publicly available sources found on the internet. We are not responsible for the legality, accuracy, or quality of the content provided by these third-party sites. Users are advised to respect copyright laws and use this service responsibly. Stream availability is not guaranteed.
        </p>
    </footer>
</div>
<script>
    // --- Console Access Deterrents (Run Immediately) ---
    function setupConsoleDeterrents() {
        document.addEventListener('contextmenu', (event) => event.preventDefault());
        document.addEventListener('keydown', (event) => {
            if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) || (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                event.preventDefault();
            }
        });
        console.log("Basic console access deterrents initialized.");
    }
    setupConsoleDeterrents();

    const PERSONAL_USE_B64 = "cHR2"; // Replace with your actual Base64 key if needed
    const AUTH_KEY = 'perasTvAuthenticated';

    const passwordOverlay = document.getElementById('password-overlay');
    const passwordForm = document.getElementById('password-form');
    const passwordInput = document.getElementById('password-input');
    const passwordError = document.getElementById('password-error');
    const mainContainer = document.querySelector('.main-container');

    // --- Authentication Check ---
    if (sessionStorage.getItem(AUTH_KEY) === 'true') {
        console.log("Already authenticated.");
        passwordOverlay.classList.add('hidden');
        mainContainer.style.display = 'block';
        initializeApp();
    } else {
        if (typeof PERSONAL_USE_B64 === 'undefined' || PERSONAL_USE_B64 === "PASTE_YOUR_BASE64_PASSWORD_HERE" || PERSONAL_USE_B64 === "") {
             console.error("ERROR: PERSONAL_USE_B64 is not set correctly.");
             passwordOverlay.innerHTML = '<p style="color:var(--error-color); text-align:center;">Configuration Error: Access key not set.</p>';
             passwordOverlay.classList.remove('hidden');
        } else {
            console.log("Authentication required.");
            passwordOverlay.classList.remove('hidden');
            passwordInput.focus();
            passwordForm.addEventListener('submit', (event) => {
                event.preventDefault();
                const enteredValue = passwordInput.value;
                let correctKey = "";
                try { correctKey = atob(PERSONAL_USE_B64); } catch (e) {
                    console.error("Error decoding Base64 key:", e);
                    passwordError.textContent = 'Configuration Error'; return;
                }
                if (enteredValue === correctKey) {
                    console.log("Access key correct.");
                    sessionStorage.setItem(AUTH_KEY, 'true');
                    passwordOverlay.classList.add('hidden');
                    mainContainer.style.display = 'block';
                    initializeApp();
                } else {
                    console.log("Incorrect access key.");
                    passwordError.textContent = 'Incorrect Access Key';
                    passwordInput.value = ''; passwordInput.focus();
                }
            });
        }
    }

    /* --- PerasTV Main Application Logic --- */
    function initializeApp() {
        if (window.appInitialized) return;
        window.appInitialized = true;
        console.log("Initializing PerasTV App...");

        // --- Configuration Constants ---
        const CONFIG = {
            channelsUrl: "channels.json",
            matchesUrl: "matches.json",
            placeholderImage: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="9" viewBox="0 0 16 9"><rect width="16" height="9" fill="%231a1a1a"/></svg>',
            searchDebounceMs: 300,
            lastTabKey: 'perasTvLastTab',
            favoritesKey: 'perasTvFavorites',
            iframeLoadTimeoutMs: 35000,
            openInNewTabKey: 'perasTvOpenInNewTab',       // Key for first toggle
            openInPlayerPageKey: 'perasTvOpenPlayerPage' // Key for second toggle
        };

        // --- DOM Element References ---
        const searchInputElement = document.getElementById('search-input');
        const tabsContainerElement = document.querySelector('.tabs');
        const channelGridElements = document.querySelectorAll('.channel-grid');
        const lastUpdatedTimestampElement = document.getElementById('lastUpdated');
        const initialLoadingMessageElement = document.getElementById('loadingMessage');
        const dataFetchErrorMessageElement = document.getElementById('fetchErrorMessage');
        const openInNewTabToggleElement = document.getElementById('open-in-new-tab-toggle');
        const openInPlayerPageToggleElement = document.getElementById('open-in-player-page-toggle');

        // --- Application State ---
        let currentHlsInstance = null;
        let allChannelsData = {};
        let allMatchesData = [];
        let currentlyExpandedBoxElement = null;
        let searchDebounceTimerId = null;
        let activeTabId = 'ALL';
        let favoriteItemIds = [];
        let openInNewTabEnabled = false;
        let openInPlayerPageEnabled = false;

        // --- Disclaimer Text ---
        const BOX_DISCLAIMER_TEXT = `Disclaimer: This site embeds content from external sources. We do not host streams. Availability and quality not guaranteed. Use responsibly.`;

        // --- SVG Icons for Fullscreen Button ---
        const SVG_ENTER_FULLSCREEN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"> <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> </svg>`;
        const SVG_EXIT_FULLSCREEN = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20px" height="20px"> <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/> </svg>`;

        // --- Initial Setup ---
        loadFavoritesFromStorage();
        loadToggleStates(); // Load state for both toggles
        setupGlobalEventListeners();
        updateTimestampDisplay();
        setInterval(updateTimestampDisplay, 60000);
        fetchAndRenderData();


        // --- Favorite Management ---
        function loadFavoritesFromStorage() { /* ... (keep existing code) ... */
            const storedFavoritesJson = localStorage.getItem(CONFIG.favoritesKey); if (storedFavoritesJson) { try { const parsedFavorites = JSON.parse(storedFavoritesJson); if (Array.isArray(parsedFavorites) && parsedFavorites.every(item => typeof item === 'string')) { favoriteItemIds = parsedFavorites; } else { console.warn("Invalid favorites data found. Resetting."); favoriteItemIds = []; localStorage.removeItem(CONFIG.favoritesKey); } } catch (error) { console.error("Error parsing favorites:", error); favoriteItemIds = []; } } else { favoriteItemIds = []; } console.log("Loaded favorites:", favoriteItemIds);
        }
        function saveFavoritesToStorage() { /* ... (keep existing code) ... */
            try { localStorage.setItem(CONFIG.favoritesKey, JSON.stringify(favoriteItemIds)); console.log("Saved favorites:", favoriteItemIds); } catch (error) { console.error("Error saving favorites:", error); }
        }
        function toggleFavoriteStatus(itemId, starButtonElement) { /* ... (keep existing code) ... */
            if (!itemId || !starButtonElement) return; const itemIndex = favoriteItemIds.indexOf(itemId); const isCurrentlyFavorite = itemIndex > -1; if (isCurrentlyFavorite) { favoriteItemIds.splice(itemIndex, 1); starButtonElement.classList.remove('is-favorite'); starButtonElement.setAttribute('aria-pressed', 'false'); starButtonElement.setAttribute('aria-label', 'Add to Favorites'); } else { favoriteItemIds.push(itemId); starButtonElement.classList.add('is-favorite'); starButtonElement.setAttribute('aria-pressed', 'true'); starButtonElement.setAttribute('aria-label', 'Remove from Favorites'); } saveFavoritesToStorage(); document.querySelectorAll(`.channel-box#${CSS.escape(itemId)} .favorite-button`).forEach(otherStar => { if (otherStar !== starButtonElement) { otherStar.classList.toggle('is-favorite', !isCurrentlyFavorite); otherStar.setAttribute('aria-pressed', !isCurrentlyFavorite ? 'true' : 'false'); otherStar.setAttribute('aria-label', !isCurrentlyFavorite ? 'Remove from Favorites' : 'Add to Favorites'); } }); if (activeTabId === 'Favorites') { renderFavoritesTabContent(); addChannelBoxEventListeners(document.getElementById('Favorites')); }
        }

        // --- Toggle State Management ---
        function loadToggleStates() { /* ... (keep existing code) ... */
            const storedNewTabState = localStorage.getItem(CONFIG.openInNewTabKey); const storedPlayerPageState = localStorage.getItem(CONFIG.openInPlayerPageKey); openInNewTabEnabled = (storedNewTabState === 'true'); openInPlayerPageEnabled = (storedPlayerPageState === 'true'); if (openInNewTabEnabled && openInPlayerPageEnabled) { console.warn("Both toggles were saved as active. Defaulting to 'Player Page'."); openInNewTabEnabled = false; saveToggleStates(); } if (openInNewTabToggleElement) openInNewTabToggleElement.checked = openInNewTabEnabled; if (openInPlayerPageToggleElement) openInPlayerPageToggleElement.checked = openInPlayerPageEnabled; console.log(`Loaded 'Open source in new tab' state: ${openInNewTabEnabled}`); console.log(`Loaded 'Open player page in new tab' state: ${openInPlayerPageEnabled}`);
        }
        function saveToggleStates() { /* ... (keep existing code) ... */
            try { localStorage.setItem(CONFIG.openInNewTabKey, openInNewTabEnabled); localStorage.setItem(CONFIG.openInPlayerPageKey, openInPlayerPageEnabled); console.log(`Saved toggle states: NewTab=${openInNewTabEnabled}, PlayerPage=${openInPlayerPageEnabled}`); } catch (error) { console.error("Error saving toggle states to localStorage:", error); }
        }

        // --- Event Listener Setup ---
        function setupGlobalEventListeners() {
            // Tabs
            tabsContainerElement.addEventListener('click', (event) => { const tabButton = event.target.closest('.tab-button[data-tab]'); if (tabButton) activateTab(tabButton.dataset.tab); });
            // Search
            searchInputElement.addEventListener('input', (event) => { clearTimeout(searchDebounceTimerId); searchDebounceTimerId = setTimeout(() => filterVisibleContent(event.target.value), CONFIG.searchDebounceMs); });
            // Toggles (Refined logic)
            if (openInNewTabToggleElement) { openInNewTabToggleElement.addEventListener('change', (event) => { const isChecked = event.target.checked; openInNewTabEnabled = isChecked; if (isChecked && openInPlayerPageToggleElement) { openInPlayerPageToggleElement.checked = false; openInPlayerPageEnabled = false; } saveToggleStates(); console.log(`'Open source in new tab' toggled: ${openInNewTabEnabled}`); }); }
            if (openInPlayerPageToggleElement) { openInPlayerPageToggleElement.addEventListener('change', (event) => { const isChecked = event.target.checked; openInPlayerPageEnabled = isChecked; if (isChecked && openInNewTabToggleElement) { openInNewTabToggleElement.checked = false; openInNewTabEnabled = false; } saveToggleStates(); console.log(`'Open player page in new tab' toggled: ${openInPlayerPageEnabled}`); }); }
            // Keyboard
            document.addEventListener('keydown', (event) => { /* ... (keep existing keyboard nav logic, box activation moved) ... */
                 if (event.key === 'Escape' && currentlyExpandedBoxElement) { collapseItemBox(currentlyExpandedBoxElement); }
                 // --- NEW: Handle Escape key for fullscreen exit ---
                 if (event.key === 'Escape' && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
                     // Browser usually handles this, but we can ensure our state updates
                     updateFullscreenButtonState();
                 }
                 // --- End NEW ---
                 const focusableElements = getFocusableElementsInActiveGrid(); const currentIndex = focusableElements.indexOf(document.activeElement);
                 if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) { if (document.activeElement && document.activeElement.closest('.channel-box') && !currentlyExpandedBoxElement) { event.preventDefault(); let nextIndex = -1; const activeGrid = document.getElementById(activeTabId); const numCols = activeGrid ? getComputedStyle(activeGrid).gridTemplateColumns.split(' ').length : 1; switch (event.key) { case 'ArrowDown': nextIndex = currentIndex + numCols; break; case 'ArrowUp': nextIndex = currentIndex - numCols; break; case 'ArrowRight': nextIndex = (currentIndex + 1) % numCols === 0 && numCols > 1 ? -1 : currentIndex + 1; break; case 'ArrowLeft': nextIndex = currentIndex % numCols === 0 && numCols > 1 ? -1 : currentIndex - 1; break; } if (nextIndex >= 0 && nextIndex < focusableElements.length) { focusableElements[nextIndex].focus(); } } else if (!document.activeElement || document.activeElement === document.body || document.activeElement === searchInputElement || document.activeElement.closest('.tabs')) { focusableElements[0]?.focus(); } }
                 if (event.key === 'Enter' || event.key === 'Ok') { if (document.activeElement && document.activeElement.classList.contains('stream-button')) { event.preventDefault(); document.activeElement.click(); } else if (document.activeElement && document.activeElement.classList.contains('tab-button')) { event.preventDefault(); document.activeElement.click(); } else if (document.activeElement && document.activeElement.classList.contains('favorite-button')) { event.preventDefault(); document.activeElement.click(); } }
            });
            // --- NEW: Listen for fullscreen changes globally ---
            document.addEventListener('fullscreenchange', updateFullscreenButtonState);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButtonState);
            document.addEventListener('mozfullscreenchange', updateFullscreenButtonState);
            document.addEventListener('MSFullscreenChange', updateFullscreenButtonState);
            // --- End NEW ---
        }
        function getFocusableElementsInActiveGrid() { /* ... (keep existing code) ... */
            const activeGrid = document.getElementById(activeTabId); if (!activeGrid) return []; return Array.from(activeGrid.querySelectorAll(':scope > .channel-box:not(.hidden):not(.expanded)'));
        }

        // --- Data Fetching & Rendering ---
        async function fetchAndRenderData() { /* ... (keep existing code) ... */
            showInitialLoadingMessage("Loading channels and matches..."); dataFetchErrorMessageElement.style.display = 'none'; try { const cacheBuster = `?t=${Date.now()}`; const channelsUrl = CONFIG.channelsUrl + cacheBuster; const matchesUrl = CONFIG.matchesUrl + cacheBuster; const [channelsResponse, matchesResponse] = await Promise.all([ fetch(channelsUrl), fetch(matchesUrl) ]); if (!channelsResponse.ok) throw new Error(`Failed to load channels: ${channelsResponse.status} ${channelsResponse.statusText}`); if (!matchesResponse.ok) throw new Error(`Failed to load matches: ${matchesResponse.status} ${matchesResponse.statusText}`); allChannelsData = await channelsResponse.json(); allMatchesData = await matchesResponse.json(); if (typeof allChannelsData !== 'object' || allChannelsData === null) throw new Error("Invalid channels data format."); if (!Array.isArray(allMatchesData)) throw new Error("Invalid matches data format."); console.log("Data fetched successfully:", { channels: allChannelsData, matches: allMatchesData }); renderAllContentGrids(); hideInitialLoadingMessage(); const lastSavedTabId = localStorage.getItem(CONFIG.lastTabKey); const validTabIds = Array.from(tabsContainerElement.querySelectorAll('.tab-button')).map(btn => btn.dataset.tab); activateTab(validTabIds.includes(lastSavedTabId) ? lastSavedTabId : 'ALL'); } catch (error) { console.error("Data loading failed:", error); hideInitialLoadingMessage(); showDataFetchErrorMessage(`Error loading data: ${error.message}. Please try refreshing.`); }
        }
        function renderAllContentGrids() { /* ... (keep existing code) ... */
             console.log("Rendering all content grids..."); renderSpecificGridContent('PT', allChannelsData.PT || [], 'channel'); renderSpecificGridContent('UK', allChannelsData.UK || [], 'channel'); renderSpecificGridContent('ES', allChannelsData.ES || [], 'channel'); renderSpecificGridContent('Matches', allMatchesData || [], 'match'); renderAllTabContent(); renderFavoritesTabContent(); addChannelBoxEventListeners();
        }
        function renderSpecificGridContent(gridId, items, itemType) { /* ... (keep existing code, generates uniqueItemId) ... */
            const gridElement = document.getElementById(gridId); if (!gridElement) return; gridElement.innerHTML = ''; if (!items || items.length === 0) { let emptyMessage = `No ${itemType === 'match' ? 'matches' : 'channels'} listed.`; if (gridId === 'Favorites') emptyMessage = 'Favorites list is empty. Click ☆ to add.'; gridElement.innerHTML = `<p class="status-message info">${emptyMessage}</p>`; return; } const fragment = document.createDocumentFragment(); items.forEach((itemData) => { let itemElement = null; let uniqueItemId = null; if (itemType === 'match') { const globalMatchIndex = allMatchesData.findIndex(m => m === itemData); if (globalMatchIndex !== -1) { uniqueItemId = `match-${globalMatchIndex}`; itemElement = createMatchBoxElement(itemData, uniqueItemId); } } else { let category = ''; let categoryIndex = -1; for (const key in allChannelsData) { const index = allChannelsData[key]?.indexOf(itemData); if (index !== -1 && index !== undefined) { category = key; categoryIndex = index; break; } } if (category && categoryIndex !== -1) { uniqueItemId = `${category}-channel-${categoryIndex}`; itemElement = createChannelBoxElement(itemData, uniqueItemId); } } if (itemElement) fragment.appendChild(itemElement); else console.warn(`Failed to create element for item in grid ${gridId}`); }); gridElement.appendChild(fragment);
        }
        function renderAllTabContent() { /* ... (keep existing code) ... */
            const allGridElement = document.getElementById('ALL'); if (!allGridElement) return; allGridElement.innerHTML = ''; const fragment = document.createDocumentFragment(); let contentAdded = false; if (allMatchesData && allMatchesData.length > 0) { allMatchesData.forEach((match, index) => { const uniqueId = `match-${index}`; const box = createMatchBoxElement(match, uniqueId); if(box) { fragment.appendChild(box); contentAdded = true; } }); } ['PT', 'UK', 'ES'].forEach(category => { const channelsInCategory = allChannelsData[category] || []; if (channelsInCategory.length > 0) { channelsInCategory.forEach((channel, index) => { const uniqueId = `${category}-channel-${index}`; const box = createChannelBoxElement(channel, uniqueId); if(box) { fragment.appendChild(box); contentAdded = true; } }); } }); allGridElement.appendChild(fragment); if (!contentAdded) allGridElement.innerHTML = '<p class="status-message info">No channels or matches available.</p>';
        }
        function renderFavoritesTabContent() { /* ... (keep existing code) ... */
            const favoritesGridElement = document.getElementById('Favorites'); if (!favoritesGridElement) return; favoritesGridElement.innerHTML = ''; if (favoriteItemIds.length === 0) { favoritesGridElement.innerHTML = '<p class="status-message info">Favorites list is empty.<br>Click ☆ to add.</p>'; return; } const fragment = document.createDocumentFragment(); let validFavoritesFound = 0; favoriteItemIds.forEach(itemId => { let itemElement = null; if (itemId.startsWith('match-')) { const matchIndex = parseInt(itemId.split('-')[1], 10); if (!isNaN(matchIndex) && matchIndex >= 0 && matchIndex < allMatchesData.length) { itemElement = createMatchBoxElement(allMatchesData[matchIndex], itemId); } } else if (itemId.includes('-channel-')) { const parts = itemId.split('-'); const category = parts[0]; const channelIndex = parseInt(parts[parts.length - 1], 10); if (allChannelsData[category] && !isNaN(channelIndex) && channelIndex >= 0 && channelIndex < allChannelsData[category].length) { itemElement = createChannelBoxElement(allChannelsData[category][channelIndex], itemId); } } if (itemElement) { fragment.appendChild(itemElement); validFavoritesFound++; } else { console.warn(`Could not find data for favorite item ID: ${itemId}.`); } }); favoritesGridElement.appendChild(fragment); if (validFavoritesFound === 0 && favoriteItemIds.length > 0) { favoritesGridElement.innerHTML = '<p class="status-message info">Previously favorited items could not be found.</p>'; }
        }

        // --- Element Creation ---
        function createChannelBoxElement(channelData, uniqueItemId) {
            if (!channelData || !uniqueItemId || !channelData.name || !Array.isArray(channelData.srcs)) return null;
            const { name, srcs } = channelData;
            const boxElement = document.createElement('div');
            boxElement.className = 'channel-box';
            boxElement.id = uniqueItemId;
            boxElement.tabIndex = 0;
            boxElement.dataset.itemName = name;
            boxElement.dataset.itemType = 'channel';
            boxElement.dataset.sources = JSON.stringify(srcs);
            boxElement.dataset.itemId = uniqueItemId;
            const isFavorite = favoriteItemIds.includes(uniqueItemId);
            // --- UPDATED: Added custom-fullscreen-btn ---
            boxElement.innerHTML = `
                <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites" aria-pressed="${isFavorite}" tabindex="-1">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                </button>
                <div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content">
                    <h3>${name}</h3>
                </div>
                <div class="channel-info"></div>
                <div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header">
                    <div class="player-area">
                        <div class="loader"></div>
                        <div class="player-message" role="alert"></div>
                        <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe>
                        <video controls autoplay muted playsinline title="Stream Player" poster="${CONFIG.placeholderImage}"></video>
                        <button class="custom-fullscreen-btn" aria-label="Enter Fullscreen" title="Enter Fullscreen">
                            ${SVG_ENTER_FULLSCREEN}
                        </button>
                    </div>
                    <div class="stream-buttons"></div>
                    <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p>
                </div>`;
            return boxElement;
        }

        function createMatchBoxElement(matchData, uniqueItemId) {
             if (!matchData || !uniqueItemId || !matchData.team1 || !matchData.team2) return null;
             const { team1, team2, logo1 = '', logo2 = '', time = '', league = '', pt = [], uk = [], es = [] } = matchData;
             const boxElement = document.createElement('div');
             boxElement.className = 'channel-box';
             boxElement.id = uniqueItemId;
             boxElement.tabIndex = 0;
             const matchTitle = `${team1} vs ${team2}`;
             boxElement.dataset.itemName = matchTitle;
             boxElement.dataset.searchTerms = `${team1} ${team2} ${league}`.toLowerCase();
             boxElement.dataset.itemType = 'match';
             const allSources = { pt: pt || [], uk: uk || [], es: es || [] };
             boxElement.dataset.sources = JSON.stringify(allSources);
             boxElement.dataset.itemId = uniqueItemId;
             const isFavorite = favoriteItemIds.includes(uniqueItemId);
             const createLogoHtml = (logoUrl, altText) => logoUrl ? `<img src="${logoUrl}" alt="${altText} logo" class="match-logo" loading="lazy" onerror="this.style.display='none'; this.onerror=null;">` : '<span class="match-logo" aria-label="No logo available" style="display: inline-block; width: 40px;"></span>';
             // --- UPDATED: Added custom-fullscreen-btn ---
             boxElement.innerHTML = `
                <button class="favorite-button ${isFavorite ? 'is-favorite' : ''}" aria-label="${isFavorite ? 'Remove from' : 'Add to'} Favorites" aria-pressed="${isFavorite}" tabindex="-1">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                </button>
                <div class="channel-header" id="${uniqueItemId}-header" aria-expanded="false" aria-controls="${uniqueItemId}-content">
                    ${createLogoHtml(logo1, team1)}
                    <h3>${matchTitle}</h3>
                    ${createLogoHtml(logo2, team2)}
                </div>
                <div class="channel-info">
                    ${league ? `<span>${league}</span>` : ''}
                    ${league && time ? '<span aria-hidden="true"> | </span>' : ''}
                    ${time ? `<span>${time}</span>` : ''}
                </div>
                <div class="iframe-container" id="${uniqueItemId}-content" role="region" aria-labelledby="${uniqueItemId}-header">
                    <div class="player-area">
                        <div class="loader"></div>
                        <div class="player-message" role="alert"></div>
                        <iframe allow="autoplay; fullscreen; encrypted-media; picture-in-picture" allowfullscreen title="Stream Player"></iframe>
                        <video controls autoplay muted playsinline title="Stream Player" poster="${CONFIG.placeholderImage}"></video>
                         <button class="custom-fullscreen-btn" aria-label="Enter Fullscreen" title="Enter Fullscreen">
                             ${SVG_ENTER_FULLSCREEN}
                         </button>
                    </div>
                    <div class="stream-buttons"></div>
                    <p class="box-disclaimer">${BOX_DISCLAIMER_TEXT}</p>
                </div>`;
             return boxElement;
        }

        function createStreamSourceButton(label, url, parentBoxElement) { /* ... (keep existing code - handles 3 toggle states) ... */
           const buttonElement = document.createElement('button'); buttonElement.className = 'stream-button'; buttonElement.textContent = label || 'Source'; buttonElement.dataset.streamUrl = url; buttonElement.onclick = (event) => { event.stopPropagation(); const itemId = parentBoxElement.dataset.itemId; if (openInPlayerPageEnabled && itemId) { const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`; console.log(`Opening player page in new tab: ${label} (${playerPageUrl})`); window.open(playerPageUrl, '_blank'); buttonElement.classList.add('active'); setTimeout(() => buttonElement.classList.remove('active'), 500); } else if (openInNewTabEnabled) { console.log(`Opening source in new tab: ${label} (${url})`); window.open(url, '_blank'); buttonElement.classList.add('active'); setTimeout(() => buttonElement.classList.remove('active'), 500); } else { console.log(`Loading stream in player: ${label} (${url})`); loadStreamIntoPlayer(buttonElement, url, parentBoxElement); } }; return buttonElement;
       }

        // --- Event Listener Setup for Channel Boxes ---
        function addChannelBoxEventListeners(scopeElement = document) { /* ... (keep existing code - handles box click/activation based on toggle) ... */
             if (!scopeElement) return; scopeElement.querySelectorAll('.channel-box:not([data-listener-added="true"])').forEach(boxElement => { const headerElement = boxElement.querySelector('.channel-header'); const infoElement = boxElement.querySelector('.channel-info'); const favoriteButtonElement = boxElement.querySelector('.favorite-button'); const boxId = boxElement.id; const itemId = boxElement.dataset.itemId; const handleBoxClick = (event) => { if (event.target.closest('.favorite-button') || event.target.closest('.custom-fullscreen-btn')) return; /* MODIFIED: Ignore fullscreen btn click */ if (openInPlayerPageEnabled && itemId) { const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`; console.log(`Box clicked: Opening player page in new tab (${playerPageUrl})`); window.open(playerPageUrl, '_blank'); } else { console.log("Box clicked: Expanding/Collapsing box."); toggleItemBoxExpansion(boxElement); } }; if (headerElement) headerElement.addEventListener('click', handleBoxClick); if (infoElement && getComputedStyle(infoElement).display !== 'none') { infoElement.addEventListener('click', handleBoxClick); } if (favoriteButtonElement && boxId) { favoriteButtonElement.addEventListener('click', (event) => { event.stopPropagation(); toggleFavoriteStatus(boxId, favoriteButtonElement); }); } else if (!boxId) { console.warn("Could not attach favorite listener: Box ID missing.", boxElement); } boxElement.addEventListener('keydown', (event) => { if ((event.key === 'Enter' || event.key === 'Ok') && !boxElement.classList.contains('expanded')) { event.preventDefault(); if (openInPlayerPageEnabled && itemId) { const playerPageUrl = `player.html?item=${encodeURIComponent(itemId)}`; console.log(`Box activated (keyboard): Opening player page in new tab (${playerPageUrl})`); window.open(playerPageUrl, '_blank'); } else { console.log("Box activated (keyboard): Expanding box."); toggleItemBoxExpansion(boxElement); } } }); boxElement.dataset.listenerAdded = 'true'; });
        }

        // --- Tab Management ---
        function activateTab(tabIdToShow) { /* ... (keep existing code) ... */
            if (tabIdToShow === activeTabId && document.getElementById(tabIdToShow)?.classList.contains('active')) return; console.log(`Activating tab: ${tabIdToShow}`); activeTabId = tabIdToShow; tabsContainerElement.querySelectorAll('.tab-button').forEach(btn => { const isActive = btn.dataset.tab === tabIdToShow; btn.classList.toggle('active', isActive); btn.setAttribute('aria-selected', isActive ? 'true' : 'false'); }); channelGridElements.forEach(grid => { const isGridActive = grid.id === tabIdToShow; grid.classList.toggle('active', isGridActive); grid.setAttribute('tabindex', isGridActive ? '0' : '-1'); }); if (currentlyExpandedBoxElement) collapseItemBox(currentlyExpandedBoxElement); localStorage.setItem(CONFIG.lastTabKey, tabIdToShow); if (tabIdToShow === 'Favorites') { renderFavoritesTabContent(); addChannelBoxEventListeners(document.getElementById('Favorites')); } filterVisibleContent(searchInputElement.value); setTimeout(() => document.getElementById(tabIdToShow)?.focus({ preventScroll: true }), 50);
        }

        // --- Search Filtering ---
        function filterVisibleContent(searchTerm) { /* ... (keep existing code) ... */
             const normalizedSearchTerm = searchTerm.toLowerCase().trim(); const isSearching = normalizedSearchTerm !== ''; let resultsFoundInActiveTab = false; const activeGridElement = document.getElementById(activeTabId); const allBoxes = document.querySelectorAll('.channel-box'); allBoxes.forEach(boxElement => { const parentGridId = boxElement.closest('.channel-grid')?.id; if (!parentGridId) return; const itemName = boxElement.dataset.itemName?.toLowerCase() || ''; const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || ''; const matchesSearch = itemName.includes(normalizedSearchTerm) || additionalSearchTerms.includes(normalizedSearchTerm); let shouldBeVisible = false; if (!isSearching) { shouldBeVisible = (parentGridId === activeTabId); } else { if (parentGridId === activeTabId) shouldBeVisible = matchesSearch; else if (activeTabId === 'ALL') shouldBeVisible = matchesSearch; else if (activeTabId === 'Favorites') shouldBeVisible = matchesSearch && favoriteItemIds.includes(boxElement.id); } if (!boxElement.classList.contains('expanded')) { boxElement.classList.toggle('hidden', !shouldBeVisible); boxElement.tabIndex = shouldBeVisible ? 0 : -1; } else { boxElement.classList.remove('hidden'); boxElement.tabIndex = -1; } if (shouldBeVisible && parentGridId === activeTabId && !boxElement.classList.contains('expanded')) { resultsFoundInActiveTab = true; } }); if (activeGridElement) { let noResultsMsgEl = activeGridElement.querySelector('.status-message.info.no-results'); if (!noResultsMsgEl) { noResultsMsgEl = document.createElement('p'); noResultsMsgEl.className = 'status-message info no-results'; noResultsMsgEl.style.display = 'none'; activeGridElement.prepend(noResultsMsgEl); } if (isSearching && !resultsFoundInActiveTab) { noResultsMsgEl.innerHTML = `No results found for "<strong>${searchTerm}</strong>" in this section.`; noResultsMsgEl.style.display = 'block'; } else { noResultsMsgEl.style.display = 'none'; } }
        }

        // --- Channel Box Expansion ---
        function toggleItemBoxExpansion(boxElement) { /* ... (keep existing code) ... */
             if (!boxElement) return; const isCurrentlyExpanded = boxElement.classList.contains('expanded'); const headerElement = boxElement.querySelector('.channel-header'); if (!isCurrentlyExpanded && currentlyExpandedBoxElement && currentlyExpandedBoxElement !== boxElement) { collapseItemBox(currentlyExpandedBoxElement); } if (!isCurrentlyExpanded) { expandItemBox(boxElement); if (headerElement) headerElement.setAttribute('aria-expanded', 'true'); } else { collapseItemBox(boxElement); if (headerElement) headerElement.setAttribute('aria-expanded', 'false'); }
        }

        /**
         * Expands a box.
         * **MODIFIED:** Conditionally hides player area if 'Open source in new tab' is ON.
         * **MODIFIED:** Calls setupCustomFullscreen.
         * @param {HTMLDivElement} boxElement - The box element to expand.
         */
        function expandItemBox(boxElement) {
            if (!boxElement) return;
            const playerAreaElement = boxElement.querySelector('.player-area');

            // --- Hide/Show Player Area based on Toggle ---
            if (playerAreaElement) {
                if (openInNewTabEnabled || openInPlayerPageEnabled) { // MODIFIED: Also hide if player page toggle is on
                    console.log("   Hiding player area because a 'new tab' toggle is ON.");
                    playerAreaElement.style.display = 'none'; // Hide player
                } else {
                    console.log("   Ensuring player area is visible.");
                    playerAreaElement.style.display = 'flex'; // Ensure player is visible (flex centers loader/msg)
                }
            }
            // --- End of Logic ---

            boxElement.classList.add('expanded');
            boxElement.classList.remove('hidden'); // Ensure it's visible
            boxElement.tabIndex = -1; // Remove from main grid tab flow when expanded
            currentlyExpandedBoxElement = boxElement; // Update global tracker

            populateStreamsAndLoadFirst(boxElement); // Load stream buttons and attempt to play (if needed)
            setupCustomFullscreen(boxElement); // --- NEW: Setup the fullscreen button listener ---

            // --- Smooth Scroll into View ---
            setTimeout(() => {
                 boxElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                 // --- Focus Management (Accessibility) ---
                 const firstStreamButton = boxElement.querySelector('.stream-button');
                 if (firstStreamButton) setTimeout(() => firstStreamButton.focus({ preventScroll: true }), 150);
                 else boxElement.querySelector('.iframe-container')?.focus(); // Fallback
            }, 100);
        }

        /**
         * Collapses a box.
         * **MODIFIED:** Ensures player area display is reset.
         * @param {HTMLDivElement} boxElement - The box element to collapse.
         */
        function collapseItemBox(boxElement) {
            if (!boxElement) return;
            const wasCurrentlyExpanded = (currentlyExpandedBoxElement === boxElement);
            const playerAreaElement = boxElement.querySelector('.player-area'); // Get player area

            boxElement.classList.remove('expanded');

            if (wasCurrentlyExpanded) {
                currentlyExpandedBoxElement = null;
            }

            // --- Clean Up Player and Buttons ---
            clearPlayerStateInBox(boxElement); // Ensure player is fully cleared
            const streamButtonsContainer = boxElement.querySelector('.stream-buttons');
            if (streamButtonsContainer) streamButtonsContainer.innerHTML = ''; // Clear buttons

            // --- Reset Player Area Display ---
            if (playerAreaElement) {
                playerAreaElement.style.display = ''; // Reset display (will default to CSS 'flex')
            }
            // --- End of Logic ---

            // Update accessibility attribute
            const headerElement = boxElement.querySelector('.channel-header');
            if(headerElement) headerElement.setAttribute('aria-expanded', 'false');

            // --- Restore Focusability and Re-apply Filter ---
            const normalizedSearchTerm = searchInputElement.value.toLowerCase().trim(); const isSearching = normalizedSearchTerm !== ''; const parentGridId = boxElement.closest('.channel-grid')?.id; const itemName = boxElement.dataset.itemName?.toLowerCase() || ''; const additionalSearchTerms = boxElement.dataset.searchTerms?.toLowerCase() || ''; const matchesSearch = itemName.includes(normalizedSearchTerm) || additionalSearchTerms.includes(normalizedSearchTerm); let shouldBeVisibleAfterCollapse = false; if (!isSearching) { shouldBeVisibleAfterCollapse = (parentGridId === activeTabId); } else { if (parentGridId === activeTabId) shouldBeVisibleAfterCollapse = matchesSearch; else if (activeTabId === 'ALL') shouldBeVisibleAfterCollapse = matchesSearch; else if (activeTabId === 'Favorites') shouldBeVisibleAfterCollapse = matchesSearch && favoriteItemIds.includes(boxElement.id); } boxElement.classList.toggle('hidden', !shouldBeVisibleAfterCollapse); boxElement.tabIndex = shouldBeVisibleAfterCollapse ? 0 : -1;

            // --- Restore Focus ---
            if (wasCurrentlyExpanded && shouldBeVisibleAfterCollapse) setTimeout(() => boxElement.focus({ preventScroll: true }), 50);
            else if (wasCurrentlyExpanded) setTimeout(() => document.getElementById(activeTabId)?.focus({ preventScroll: true }), 50);
        }

        function populateStreamsAndLoadFirst(boxElement) { /* ... (keep existing code - handles 3 toggle states) ... */
            const sourcesJson = boxElement.dataset.sources; const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); const playerAreaElement = boxElement.querySelector('.player-area'); if (!sourcesJson || !streamButtonsContainer || !playerAreaElement) { displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); return; } streamButtonsContainer.innerHTML = ''; let firstStreamUrl = null; let firstStreamButtonElement = null; let streamCount = 0; const fragment = document.createDocumentFragment(); try { const sourcesData = JSON.parse(sourcesJson); if (Array.isArray(sourcesData)) { sourcesData.forEach((src) => { const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null); const label = typeof src === 'object' && src.label ? src.label : `Source ${streamCount + 1}`; if (url) { if (!firstStreamUrl) firstStreamUrl = url; const button = createStreamSourceButton(label, url, boxElement); if (!firstStreamButtonElement) firstStreamButtonElement = button; fragment.appendChild(button); streamCount++; } }); } else if (typeof sourcesData === 'object' && sourcesData !== null) { Object.entries(sourcesData).forEach(([langKey, sourcesInLang]) => { if (sourcesInLang && Array.isArray(sourcesInLang) && sourcesInLang.length > 0) { const langGroupDiv = document.createElement('div'); const langLabel = document.createElement('strong'); langLabel.textContent = `${langKey.toUpperCase()}:`; langGroupDiv.appendChild(langLabel); sourcesInLang.forEach((src) => { const url = typeof src === 'object' && src.url ? src.url : (typeof src === 'string' ? src : null); const label = typeof src === 'object' && src.label ? src.label : `Src ${streamCount + 1}`; if (url) { if (!firstStreamUrl) firstStreamUrl = url; const button = createStreamSourceButton(label, url, boxElement); if (!firstStreamButtonElement) firstStreamButtonElement = button; langGroupDiv.appendChild(button); streamCount++; } }); fragment.appendChild(langGroupDiv); } }); } streamButtonsContainer.appendChild(fragment); if (streamCount === 0) { displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerStateInBox(boxElement); } else if (openInPlayerPageEnabled) { console.log("Skipping auto-load: 'Open player page' enabled."); if (playerAreaElement.style.display !== 'none') displayMessageInPlayerArea(playerAreaElement, `<strong>Select a source</strong><span>'Open player page' active. Click to open.</span>`, false); clearPlayerStateInBox(boxElement); } else if (openInNewTabEnabled) { console.log("Skipping auto-load: 'Open source' enabled."); if (playerAreaElement.style.display !== 'none') displayMessageInPlayerArea(playerAreaElement, `<strong>Select a source</strong><span>'Open source' active. Click to open.</span>`, false); clearPlayerStateInBox(boxElement); } else if (firstStreamUrl && firstStreamButtonElement) { const videoEl = boxElement.querySelector('video'); const iframeEl = boxElement.querySelector('iframe'); if (!videoEl.classList.contains('active') && !iframeEl.classList.contains('active')) { console.log("Auto-loading first stream (toggles OFF)."); loadStreamIntoPlayer(firstStreamButtonElement, firstStreamUrl, boxElement); } else { console.log("Skipping auto-load, player active."); const activeSrc = videoEl.src || iframeEl.src; if (activeSrc) streamButtonsContainer.querySelectorAll('.stream-button').forEach(btn => btn.classList.toggle('active', btn.dataset.streamUrl === activeSrc)); } } else { console.error("Inconsistency: Streams counted, no first URL/Button.", boxElement.id); displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer); clearPlayerStateInBox(boxElement); } } catch (error) { console.error("Failed to parse sources/create buttons:", boxElement.id, error); streamButtonsContainer.innerHTML = '<p class="status-message error">Error loading sources.</p>'; clearPlayerStateInBox(boxElement); }
        }
        function displayNoStreamsAvailable(playerAreaElement, streamButtonsContainer) { /* ... (keep existing code) ... */
             const message = 'No stream sources listed for this item.'; if (streamButtonsContainer) streamButtonsContainer.innerHTML = `<p style="color: var(--text-secondary); font-size: 0.9em; padding: 10px 0;">${message}</p>`; if (playerAreaElement && playerAreaElement.style.display !== 'none') displayMessageInPlayerArea(playerAreaElement, `<strong>No Streams Available</strong><span>${message}</span>`, false);
        }

        // --- Stream Handling (Only used when BOTH toggles are false) ---
        function loadStreamIntoPlayer(clickedButtonElement, streamUrl, parentBoxElement) { /* ... (keep existing code, including safety check for toggles) ... */
            if (!parentBoxElement || !streamUrl || typeof streamUrl !== 'string') return; if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadStreamIntoPlayer called, but toggle enabled. Aborting."); clearPlayerStateInBox(parentBoxElement); return; } console.log(`>>> loadStreamIntoPlayer START for box ${parentBoxElement.id}: ${streamUrl}`); const playerAreaElement = parentBoxElement.querySelector('.player-area'); const loaderElement = playerAreaElement?.querySelector('.loader'); const messageContainerElement = playerAreaElement?.querySelector('.player-message'); const iframeElement = playerAreaElement?.querySelector('iframe'); const videoElement = playerAreaElement?.querySelector('video'); if (!playerAreaElement || !loaderElement || !messageContainerElement || !iframeElement || !videoElement) return; clearPlayerStateInBox(parentBoxElement); messageContainerElement.classList.remove('visible'); loaderElement.classList.add('visible'); const streamButtonsContainer = parentBoxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) streamButtonsContainer.querySelectorAll('.stream-button').forEach(b => b.classList.remove('active')); if (clickedButtonElement) clickedButtonElement.classList.add('active'); if (!streamUrl.startsWith('http://') && !streamUrl.startsWith('https://')) { loaderElement.classList.remove('visible'); displayMessageInPlayerArea(playerAreaElement, `<strong>Invalid URL</strong><span>Link must start with http/https.</span>`, true, streamUrl, parentBoxElement); return; } setTimeout(() => { try { const urlObject = new URL(streamUrl); if (urlObject.pathname.toLowerCase().endsWith('.m3u8')) loadHlsStreamIntoVideo(streamUrl, videoElement, playerAreaElement); else loadUrlIntoIframe(streamUrl, iframeElement, playerAreaElement); } catch (error) { loaderElement.classList.remove('visible'); displayMessageInPlayerArea(playerAreaElement, `<strong>URL Error</strong><span>Could not process link.</span>`, true, streamUrl, parentBoxElement); } }, 50);
        }
        function clearPlayerStateInBox(boxElement) { /* ... (keep existing code) ... */
             if (!boxElement) return; const playerAreaElement = boxElement.querySelector('.player-area'); if (!playerAreaElement) return; const videoElement = playerAreaElement.querySelector('video'); const iframeElement = playerAreaElement.querySelector('iframe'); const loaderElement = playerAreaElement.querySelector('.loader'); const messageContainerElement = playerAreaElement.querySelector('.player-message'); if (currentHlsInstance && videoElement && currentHlsInstance.media === videoElement) { try { currentHlsInstance.destroy(); } catch (e) {} currentHlsInstance = null; } if (iframeElement) { if (iframeElement.getAttribute('src') && iframeElement.getAttribute('src') !== 'about:blank') iframeElement.src = 'about:blank'; iframeElement.classList.remove('active'); } if (videoElement) { videoElement.pause(); if (videoElement.hasAttribute('src')) videoElement.removeAttribute('src'); if (videoElement.currentSrc) videoElement.load(); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; } if (loaderElement) loaderElement.classList.remove('visible'); if (messageContainerElement) messageContainerElement.classList.remove('visible'); const streamButtonsContainer = boxElement.querySelector('.stream-buttons'); if (streamButtonsContainer) streamButtonsContainer.querySelectorAll('.stream-button.active').forEach(b => b.classList.remove('active'));
             // --- NEW: Ensure custom fullscreen button is hidden when player clears ---
             const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn');
             if (fsBtn) fsBtn.style.display = 'none';
             // --- End NEW ---
        }
        function displayMessageInPlayerArea(playerAreaElement, messageHtml, showTryNextButton, failedUrl = null, parentBoxElement = null) { /* ... (keep existing code - checks toggles for Try Next btn) ... */
             const messageContainerElement = playerAreaElement?.querySelector('.player-message'); const loaderElement = playerAreaElement?.querySelector('.loader'); const videoElement = playerAreaElement?.querySelector('video'); const iframeElement = playerAreaElement?.querySelector('iframe'); if (!messageContainerElement || !loaderElement || !playerAreaElement) return; if (videoElement) videoElement.classList.remove('active'); if (iframeElement) iframeElement.classList.remove('active'); loaderElement.classList.remove('visible'); messageContainerElement.innerHTML = messageHtml; if (showTryNextButton && failedUrl && parentBoxElement && !openInNewTabEnabled && !openInPlayerPageEnabled) { const nextButtonElement = findNextAvailableStreamButton(failedUrl, parentBoxElement); if (nextButtonElement) { const tryNextBtn = document.createElement('button'); tryNextBtn.className = 'try-next-button'; tryNextBtn.textContent = 'Try Next Source'; tryNextBtn.onclick = (event) => { event.stopPropagation(); nextButtonElement.click(); }; messageContainerElement.appendChild(document.createElement('br')); messageContainerElement.appendChild(tryNextBtn); } else { const noMoreSpan = document.createElement('span'); noMoreSpan.style.cssText = 'font-size:0.8em;margin-top:10px;display:block;'; noMoreSpan.textContent = '(No more sources available)'; messageContainerElement.appendChild(noMoreSpan); } } else if (showTryNextButton && (openInNewTabEnabled || openInPlayerPageEnabled)) { console.log("   'Try Next Source' button skipped (toggle enabled)."); } messageContainerElement.classList.add('visible');
             // --- NEW: Hide custom fullscreen button when message shows ---
             const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn');
             if (fsBtn) fsBtn.style.display = 'none';
             // --- End NEW ---
        }
        function findNextAvailableStreamButton(failedUrl, parentBoxElement) { /* ... (keep existing code) ... */
             if (!failedUrl || !parentBoxElement) return null; const allButtonsInBox = parentBoxElement.querySelectorAll('.stream-button'); let foundFailedButton = false; for (let i = 0; i < allButtonsInBox.length; i++) { const currentButton = allButtonsInBox[i]; if (currentButton.dataset.streamUrl === failedUrl) foundFailedButton = true; else if (foundFailedButton) return currentButton; } return null;
        }
        function loadHlsStreamIntoVideo(hlsUrl, videoElement, playerAreaElement) { /* ... (keep existing code, including safety check) ... */
            if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadHlsStreamIntoVideo called, but toggle enabled. Aborting."); return; } const parentBoxElement = videoElement.closest('.channel-box'); videoElement.poster = CONFIG.placeholderImage; if (Hls.isSupported()) { if (currentHlsInstance && currentHlsInstance.media === videoElement) { currentHlsInstance.destroy(); currentHlsInstance = null; } else if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; } currentHlsInstance = new Hls({ liveSyncDurationCount: 2, manifestLoadingTimeOut: 15000, levelLoadingTimeOut: 15000, fragLoadingTimeOut: 20000, manifestLoadErrorMaxRetry: 3, levelLoadErrorMaxRetry: 4, fragLoadErrorMaxRetry: 5 }); const hlsErrorListener = (event, data) => { if (!currentHlsInstance || currentHlsInstance.media !== videoElement) return; console.error('HLS.js Error:', data.type, data.details, data.fatal); let userMessage = `Stream Error (${data.details || 'Unknown'}).`; if (data.type === Hls.ErrorTypes.NETWORK_ERROR) userMessage = `Network Error (${data.details}).`; else if (data.type === Hls.ErrorTypes.MEDIA_ERROR && data.details !== 'bufferStalledError') userMessage = `Media Error (${data.details}).`; if (data.fatal) { displayMessageInPlayerArea(playerAreaElement, `<strong>${userMessage}</strong>`, true, hlsUrl, parentBoxElement); if (currentHlsInstance && currentHlsInstance.media === videoElement) { currentHlsInstance.destroy(); currentHlsInstance = null; } videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; } }; const hlsManifestParsedListener = () => { if (!currentHlsInstance || currentHlsInstance.media !== videoElement) return; playerAreaElement.querySelector('.loader').classList.remove('visible'); videoElement.classList.add('active'); videoElement.muted = true; videoElement.play().catch(error => { if (currentHlsInstance && currentHlsInstance.media === videoElement) { displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>${error.name === 'NotAllowedError' ? 'Click play to start.' : error.message}</span>`, error.name !== 'NotAllowedError', hlsUrl, parentBoxElement); if(error.name !== 'NotAllowedError') videoElement.classList.remove('active'); playerAreaElement.querySelector('.loader').classList.remove('visible'); } }); }; currentHlsInstance.on(Hls.Events.ERROR, hlsErrorListener); currentHlsInstance.on(Hls.Events.MANIFEST_PARSED, hlsManifestParsedListener); currentHlsInstance.attachMedia(videoElement); currentHlsInstance.loadSource(hlsUrl); } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) { if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; } const handleNativeLoadedMetadata = () => { if (videoElement.getAttribute('src') !== hlsUrl) return; playerAreaElement.querySelector('.loader').classList.remove('visible'); videoElement.classList.add('active'); videoElement.muted = true; videoElement.play().catch(error => { if(videoElement.getAttribute('src') === hlsUrl){ displayMessageInPlayerArea(playerAreaElement, `<strong>Playback Error</strong><span>${error.name==='NotAllowedError'?'Click play.':error.message}</span>`, error.name !== 'NotAllowedError', hlsUrl, parentBoxElement); if(error.name !== 'NotAllowedError') videoElement.classList.remove('active'); playerAreaElement.querySelector('.loader').classList.remove('visible'); } }); }; const handleNativeError = () => { if (videoElement.getAttribute('src') !== hlsUrl) return; const err = videoElement.error; const msg = err ? (err.message || `code ${err.code}`) : 'Unknown'; displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>Native HLS failed: ${msg}.</span>`, true, hlsUrl, parentBoxElement); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; playerAreaElement.querySelector('.loader').classList.remove('visible'); }; videoElement.removeEventListener('loadedmetadata', handleNativeLoadedMetadata); videoElement.removeEventListener('error', handleNativeError); videoElement.addEventListener('loadedmetadata', handleNativeLoadedMetadata); videoElement.addEventListener('error', handleNativeError); videoElement.src = hlsUrl; videoElement.load(); } else { displayMessageInPlayerArea(playerAreaElement, `<strong>Unsupported Stream</strong><span>Browser cannot play HLS (.m3u8).</span>`, false); videoElement.classList.remove('active'); videoElement.poster = CONFIG.placeholderImage; playerAreaElement.querySelector('.loader').classList.remove('visible'); }
             // --- NEW: Show custom fullscreen button after loading attempt ---
             const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn');
             if (fsBtn) fsBtn.style.display = 'block';
             updateFullscreenButtonState(); // Update icon based on current state
             // --- End NEW ---
        }
        function loadUrlIntoIframe(iframeUrl, iframeElement, playerAreaElement) { /* ... (keep existing code, including safety check) ... */
            if (openInNewTabEnabled || openInPlayerPageEnabled) { console.warn("loadUrlIntoIframe called, but toggle enabled. Aborting."); return; } const parentBoxElement = iframeElement.closest('.channel-box'); let iframeLoadTimeoutId = null; let isLoadSuccessful = false; if (currentHlsInstance) { currentHlsInstance.destroy(); currentHlsInstance = null; } const cleanupIframeLoad = () => { clearTimeout(iframeLoadTimeoutId); iframeElement.onload = null; iframeElement.onerror = null; }; const handleIframeLoadFailure = (reason) => { cleanupIframeLoad(); if (iframeElement.getAttribute('src') === iframeUrl) { displayMessageInPlayerArea(playerAreaElement, `<strong>Stream Error</strong><span>${reason}. Might be offline/blocked.</span>`, true, iframeUrl, parentBoxElement); iframeElement.classList.remove('active'); iframeElement.src = 'about:blank'; playerAreaElement.querySelector('.loader').classList.remove('visible'); } }; iframeLoadTimeoutId = setTimeout(() => { if (!isLoadSuccessful && iframeElement.getAttribute('src') === iframeUrl) handleIframeLoadFailure(`Load timeout (${CONFIG.iframeLoadTimeoutMs / 1000}s)`); }, CONFIG.iframeLoadTimeoutMs); iframeElement.onload = () => { if (iframeElement.getAttribute('src') === iframeUrl) { isLoadSuccessful = true; cleanupIframeLoad(); playerAreaElement.querySelector('.loader').classList.remove('visible'); iframeElement.classList.add('active'); } else if (iframeElement.getAttribute('src') !== 'about:blank') { /* ignore */ } }; iframeElement.onerror = () => { if (iframeElement.getAttribute('src') === iframeUrl) handleIframeLoadFailure("onError event fired"); }; iframeElement.src = iframeUrl;
             // --- NEW: Show custom fullscreen button after loading attempt ---
             const fsBtn = playerAreaElement.querySelector('.custom-fullscreen-btn');
             if (fsBtn) fsBtn.style.display = 'block';
             updateFullscreenButtonState(); // Update icon based on current state
             // --- End NEW ---
        }

        // --- NEW: Custom Fullscreen Logic ---
        /**
         * Sets up the event listener for the custom fullscreen button within a box.
         * @param {HTMLDivElement} boxElement The channel/match box element.
         */
        function setupCustomFullscreen(boxElement) {
            const btn = boxElement.querySelector('.custom-fullscreen-btn');
            const iframe = boxElement.querySelector('iframe');
            const video = boxElement.querySelector('video');

            if (btn && (iframe || video)) {
                btn.onclick = (event) => {
                    event.stopPropagation(); // Prevent box collapse/expand

                    // Determine which element is active and should be fullscreened
                    const elementToFullscreen = iframe?.classList.contains('active') ? iframe : (video?.classList.contains('active') ? video : null);

                    if (!elementToFullscreen) {
                        console.warn("No active element (iframe/video) found to fullscreen in box:", boxElement.id);
                        return;
                    }

                    toggleBrowserFullscreen(elementToFullscreen);
                };
            } else {
                console.warn("Could not find fullscreen button or player elements in box:", boxElement.id);
            }
        }

        /**
         * Toggles fullscreen mode for a given element using the Fullscreen API.
         * @param {HTMLElement} element The element to make fullscreen (iframe or video).
         */
        function toggleBrowserFullscreen(element) {
            if (!element) return;

            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                // --- Enter Fullscreen ---
                console.log("Requesting fullscreen for element:", element);
                if (element.requestFullscreen) {
                    element.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                } else if (element.webkitRequestFullscreen) { /* Safari */
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) { /* Firefox */
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) { /* IE11 */
                    element.msRequestFullscreen();
                }
            } else {
                // --- Exit Fullscreen ---
                console.log("Exiting fullscreen.");
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        }

        /**
         * Updates the appearance (icon, label) of all visible custom fullscreen buttons
         * based on the current fullscreen state of the document.
         */
        function updateFullscreenButtonState() {
            const isFullscreenActive = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            const buttons = document.querySelectorAll('.custom-fullscreen-btn');

            buttons.forEach(btn => {
                if (isFullscreenActive) {
                    btn.innerHTML = SVG_EXIT_FULLSCREEN;
                    btn.setAttribute('aria-label', 'Exit Fullscreen');
                    btn.setAttribute('title', 'Exit Fullscreen');
                } else {
                    btn.innerHTML = SVG_ENTER_FULLSCREEN;
                    btn.setAttribute('aria-label', 'Enter Fullscreen');
                    btn.setAttribute('title', 'Enter Fullscreen');
                }
            });
             console.log("Fullscreen state changed. Is active:", isFullscreenActive);
        }
        // --- End NEW Custom Fullscreen Logic ---


        // --- Utility Functions ---
        function updateTimestampDisplay() { /* ... (keep existing code) ... */
             try { const now = new Date(); const timeString = new Intl.DateTimeFormat(navigator.language || 'en-US', { hour: '2-digit', minute: '2-digit' }).format(now); lastUpdatedTimestampElement.textContent = `Updated: ${timeString}`; } catch (error) { lastUpdatedTimestampElement.textContent = "Updated: Error"; }
        }
        function showInitialLoadingMessage(text = "Loading...") { /* ... (keep existing code) ... */
             initialLoadingMessageElement.textContent = text; initialLoadingMessageElement.style.display = 'block';
        }
        function hideInitialLoadingMessage() { /* ... (keep existing code) ... */
              initialLoadingMessageElement.style.display = 'none';
        }
        function showDataFetchErrorMessage(text = "An error occurred.") { /* ... (keep existing code) ... */
               dataFetchErrorMessageElement.innerHTML = `<strong>Error</strong><span>${text}</span>`; dataFetchErrorMessageElement.style.display = 'block';
        }

    } // End of initializeApp() function
</script>

</body>
</html>
